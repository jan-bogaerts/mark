# MarkdownCode > components > toolbar > home
{"# MarkdownCode > services > Undo service": {"UndoService": [{"feature": "The user can undo the last action performed.", "function": "undoLastAction", "description": "undoLastAction will revert the last action performed by the user, restoring the previous state of the application."}, {"feature": "The user can redo the last action that was undone.", "function": "redoLastUndo", "description": "redoLastUndo will redo the last action that was undone by the user, restoring the state of the application to the state after the undo operation."}]}, "# MarkdownCode > services > build service": {"BuildService": [{"feature": "The user can initiate a build process.", "function": "initiateBuild", "description": "The initiateBuild function will start the build process for the selected project. It will trigger the necessary actions to compile the code, run tests, and generate the build artifacts."}, {"feature": "The user can specify build configurations.", "function": "setBuildConfigurations", "description": "The setBuildConfigurations function will allow the user to define different build configurations for their project. This can include settings such as target platform, optimization level, and build flags."}, {"feature": "The user can view the build status.", "function": "getBuildStatus", "description": "The getBuildStatus function will retrieve the current status of the build process. This can include information such as whether the build is in progress, completed successfully, or encountered any errors."}, {"feature": "The user can cancel a build process.", "function": "cancelBuild", "description": "The cancelBuild function will stop the ongoing build process for the selected project. It will terminate any running tasks and clean up any temporary files or resources."}]}}
# MarkdownCode > components > toolbar > home > file section
{"# MarkdownCode > services": {"DialogService": [{"feature": "Open a dialog box to select a file", "function": "openDialog", "description": "The DialogService should provide a function called openDialog that will display a dialog box to the user, allowing them to select a file. This function should use the default electron dialog box for this purpose."}, {"feature": "Show an error dialog", "function": "showErrorDialog", "description": "The DialogService should provide a function called showErrorDialog that will display an error dialog to the user. This function should be used as an exception handler for any errors that occur during the file management actions."}, {"feature": "Show a save-as dialog", "function": "showSaveAsDialog", "description": "The DialogService should provide a function called showSaveAsDialog that will display a save-as dialog to the user. This function should be used when the user wants to save the current project to a new location."}, {"feature": "Wrap actions in an error handler and show the error", "function": "wrapInErrorHandler", "description": "The DialogService should provide a function called wrapInErrorHandler that will wrap the file management actions in an error handler and display the error to the user using the showErrorDialog function."}]}, "# MarkdownCode > services > project service": {"ProjectService": [{"feature": "New Project", "function": "createNewProject", "description": "createNewProject will clear the current project data and create a new project."}, {"feature": "Open", "function": "openProject", "description": "openProject will show a dialog box to select a file, and if a file is selected, it will ask the project service to load the file."}, {"feature": "Save", "function": "saveProject", "description": "saveProject will save the current project to file. It will be enabled when the project service has a filename for the project and the undo service has undo data. If the project file does not have a filename, it will show a save-as dialog. If the user provides a valid filename, it will call the project-service 'save' function with the filename as a parameter. If the project service already has a filename, it will call the project service save without a parameter."}, {"feature": "Save as", "function": "saveProjectAs", "description": "saveProjectAs will save the current project to a new location. It will be enabled when the undo service has undo data. It will show an electron save-as dialog, and if the user selects a file, it will ask the project-service to save the project to the new location."}, {"feature": "Auto-save", "function": "toggleAutoSave", "description": "toggleAutoSave is a function that will be called when the auto-save toggle button is pressed. It will ask the project service to update the auto-save state, and the toggle button's state will follow that of the project service's auto-save state."}]}, "# MarkdownCode > services > Undo service": {"UndoService": [{"feature": "Undo changes in the current project", "function": "undo", "description": "The undo function should undo the last change made in the current project. It should retrieve the previous state of the project from the undo service and update the project accordingly."}, {"feature": "Redo changes in the current project", "function": "redo", "description": "The redo function should redo the last undone change in the current project. It should retrieve the next state of the project from the undo service and update the project accordingly."}, {"feature": "Check if there are changes to undo", "function": "hasUndoData", "description": "The hasUndoData function should check if there are any changes in the current project that can be undone. It should return a boolean value indicating whether there are changes to undo or not."}, {"feature": "Check if there are changes to redo", "function": "hasRedoData", "description": "The hasRedoData function should check if there are any undone changes in the current project that can be redone. It should return a boolean value indicating whether there are changes to redo or not."}]}}
# MarkdownCode > components > toolbar > home > edit section
{"# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The user can initiate the cut command of the selection service", "function": "cut", "description": "The cut function should initiate the cut command of the selection service. It should check if the selection service has any data marked as selected and perform the cut operation on that data."}, {"feature": "The user can initiate the copy command of the selection service", "function": "copy", "description": "The copy function should initiate the copy command of the selection service. It should check if the selection service has any data marked as selected and perform the copy operation on that data."}, {"feature": "The user can initiate the paste command of the selection service", "function": "paste", "description": "The paste function should initiate the paste command of the selection service. It should check if the clipboard contains text data and perform the paste operation using that data."}, {"feature": "The user can initiate the delete command of the selection service", "function": "delete", "description": "The delete function should initiate the delete command of the selection service. It should check if the selection service has any data marked as selected and perform the delete operation on that data."}, {"feature": "The user can select all the text in the currently active window", "function": "selectAll", "description": "The selectAll function should select all the text in the currently active window. It should perform this operation using the selection service."}, {"feature": "The user can clear the current selection buffer", "function": "clearSelection", "description": "The clearSelection function should clear the current selection buffer. It should check if the selection service has any data marked as selected and perform the clear operation on that data."}]}}
# MarkdownCode > components > toolbar > home > undo section
{"# MarkdownCode > services > project service": {"ProjectService": [{"feature": "The undo-section component contains actions that the undo / redo service can perform.", "function": "getUndoActions", "description": "getUndoActions will retrieve a list of all the actions that can be undone by the undo / redo service."}, {"feature": "The undo-section component contains actions that the undo / redo service can perform.", "function": "getRedoActions", "description": "getRedoActions will retrieve a list of all the actions that can be redone by the undo / redo service."}]}, "# MarkdownCode > services > Undo service": {"UndoService": [{"feature": "Undo the last action", "function": "undoLastAction", "description": "The undoLastAction function should be provided by the UndoService and it should undo the last action performed by the current project's undo-service."}, {"feature": "Redo the last action", "function": "redoLastAction", "description": "The redoLastAction function should be provided by the UndoService and it should redo the last action performed by the project's undo-service."}]}}
# MarkdownCode > components > toolbar > home > build section
{"# MarkdownCode > services > project service": {"ProjectService": [{"feature": "The build-section component contains actions that the build-service can perform.", "function": "performBuildActions", "description": "performBuildActions will execute the actions available in the build-section component. This function will trigger the rendering of code for the entire project or for the currently active fragment, depending on the selected action."}, {"feature": "The build-section component supports the following actions:", "function": "getBuildActions", "description": "getBuildActions will retrieve a list of all the actions supported by the build-section component. This function will return the names and descriptions of the available actions, such as 'Render All Code' and 'Render Code for Active Fragment'."}, {"feature": "The 'Render All Code' action button is enabled when the result-cache of any of the services in the GPT-service's list has an out-of-date result fragment or missing result fragments.", "function": "isRenderAllCodeEnabled", "description": "isRenderAllCodeEnabled will check if the 'Render All Code' action button should be enabled. This function will determine if any of the services in the GPT-service's list have out-of-date result fragments or missing result fragments in their result-cache. If so, the button will be enabled."}, {"feature": "The 'Render Code for Active Fragment' action button is enabled when the selected fragment is out-of-date or missing in any of the result-caches of any of the services in the GPT-service's list.", "function": "isRenderCodeForActiveFragmentEnabled", "description": "isRenderCodeForActiveFragmentEnabled will check if the 'Render Code for Active Fragment' action button should be enabled. This function will determine if the selected fragment is out-of-date or missing in any of the result-caches of the services in the GPT-service's list. If so, the button will be enabled."}, {"feature": "The 'Active Topic in Active Prompt' action button is enabled when the selected fragment is out-of-date or missing in the service related to the currently selected", "function": "isActiveTopicInActivePromptEnabled", "description": "isActiveTopicInActivePromptEnabled will check if the 'Active Topic in Active Prompt' action button should be enabled. This function will determine if the selected fragment is out-of-date or missing in the service related to the currently selected. If so, the button will be enabled."}]}, "# MarkdownCode > services > gpt service": {"GptService": [{"feature": "The build-service can perform actions", "function": "performActions", "description": "performActions will execute the specified actions in the build-service."}, {"feature": "The build-service supports the 'all' action", "function": "startRenderingAllCode", "description": "startRenderingAllCode will initiate the rendering of all the code for the entire project."}, {"feature": "The build-service supports the 'code for active topic' action", "function": "startRenderingCodeForActiveTopic", "description": "startRenderingCodeForActiveTopic will initiate the rendering of all the code files for the currently active fragment."}, {"feature": "The build-service supports the 'active topic in active prompt' action", "function": "startRenderingActiveTopicInActivePrompt", "description": "startRenderingActiveTopicInActivePrompt will initiate the rendering of the active topic in the active prompt."}]}, "# MarkdownCode > services > result-cache service": {"ResultCacheService": [{"feature": "The service should provide a function to check if the result cache of any service in the GPT-service's list has an out-of-date result fragment or missing result fragments.", "function": "checkResultCache", "description": "The checkResultCache function should iterate through the list of services in the GPT-service's list and check if any of their result caches have out-of-date result fragments or missing result fragments. It should return true if any of the result caches are out-of-date or have missing fragments, and false otherwise."}, {"feature": "The service should provide a function to start rendering all the code for the entire project if any of the result caches in the GPT-service's list have out-of-date result fragments or missing result fragments.", "function": "renderAllCode", "description": "The renderAllCode function should check if any of the result caches in the GPT-service's list have out-of-date result fragments or missing result fragments. If any of the result caches are out-of-date or have missing fragments, it should initiate the rendering process for all the code files in the entire project."}, {"feature": "The service should provide a function to start rendering all the code files for the currently active fragment if it is out-of-date or missing in any of the result caches in the GPT-service's list.", "function": "renderActiveFragmentCode", "description": "The renderActiveFragmentCode function should check if the currently active fragment is out-of-date or missing in any of the result caches in the GPT-service's list. If the fragment is out-of-date or missing, it should initiate the rendering process for all the code files related to the active fragment."}]}, "# MarkdownCode > services > build service": {"BuildService": [{"feature": "Start rendering all the code for the entire project", "function": "startRenderingAllCode", "description": "The function startRenderingAllCode will initiate the rendering process for all the code files in the entire project. This function should be called when the user clicks on the 'all' button in the build-section component. It should check if any of the services in the GPT-service's list have an out-of-date result fragment or missing result fragments in their result-cache. If so, it should start rendering the code for the entire project."}, {"feature": "Start rendering all the code files for the currently active fragment", "function": "startRenderingActiveFragmentCode", "description": "The function startRenderingActiveFragmentCode will initiate the rendering process for all the code files related to the currently active fragment. This function should be called when the user clicks on the 'code for active topic' button in the build-section component. It should check if the selected fragment is out-of-date or missing in any of the result-caches of any of the services in the GPT-service's list. If so, it should start rendering the code files for the currently active fragment."}, {"feature": "Start rendering the active topic in the active prompt", "function": "startRenderingActiveTopicInActivePrompt", "description": "The function startRenderingActiveTopicInActivePrompt will initiate the rendering process for the active topic in the active prompt. This function should be called when the user clicks on the 'active topic in active prompt' button in the build-section component. It should check if the selected fragment is out-of-date or missing in the service related to the currently selected. If so, it should start rendering the active topic in the active prompt."}]}}
# MarkdownCode > components > toolbar > format > style section
{"# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The user can select a style from the paragraph style toggle group.", "function": "selectStyle", "description": "The selectStyle function should be able to receive the user's selection from the paragraph style toggle group and apply the selected style as markdown to the text that is currently in the selection service."}]}}
# MarkdownCode > components > toolbar > format > paragraph section
{"# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The user can select text and apply markdown formatting actions.", "function": "applyFormatting", "description": "applyFormatting will take the selected text and apply the specified markdown formatting action, such as turning the selection into a bullet list or numbered list, increasing or decreasing the indent of the selection."}, {"feature": "The state of toggle buttons is updated based on the selected text.", "function": "updateToggleButtons", "description": "updateToggleButtons will update the state of the toggle buttons to reflect the state of the selected text. For example, if the selected text is already in a bullet list, the bullet list toggle button should be in the 'on' state."}]}, "# MarkdownCode > services > Undo service": {"UndoService": []}}
# MarkdownCode > components > toolbar > format > font section
{"# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The state of the toggle buttons is updated to reflect the state of the selected text", "function": "updateToggleButtonsState", "description": "updateToggleButtonsState function should be provided by the SelectionService to update the state of the toggle buttons based on the selected text. This function will be called whenever the text selection is changed."}, {"feature": "The user can set the bold state on/off on the selected text", "function": "toggleBoldState", "description": "toggleBoldState function should be provided by the SelectionService to toggle the bold state on/off on the selected text. This function will be called when the user clicks on the bold toggle button."}, {"feature": "The user can set the italic state on/off on the selected text", "function": "toggleItalicState", "description": "toggleItalicState function should be provided by the SelectionService to toggle the italic state on/off on the selected text. This function will be called when the user clicks on the italic toggle button."}, {"feature": "The user can set the underline state on/off on the selected text", "function": "toggleUnderlineState", "description": "toggleUnderlineState function should be provided by the SelectionService to toggle the underline state on/off on the selected text. This function will be called when the user clicks on the underline toggle button."}, {"feature": "The user can set the strike-through state on/off on the selected text", "function": "toggleStrikeThroughState", "description": "toggleStrikeThroughState function should be provided by the SelectionService to toggle the strike-through state on/off on the selected text. This function will be called when the user clicks on the strike-through toggle button."}]}}
# MarkdownCode > components > toolbar > preferences > GPT section:
{"# MarkdownCode > services": {"DialogService": [{"feature": "The user can enter their API key in a dialog box", "function": "enterApiKey", "description": "The enterApiKey function will open a dialog box where the user can enter their API key. This API key will be used for API calls with the OpenAI platform."}, {"feature": "The user can select a default model from a combobox", "function": "selectDefaultModel", "description": "The selectDefaultModel function will display a combobox where the user can select which default model should be used when requests are sent to OpenAI. The list of available models used to populate the combobox will be provided by the DialogService."}]}, "# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The user can select a default model from a combobox", "function": "getDefaultModel", "description": "getDefaultModel will retrieve the currently selected default model from the combobox."}, {"feature": "The service can provide a list of available models", "function": "getAvailableModels", "description": "getAvailableModels will retrieve a list of all the models that are currently available from the GPT service."}]}, "# MarkdownCode > services > gpt service": {"GptService": [{"feature": "The user can select a default model from a dropdown box", "function": "getDefaultModel", "description": "getDefaultModel will retrieve the default model that is currently selected by the user. This function should return the name or ID of the selected model."}, {"feature": "The user can set a new default model", "function": "setDefaultModel", "description": "setDefaultModel will update the default model selected by the user. This function should take the name or ID of the new default model as a parameter and update the configuration accordingly."}, {"feature": "The service provides a list of available models", "function": "getAvailableModels", "description": "getAvailableModels will retrieve a list of all the models that are currently available. This function should return an array of model names or IDs."}]}, "# MarkdownCode > services > compress service": {"CompressService": [{"feature": "The user can select a default model for compression", "function": "getDefaultModel", "description": "getDefaultModel will retrieve the default model that the user has selected for compression. This function should return the name or ID of the default model."}, {"feature": "The service can provide a list of available models for compression", "function": "getAvailableModels", "description": "getAvailableModels will retrieve a list of all the models that are currently available for compression. This function should return an array of model names or IDs."}]}}
# MarkdownCode > components > toolbar > preferences > view section:
{"# MarkdownCode > services > Theme service": {"ThemeService": [{"feature": "The user can select a preferred color mode from a combobox", "function": "selectColorMode", "description": "selectColorMode will allow the user to choose between light mode and dark mode for the application's theme. This function should update the theme used by the monaco editor."}, {"feature": "The user can select a font from a combobox", "function": "selectFont", "description": "selectFont will provide a list of available fonts for the user to choose from. This function should update the font used by the monaco editor and markdown viewer."}, {"feature": "The user can select a font size from a combobox", "function": "selectFontSize", "description": "selectFontSize will provide a list of available font sizes for the user to choose from. This function should update the font size used by the monaco editor and markdown viewer."}]}}
# MarkdownCode > components > body > editor
{"# MarkdownCode > services > project service": {"ProjectService": [{"feature": "The service should load a project", "function": "loadProject", "description": "loadProject will retrieve the markdown text of a specific project and display it in the editor component."}, {"feature": "The service should update the currently selected line", "function": "updateSelectedLine", "description": "updateSelectedLine will be called by the editor component when the user moves the cursor to another line. It will ask the position-tracking service to update the currently selected line."}]}, "# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The editor component needs to retrieve the currently selected line", "function": "getSelectedLine", "description": "getSelectedLine will retrieve the line number of the currently selected line in the editor component."}, {"feature": "The editor component needs to highlight the currently selected line", "function": "highlightSelectedLine", "description": "highlightSelectedLine will apply a visual highlight to the currently selected line in the editor component."}, {"feature": "The editor component needs to update the currently selected line", "function": "updateSelectedLine", "description": "updateSelectedLine will update the currently selected line in the editor component based on user input or other events."}]}, "# MarkdownCode > services > position-tracking service": {"PositionTrackingService": [{"feature": "Update currently selected line", "function": "updateSelectedLine", "description": "The function updateSelectedLine should be provided by the PositionTrackingService. It will be called by the editor component whenever the user moves the cursor to another line. The function should update the currently selected line in the editor."}]}}
# MarkdownCode > components > body > outline
{"# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The component monitors the position-tracking service for changes to the currently selected text-fragment.", "function": "monitorPositionChanges", "description": "monitorPositionChanges will listen for changes in the currently selected text-fragment and trigger an action when the position changes."}, {"feature": "When the position changes, set the corresponding tree-item as selected.", "function": "setSelectedTreeItem", "description": "setSelectedTreeItem will update the selected tree-item in the outline component when the position of the selected text-fragment changes."}]}, "# MarkdownCode > services > line parser": {"LineParser": [{"feature": "The LineParser should be able to parse a line of text and extract the markdown heading level", "function": "parseLine", "description": "The parseLine function should take a line of text as input and return the markdown heading level of that line. For example, if the input line is '## components', the function should return 2."}, {"feature": "The LineParser should be able to determine the parent of a markdown heading", "function": "getParent", "description": "The getParent function should take a line of text as input and return the parent markdown heading of that line. For example, if the input line is '### comp 1', the function should return '## components'."}, {"feature": "The LineParser should be able to check if a line of text is a markdown heading", "function": "isHeading", "description": "The isHeading function should take a line of text as input and return true if the line is a markdown heading, and false otherwise. For example, if the input line is '## components', the function should return true."}]}, "# MarkdownCode > services > position-tracking service": {"PositionTrackingService": [{"feature": "The component monitors the position-tracking service for changes to the currently selected text-fragment.", "function": "monitorPositionChanges", "description": "monitorPositionChanges will continuously check for changes in the currently selected text-fragment. When a change is detected, it will trigger the corresponding action to update the tree-item as selected."}]}}
# MarkdownCode > components > body > results view
{"# MarkdownCode > services": {"ErrorService": [{"feature": "The user can select a gpt model to be used by the ErrorService.", "function": "selectModel", "description": "selectModel function will allow the user to choose a gpt model from a dropdown menu. The list of available models will be provided by the gpt-service. The selected model will be used by the ErrorService for generating results."}, {"feature": "The user can refresh the result generated by the ErrorService.", "function": "refreshResult", "description": "refreshResult function will update the result generated by the ErrorService. When the user clicks the 'refresh' button, the ErrorService will be triggered to generate a new result based on the current selected model and text block."}, {"feature": "The user can copy the current text displayed in the center to the clipboard.", "function": "copyTextToClipboard", "description": "copyTextToClipboard function will allow the user to copy the text displayed in the center of the view to the clipboard. When the user clicks the 'copy' button, the text will be copied to the clipboard for further use."}], "DialogService": [{"feature": "The user can select a gpt model to be used by the service associated with the current tab.", "function": "selectModelForAll", "description": "selectModelForAll will open a context menu with a list of available gpt models. The user can select a model from the menu, and the function will update the model name for the service associated with the current tab in the results-view."}, {"feature": "The user can select a gpt model to be used by the service associated with the current tab for the currently active fragment.", "function": "selectModelForFragment", "description": "selectModelForFragment will open a context menu with a list of available gpt models. The user can select a model from the menu, and the function will update the model name for the service associated with the current tab and the currently active fragment in the results-view."}, {"feature": "The service can update the result when the 'refresh' button is pressed.", "function": "updateResult", "description": "updateResult will trigger the service to update the result for the currently selected text block in the results-view when the 'refresh' button is pressed."}, {"feature": "The view can monitor changes to the currently selected text-fragment.", "function": "monitorTextFragmentChanges", "description": "monitorTextFragmentChanges will track changes to the currently selected text-fragment using the position-tracking service. When the text-fragment changes, the function will update the content of the currently active tab in the results-view by setting the selected value of the first combobox to the header-title of the text-fragment."}]}, "# MarkdownCode > services > Theme service": {"ThemeService": [{"feature": "The user can select a gpt model to be used by the service associated with the current tab.", "function": "selectModelForService", "description": "selectModelForService will allow the user to choose a gpt model from a dropdown menu. The selected model will be used by the service associated with the current tab."}, {"feature": "The user can select a gpt model to be used by the service associated with the current tab, for the currently active fragment.", "function": "selectModelForFragment", "description": "selectModelForFragment will allow the user to choose a gpt model from a dropdown menu. The selected model will be used by the service associated with the current tab and the currently active fragment."}, {"feature": "The service can update the result when the 'refresh' button is pressed.", "function": "updateResult", "description": "updateResult will trigger the service to update the result when the 'refresh' button is pressed."}]}, "# MarkdownCode > services > project service": {"ProjectService": [{"feature": "The user can select a gpt model to be used by the service associated with the current tab.", "function": "selectModelForAll", "description": "selectModelForAll will open a context menu with a list of available gpt models. The user can select a model from the menu, and the function will update the model name for the service associated with the current tab in the results-view."}, {"feature": "The user can select a gpt model to be used by the service associated with the current tab and the currently active fragment.", "function": "selectModelForFragment", "description": "selectModelForFragment will open a context menu with a list of available gpt models. The user can select a model from the menu, and the function will update the model name for the service associated with the current tab and the currently active fragment in the results-view."}, {"feature": "The user can refresh the result of the service associated with the current tab.", "function": "refreshResult", "description": "refreshResult will update the result of the service associated with the current tab in the results-view."}, {"feature": "The user can copy the current text displayed in the center to the clipboard.", "function": "copyToClipboard", "description": "copyToClipboard will copy the current text displayed in the center of the results-view to the clipboard."}]}, "# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The user can select a gpt model to be used by the service associated with the current tab.", "function": "selectModelForAll", "description": "selectModelForAll will display a submenu with a list of available gpt models. The currently selected model will be highlighted. When a different model is selected, the function will update the model name for the service related to the results-view."}, {"feature": "The user can select a gpt model to be used by the service associated with the current tab and the currently active fragment.", "function": "selectModelForFragment", "description": "selectModelForFragment will display a submenu with a list of available gpt models. The currently selected model will be highlighted. When a different model is selected, the function will update the model name for the service related to the results-view and the current fragment title."}]}, "# MarkdownCode > services > Undo service": {"UndoService": [{"feature": "The user can undo the changes made in the monaco editor of the tab.", "function": "undoChanges", "description": "undoChanges will revert the changes made in the monaco editor of the tab to the previous state."}, {"feature": "The user can redo the changes made in the monaco editor of the tab.", "function": "redoChanges", "description": "redoChanges will reapply the changes made in the monaco editor of the tab that were previously undone."}]}, "# MarkdownCode > services > line parser": {"LineParser": [{"feature": "The user can select a gpt model to be used by the LineParser service.", "function": "selectModel", "description": "selectModel will allow the user to choose a gpt model from a dropdown menu. The selected model will be used by the LineParser service for processing the text."}, {"feature": "The LineParser service can update the selected gpt model.", "function": "updateModel", "description": "updateModel will update the selected gpt model for the LineParser service. This function will be called when the user selects a different model from the dropdown menu."}, {"feature": "The LineParser service can refresh the result.", "function": "refreshResult", "description": "refreshResult will trigger the LineParser service to update the result. This function will be called when the user clicks the 'refresh' button in the LineParser tab."}, {"feature": "The LineParser service can store changes made by the user in the monaco-editor.", "function": "storeChanges", "description": "storeChanges will save any edits made by the user in the monaco-editor back to the result-cache of the LineParser service. The changes will be marked as 'overwritten'."}]}, "# MarkdownCode > services > position-tracking service": {"PositionTrackingService": [{"feature": "The view monitors the position-tracking service for changes to the currently selected text-fragment.", "function": "monitorPositionTrackingService", "description": "The function monitorPositionTrackingService will continuously check for changes in the currently selected text-fragment. Whenever there is a change, it will update the content of the currently active tab by setting the selected value of the first combobox to the header-title of the text-fragment."}]}, "# MarkdownCode > services > gpt service": {"GptService": [{"feature": "The user can select a gpt model to be used by the service associated with the current tab.", "function": "selectModelForService", "description": "selectModelForService allows the user to choose a gpt model from a dropdown menu. The selected model will be used by the service associated with the current tab."}, {"feature": "The user can select a gpt model to be used by the service associated with the current tab and the currently active fragment.", "function": "selectModelForFragment", "description": "selectModelForFragment allows the user to choose a gpt model from a dropdown menu. The selected model will be used by the service associated with the current tab and the currently active fragment."}, {"feature": "The service can update the result when the 'refresh' button is pressed.", "function": "updateResult", "description": "updateResult triggers the service to update the result when the 'refresh' button is pressed."}, {"feature": "The service can store changes made in the monaco-editor back in the result-cache, marked as 'overwritten'.", "function": "storeChanges", "description": "storeChanges saves the changes made in the monaco-editor back in the result-cache of the service, marking them as 'overwritten'."}, {"feature": "The service can retrieve a list of available models.", "function": "getAvailableModels", "description": "getAvailableModels retrieves a list of all the available gpt models from the gpt-service."}, {"feature": "The service can update the model-name for the name of the service related to the results-view.", "function": "updateModelName", "description": "updateModelName updates the model-name for the name of the service related to the results-view when a different model is selected."}, {"feature": "The service can update the model-name for the name of the service related to the results-view and the current fragment-title.", "function": "updateModelNameForFragment", "description": "updateModelNameForFragment updates the model-name for the name of the service related to the results-view and the current fragment-title when a different model is selected."}]}, "# MarkdownCode > services > result-cache service": {"ResultCacheService": [{"feature": "The view creates a tab for each service in the services list provided by the gpt-service.", "function": "createTab", "description": "createTab function will create a tab in the results-view component for each service in the services list. The tab will display the service name as the title."}, {"feature": "The tab content shows a monaco editor containing the result from the result-cache of the service, if available.", "function": "displayResult", "description": "displayResult function will retrieve the result from the result-cache of the service and display it in a monaco editor in the tab content. If the result is not available, the monaco editor will be empty."}, {"feature": "The tab content shows the result text as grayed-out if it is marked as out-of-date.", "function": "markResultAsOutOfDate", "description": "markResultAsOutOfDate function will apply a grayed-out style to the result text in the monaco editor if it is marked as out-of-date."}, {"feature": "The tab content shows the result text in red if it is an overwritten version of the service output.", "function": "markResultAsOverwritten", "description": "markResultAsOverwritten function will apply a red style to the result text in the monaco editor if it is an overwritten version of the service output. The color will be dark-red for the light theme and light-red for the dark theme."}, {"feature": "The tab content includes a 'more' button that opens a context menu.", "function": "openContextMenu", "description": "openContextMenu function will open a context menu when the 'more' button is clicked in the tab content."}, {"feature": "The context menu includes a 'model for all' menu item.", "function": "selectModelForAll", "description": "selectModelForAll function will allow the user to select a GPT model to be used by the service associated with the current tab. The available models will be provided by the gpt-service's list of available models."}, {"feature": "The context menu includes a 'model for fragment' menu item.", "function": "selectModelForFragment", "description": "selectModelForFragment function will allow the user to select a GPT model to be used by the service associated with the current tab and the currently active fragment. The available models will be provided by the gpt-service's list of available models."}, {"feature": "The context menu includes a 'refresh' button.", "function": "refreshResult", "description": "refreshResult function will update the result of the service when the 'refresh' button is pressed in the context menu."}, {"feature": "The view monitors changes to the currently selected text-fragment.", "function": "monitorTextFragmentChanges", "description": "monitorTextFragmentChanges function will monitor changes to the currently selected text-fragment using the position-tracking service. When the text-fragment changes, the content of the currently active tab will be updated by setting the selected value of the first combobox to the header-title of the text-fragment."}]}, "# MarkdownCode > services > build service": {"BuildService": [{"feature": "The user can select a gpt model to be used by the BuildService.", "function": "selectModel", "description": "selectModel will allow the user to choose a gpt model from a dropdown menu. The list of available models will be provided by the gpt-service. The selected model will be used by the BuildService for generating results."}, {"feature": "The BuildService can update the selected gpt model.", "function": "updateModel", "description": "updateModel will update the selected gpt model for the BuildService. It will be triggered when the user selects a different model from the dropdown menu. The gpt-service will be asked to update the model name for the BuildService."}, {"feature": "The BuildService can update the result.", "function": "updateResult", "description": "updateResult will be triggered when the user clicks the 'refresh' button. The BuildService will update the result based on the selected gpt model and the currently active text fragment."}, {"feature": "The BuildService can store user edits in the result-cache.", "function": "storeEdits", "description": "storeEdits will store any changes made by the user in the monaco-editor of the tab. The changes will be stored back in the result-cache of the BuildService and marked as 'overwritten'."}]}, "# MarkdownCode > services > compress service": {"CompressService": [{"feature": "The user can select a gpt model to be used by the CompressService.", "function": "selectModel", "description": "selectModel will allow the user to choose a gpt model from a dropdown menu. The selected model will be used by the CompressService for generating compressed text."}, {"feature": "The user can refresh the result generated by the CompressService.", "function": "refreshResult", "description": "refreshResult will trigger the CompressService to update the result. This can be done by pressing a 'refresh' button in the view."}, {"feature": "The user can copy the current compressed text to the clipboard.", "function": "copyToClipboard", "description": "copyToClipboard will allow the user to copy the currently displayed compressed text to the clipboard. This can be done by clicking a 'copy' button in the view."}]}}
# MarkdownCode > services > Theme service
{"# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The user can select a theme from a dropdown menu where the options are provided by the service.", "function": "getThemeOptions", "description": "getThemeOptions will retrieve a list of all the available theme options (e.g., light, dark) that the user can select from."}, {"feature": "The service allows the user to set the selected theme.", "function": "setSelectedTheme", "description": "setSelectedTheme will set the currently selected theme based on the user's choice."}, {"feature": "Every component can retrieve the currently selected theme from the service.", "function": "getSelectedTheme", "description": "getSelectedTheme will retrieve the currently selected theme that can be applied to each component."}, {"feature": "The main window refreshes its content when the selected theme is updated.", "function": "refreshContent", "description": "refreshContent will update the content of the main window to reflect the changes made to the selected theme."}]}}
# MarkdownCode > services > line parser
{"# MarkdownCode > services > project service": {"ProjectService": [{"feature": "Parsing markdown lines and updating links in the project's data-list items", "function": "parseMarkdownLines", "description": "The parseMarkdownLines function accepts a string as input, which is the text that needs to be parsed, and the index number of the line in the project. It trims the line and converts it to lowercase. If the line starts with a '#', it is considered a header. If there is already a text-fragment object at that index position in the project, it updates the object; otherwise, it creates a new line object. If it is a new text fragment, it updates all 'line-fragments' below it until the next text-fragment, setting their 'parent' field to point to the new text fragment. It counts the number of '#' characters in front of the title to determine the level or depth of the text-fragment. It searches for the first text-fragment that is above the current text-fragment and is one level higher (e.g., if the current text-fragment has '###', it searches for the first text-fragment with '##' or at level 2) and uses that as the parent of the text-fragment representing the line being parsed. If the line is not a header, it stores it as a line-object. If there is already a line-object at the index position in the project, it updates the line; otherwise, it creates a new line-object. It finds the first text-fragment that is higher up the data list and uses that as the parent of the line-object."}]}}
# MarkdownCode > services > position-tracking service
{"# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The service keeps track of the currently selected line number.", "function": "getSelectedLine", "description": "getSelectedLine will retrieve the line number of the currently selected line."}, {"feature": "The service keeps track of the text-fragment related to the currently selected line.", "function": "getSelectedTextFragment", "description": "getSelectedTextFragment will retrieve the text-fragment related to the currently selected line."}, {"feature": "The service keeps track of an eventTarget that stores the events which monitor changes in the currently selected text-fragment.", "function": "getEventTarget", "description": "getEventTarget will retrieve the eventTarget object that stores the events which monitor changes in the currently selected text-fragment."}, {"feature": "The service provides a method to set the currently selected line.", "function": "setSelectedLine", "description": "setSelectedLine will set the currently selected line to a new value. If the new value is different from the current selected line, it will trigger the on-changed event for all the registered events."}]}, "# MarkdownCode > services > Undo service": {"UndoService": [{"feature": "The service keeps track of the currently selected line number.", "function": "getSelectedLine", "description": "getSelectedLine will retrieve the line number of the currently selected line."}, {"feature": "The service keeps track of the text-fragment related to the currently selected line.", "function": "getSelectedTextFragment", "description": "getSelectedTextFragment will retrieve the text-fragment related to the currently selected line."}, {"feature": "The service keeps track of an eventTarget that stores the events which monitor changes in the currently selected text-fragment.", "function": "getEventTarget", "description": "getEventTarget will retrieve the eventTarget object that stores the events which monitor changes in the currently selected text-fragment."}, {"feature": "The service provides a method to set the currently selected line.", "function": "setSelectedLine", "description": "setSelectedLine will set the currently selected line to a new value. If the new value is different from the current selected line, it will trigger the on-changed event for all the registered events."}]}}
# MarkdownCode > services > result-cache service
{"# MarkdownCode > services": {"DialogService": [{"feature": "Caching results", "function": "cacheResults", "description": "The DialogService needs to provide a function called cacheResults. This function will allow other services to store their calculated results for each text fragment and keep track of whether the result has become out of date or not. The function should take the result value, the key of the project text fragment, and any additional result values from other services as parameters. It should update the cache's dictionary with the new result and mark it as still valid."}, {"feature": "Updating cache", "function": "updateCache", "description": "The DialogService needs to provide a function called updateCache. This function will be called by other services whenever they calculate a new result. It should take the key of the project text fragment and any additional result values from other services as parameters. If the key is not yet present in the cache's dictionary, a new cache item object should be created with the result value and marked as still valid. If the key is already present, the cache item should be retrieved and its result should be updated to still valid."}, {"feature": "Monitoring changes", "function": "monitorChanges", "description": "The DialogService needs to provide a function called monitorChanges. This function will be used to register event handlers with other objects that the parent service uses as input. It should take either the project service or another cache service as a parameter. Whenever the event handler is triggered, the cache service should check the secondary dictionary for any entries related to the changed text fragment. For each entry, it should mark the corresponding cache item as out of date and notify any other cache services that monitor this cache service."}, {"feature": "Loading cache from file", "function": "loadCacheFromFile", "description": "The DialogService needs to provide a function called loadCacheFromFile. This function will be responsible for loading the cache's dictionary from a JSON file. The name of the file should be specified by the service that creates the DialogService instance. The JSON file should contain the primary dictionary, the secondary dictionary, and the last save date of the project file. The last save date will be used to verify if the results are still valid or not."}]}, "# MarkdownCode > services > project service": {"ProjectService": [{"feature": "The service allows other services to store and manage previously retrieved results for text fragments.", "function": "storeResult", "description": "storeResult function is used to store the result of a calculation performed on a text fragment. It takes the key of the project text fragment and the result value as parameters. If the key is already present in the cache, the function updates the result value. If the key is not present, a new cache item object is created with the result value and marked as still-valid."}, {"feature": "The service can check if a result has become out of date.", "function": "checkResultValidity", "description": "checkResultValidity function is used to check if a result stored in the cache has become out of date. It takes the key of the project text fragment as a parameter and returns a boolean value indicating whether the result is still valid or not."}, {"feature": "The service can monitor changes in project text fragments and result fragments.", "function": "monitorChanges", "description": "monitorChanges function is used to register event handlers with the project service and other cache services. It allows the service to react to changes in text fragments and mark the corresponding results as out of date. When triggered, the function checks the secondary dictionary for entries related to the changed text fragment and marks the corresponding results as out of date in the primary dictionary. It also notifies other cache services if necessary."}, {"feature": "The service can load and save the cache data from/to a JSON file.", "function": "loadCacheData", "description": "loadCacheData function is used to load the cache data from a JSON file. It reads the primary dictionary, secondary dictionary, and last save date from the file and updates the cache accordingly."}, {"feature": "The service can load and save the cache data from/to a JSON file.", "function": "saveCacheData", "description": "saveCacheData function is used to save the cache data to a JSON file. It writes the primary dictionary, secondary dictionary, and current date as the last save date to the file."}]}, "# MarkdownCode > services > Selection service": {"SelectionService": [{"feature": "The service allows other services to store and retrieve previously calculated results for text fragments.", "function": "storeResult", "description": "storeResult function will take a text fragment key and its corresponding result as input and store it in the cache's primary dictionary. If the key already exists, the function will update the result with the new value."}, {"feature": "The service can check if a stored result is still valid or has become out of date.", "function": "checkResultValidity", "description": "checkResultValidity function will take a text fragment key as input and check if the corresponding result in the cache's primary dictionary is still valid or has become out of date. It will return a boolean value indicating the result's validity."}, {"feature": "The service can update the state of a stored result to still-valid.", "function": "updateResultState", "description": "updateResultState function will take a text fragment key as input and update the state of the corresponding result in the cache's primary dictionary to still-valid."}, {"feature": "The service can search for the title of a text fragment in the secondary dictionary.", "function": "searchTitle", "description": "searchTitle function will take a text fragment title as input and search for it in the cache's secondary dictionary. If the title is found, it will return the corresponding list of keys from the primary dictionary."}, {"feature": "The service can add a new entry to the secondary dictionary.", "function": "addEntry", "description": "addEntry function will take a text fragment title and its corresponding key from the primary dictionary as input and add it to the cache's secondary dictionary. If the title already exists, it will append the key to the existing list of keys."}, {"feature": "The service can load the cache data from a JSON file.", "function": "loadCacheData", "description": "loadCacheData function will load the cache's primary and secondary dictionaries, as well as the last save date of the project file, from a specified JSON file."}, {"feature": "The service registers event handlers with objects used as input by the parent service.", "function": "registerEventHandler", "description": "registerEventHandler function will register an event handler with an object used as input by the parent service. This can be either the project service to monitor text fragment changes or another cache service to monitor cache result changes."}, {"feature": "The service reacts to changes in text fragments by marking corresponding entries in the primary dictionary as out-of-date.", "function": "reactToTextFragmentChanges", "description": "reactToTextFragmentChanges function will be triggered by the event handler when a text fragment change is detected. It will search for the corresponding entries in the primary dictionary and mark them as out-of-date."}, {"feature": "The service notifies other cache services when a text fragment from a result becomes out-of-date.", "function": "notifyCacheServices", "description": "notifyCacheServices function will be called when a text fragment from a result becomes out-of-date. It will notify other cache services that monitor this cache service about the out-of-date text fragment."}]}, "# MarkdownCode > services > Undo service": {"UndoService": [{"feature": "The service allows other services to store previously retrieved results for each text fragment.", "function": "storeResult", "description": "storeResult function will take in the text fragment and its corresponding result as parameters. It will store the result in the cache, associating it with the text fragment."}, {"feature": "The service can check if a result has become out of date.", "function": "checkResultValidity", "description": "checkResultValidity function will take in the text fragment as a parameter and check if the result associated with it is still valid or has become out of date. It will return a boolean value indicating the result's validity."}, {"feature": "The service can update the result of a text fragment to still-valid.", "function": "updateResultValidity", "description": "updateResultValidity function will take in the text fragment as a parameter and update the result associated with it to still-valid state."}, {"feature": "The service can search for the title of a text fragment in a secondary dictionary.", "function": "searchTitleInDictionary", "description": "searchTitleInDictionary function will take in the title of a text fragment as a parameter and search for it in the secondary dictionary. It will return the corresponding list of keys from the primary dictionary."}, {"feature": "The service can add a new entry to the secondary dictionary.", "function": "addEntryToDictionary", "description": "addEntryToDictionary function will take in the title of a text fragment and the key from the primary dictionary as parameters. It will add a new entry to the secondary dictionary, associating the title with the key."}, {"feature": "The service can update an existing entry in the secondary dictionary.", "function": "updateEntryInDictionary", "description": "updateEntryInDictionary function will take in the title of a text fragment and the key from the primary dictionary as parameters. It will update the existing entry in the secondary dictionary by adding the key to the list of keys associated with the title."}, {"feature": "The service can store the results in a JSON file.", "function": "storeResultsInFile", "description": "storeResultsInFile function will store the primary dictionary, secondary dictionary, and last save date in a JSON file. The name of the file is specified by the service that creates the instance of the class."}, {"feature": "The service can load the results from a JSON file.", "function": "loadResultsFromFile", "description": "loadResultsFromFile function will load the primary dictionary, secondary dictionary, and last save date from a JSON file. It will verify the validity of the results by comparing the last save date with the last-modified date of the project."}, {"feature": "The service can register event handlers with input objects.", "function": "registerEventHandler", "description": "registerEventHandler function will take in an input object as a parameter and register an event handler with it. This allows the service to monitor changes in the input object and react accordingly."}, {"feature": "The service can mark entries in the primary dictionary as out-of-date.", "function": "markEntriesAsOutOfDate", "description": "markEntriesAsOutOfDate function will take in a list of entries from the secondary dictionary as a parameter. It will search for each entry in the primary dictionary and mark the corresponding result as out-of-date."}, {"feature": "The service can notify other cache services about out-of-date results.", "function": "notifyCacheServices", "description": "notifyCacheServices function will take in the specified text fragment from the result as a parameter. It will notify other cache services that monitor this cache service about the specified text fragment going out-of-date."}]}, "# MarkdownCode > services > position-tracking service": {"PositionTrackingService": [{"feature": "Caching results", "function": "cacheResults", "description": "The PositionTrackingService should have a function called cacheResults that allows it to store the results of its calculations. This function should take in the key of the project text-fragment and the result value as parameters. It should update the cache's dictionary by creating a new cache-item object with the result and marking it as still-valid. If the key is already present, it should retrieve the cache item and update its result to still-valid."}, {"feature": "Updating cache on changes", "function": "updateCacheOnChanges", "description": "The PositionTrackingService should have a function called updateCacheOnChanges that registers an event handler with each object that the service uses as input. This function should be triggered whenever a change occurs in the input objects. It should check the secondary dictionary in the cache for any entries related to the changed text-fragment. For each entry, it should mark the corresponding cache item in the primary dictionary as out-of-date. If there are any other cache services monitoring this cache-service, it should notify them that the specified text-fragment has gone out-of-date."}, {"feature": "Loading cache from file", "function": "loadCacheFromFile", "description": "The PositionTrackingService should have a function called loadCacheFromFile that loads the cache's data from a JSON file. This function should take in the file name as a parameter. It should load the primary dictionary, secondary dictionary, and last save date from the file. The last save date should be used to verify if the results are still valid or not. If the last save date doesn't match the last-modified date of the project, it indicates that something is out-of-sync and the results in the file should be considered out-of-date."}]}, "# MarkdownCode > services > gpt service": {"GptService": [{"feature": "The service allows other services to store and manage previously retrieved results for text fragments.", "function": "storeResult", "description": "storeResult function will take a text fragment and its corresponding result as input and store it in the cache. It will also update the state of the result to still-valid."}, {"feature": "The service allows other services to check if a result has become out of date.", "function": "checkResult", "description": "checkResult function will take a text fragment as input and check if its corresponding result in the cache is still valid or has become out of date."}, {"feature": "The service allows other services to update the result of a text fragment in the cache.", "function": "updateResult", "description": "updateResult function will take a text fragment and its updated result as input and update the result in the cache. It will also mark the result as still-valid."}, {"feature": "The service allows other services to search for the title of a text fragment in the secondary dictionary.", "function": "searchTitle", "description": "searchTitle function will take a title as input and search for it in the secondary dictionary. If the title is found, it will return the corresponding list of keys from the primary dictionary."}, {"feature": "The service allows other services to register event handlers for monitoring changes in text fragments.", "function": "registerEventHandler", "description": "registerEventHandler function will take an object as input and register an event handler with it. The event handler will be triggered when the object's text fragments have changed."}, {"feature": "The service allows other cache services to monitor changes in cache results.", "function": "monitorCacheResults", "description": "monitorCacheResults function will notify other cache services when a specified text fragment from the result has gone out-of-date."}]}, "# MarkdownCode > services > build service": {"BuildService": [{"feature": "The service allows other services to store and manage previously retrieved results for text fragments.", "function": "storeResults", "description": "storeResults function will take in the result of a calculation on a text fragment and store it in the cache. It will also keep track of whether the result has become out of date or not."}, {"feature": "The service allows other services to update the cache with new results.", "function": "updateCache", "description": "updateCache function will update the cache with new results for a specific text fragment. If the text fragment is already present in the cache, it will update the result to still-valid."}, {"feature": "The service allows other services to search for a specific text fragment in the cache.", "function": "searchCache", "description": "searchCache function will search for a specific text fragment in the cache and retrieve the corresponding result. It will also check if the result is still valid or out of date."}, {"feature": "The service allows other services to monitor changes in text fragments.", "function": "monitorChanges", "description": "monitorChanges function will register an event handler with the project service or other cache services to monitor changes in text fragments. When triggered, it will check the secondary dictionary to react to changes in single text fragments and mark the corresponding cache entries as out-of-date."}, {"feature": "The service allows other cache services to monitor changes in the cache.", "function": "monitorCacheChanges", "description": "monitorCacheChanges function will notify other cache services when a specific text fragment in the cache has gone out-of-date. This allows the system to react to changes in cache results even if they were derived from multiple input text fragments."}]}, "# MarkdownCode > services > compress service": {"CompressService": [{"feature": "The service can store and retrieve results for each text fragment", "function": "storeResult", "description": "storeResult function will take a text fragment key and its corresponding result as input and store it in the cache's primary dictionary. If the key is already present, the function will update the result to the new value."}, {"feature": "The service can check if a result is still valid or out-of-date", "function": "checkResultValidity", "description": "checkResultValidity function will take a text fragment key as input and check if the result associated with that key is still valid or out-of-date. It will return a boolean value indicating the result's validity."}, {"feature": "The service can update the state of a result to still-valid", "function": "updateResultState", "description": "updateResultState function will take a text fragment key as input and update the state of the result associated with that key to still-valid. This function is called when the service calculates a new result for the same text fragment."}, {"feature": "The service can search for the title of a text fragment in the secondary dictionary", "function": "searchTitleInSecondaryDictionary", "description": "searchTitleInSecondaryDictionary function will take a title as input and search for it in the cache's secondary dictionary. If the title is found, it will return the corresponding list of keys from the primary dictionary. If the title is not found, it will return an empty list."}, {"feature": "The service can add a new entry to the secondary dictionary", "function": "addEntryToSecondaryDictionary", "description": "addEntryToSecondaryDictionary function will take a title and a key as input and add a new entry to the cache's secondary dictionary. If the title is already present, it will append the key to the existing list of keys. If the title is not present, it will create a new entry with the key as the value."}, {"feature": "The service can register event handlers with other objects", "function": "registerEventHandler", "description": "registerEventHandler function will take an object as input and register an event handler with it. The event handler will be triggered when the object's state changes. This function is used to monitor changes in text fragments or cache results."}, {"feature": "The service can mark a result as out-of-date", "function": "markResultAsOutOfDate", "description": "markResultAsOutOfDate function will take a text fragment key as input and mark the result associated with that key as out-of-date. This function is called when the cache service detects changes in a text fragment or when other cache services notify it about out-of-date results."}, {"feature": "The service can notify other cache services about out-of-date results", "function": "notifyOtherCacheServices", "description": "notifyOtherCacheServices function will take a text fragment key as input and notify other cache services that monitor this cache service about the specified text fragment going out-of-date. This function is called when the cache service detects changes in a text fragment."}]}}
# MarkdownCode > services > build service
{"# MarkdownCode > services > project service": {"ProjectService": [{"feature": "The service turns the markdown project data list into source code.", "function": "convertMarkdownToSourceCode", "description": "convertMarkdownToSourceCode takes the markdown project data list as input and iteratively generates conversions on the different text frames. It starts with the original markdown code and finally ends with source code files that are stored on disk."}, {"feature": "The service builds the project by performing certain actions.", "function": "buildProject", "description": "buildProject performs the following actions for each text-fragment in the project: it asks the compress service to render its result."}]}, "# MarkdownCode > services > gpt service": {"GptService": [{"feature": "The service uses a set of GptServices to generate conversions on different text frames.", "function": "generateConversions", "description": "generateConversions will take the original markdown code and iteratively generate conversions on different text frames using the GptServices provided by the service."}, {"feature": "The service asks the compress service to render the result of each text-fragment in the project.", "function": "renderResult", "description": "renderResult will call the compress service to render the result of each text-fragment in the project."}]}, "# MarkdownCode > services > compress service": {"CompressService": [{"feature": "The service can compress text fragments", "function": "compressText", "description": "compressText will take a text fragment as input and compress it using the compress service. The function should return the compressed version of the text fragment."}]}}
# MarkdownCode > services > compress service
{"# MarkdownCode > services > project service": {"ProjectService": [{"feature": "The compress service takes a text fragment and asks the gpt service to make it shorter.", "function": "compressText", "description": "compressText will take a text fragment as input and call the gpt service to make it shorter."}, {"feature": "The get-result function calls the GPT-service with the following parameters:", "function": "getResult", "description": "getResult will call the GPT-service with the specified parameters to retrieve the result."}, {"feature": "Useful to check if the gpt service understands the fragment and can be used as input for other processes.", "function": "checkFragment", "description": "checkFragment will check if the gpt service understands the fragment and can be used as input for other processes."}, {"feature": "This service uses a result-cache-service to store all the results and keep track of when the build has gone out-of-date.", "function": "updateResultCache", "description": "updateResultCache will update the result-cache-service whenever the get-result function is called."}]}, "# MarkdownCode > services > gpt service": {"GptService": [{"feature": "The compress service takes a text fragment and asks the gpt service to make it shorter.", "function": "compressText", "description": "compressText will take a text fragment as input and call the GptService to make it shorter."}, {"feature": "the get-result function calls the GPT-service with the following parameters:", "function": "getResult", "description": "getResult will call the GptService with the specified parameters to retrieve the result."}, {"feature": "Useful to check if the gpt service understands the fragment and can be used as input for other processes.", "function": "checkFragment", "description": "checkFragment will check if the GptService understands the given text fragment and if it can be used as input for other processes."}]}, "# MarkdownCode > services > result-cache service": {"ResultCacheService": [{"feature": "The result-cache-service stores all the results and keeps track of when the build has gone out-of-date.", "function": "updateResultCache", "description": "updateResultCache function updates the result-cache with the result of the get-result function. It stores the result under the same key as the input parameter of get-result."}]}, "# MarkdownCode > services > build service": {"BuildService": [{"feature": "The compress service takes a text fragment and asks the gpt service to make it shorter.", "function": "compressText", "description": "compressText function will take a text fragment as input and call the gpt service to make it shorter."}, {"feature": "The get-result function calls the GPT-service with the following parameters:", "function": "getResult", "description": "getResult function will call the GPT-service with the specified parameters."}, {"feature": "Useful to check if the gpt service understands the fragment and can be used as input for other processes.", "function": "checkFragment", "description": "checkFragment function will check if the gpt service understands the fragment and can be used as input for other processes."}, {"feature": "This service uses a result-cache-service to store all the results and keep track of when the build has gone out-of-date.", "function": "updateResultCache", "description": "updateResultCache function will update the result-cache-service with the result of the get-result function."}]}}
