{"cache":{"be67508d-8316-462a-b24e-4df2b34def0f":{"result":[],"prompt":["Mark is an ideation and software building tool driven by machine learning. It allows users to enter text in markdown which is automatically analyzed for various parameters and which can be converted into executable software code.",""],"state":"still-valid"},"7bff2308-d88b-408e-8082-7f7034afa59e":{"result":[],"prompt":["- developed in javascript (ES6)","- it uses electron as it's runtime","- The UI is built using react and antd",""],"state":"still-valid"},"58516b7b-3add-4daf-9f27-46e0ba1066ab":{"result":[],"prompt":[""],"state":"still-valid"},"80a81923-8079-4820-b50c-5cd3df1b12e1":{"result":[],"prompt":["- the main-window component is the content of the first window that is shown when the application starts.","- the root of the main window consists out of a configProvider component (from antd) which is used to apply the theme to the antd components: `theme={{algorithm: theme === 'dark' ? darkAlgorithm : defaultAlgorithm}}`","- it contains the following components:","  - a toolbar: located at the top of the window.","  - an extra div (together with the toolbar in the header), with classname `os-draggable`, used to drag the window around","  - a body: this component occupies all of the remaining space in the window",""],"state":"still-valid"},"af17bd18-7341-4623-af40-b35190024b95":{"result":[],"prompt":["- the log-window component is used as the content of the secondary window of the application and shows log messages that are generated by the application.","- When the component is loaded, call `window.electron.onLogMsg` to register the event handler `handleLogMsg` for receiving messages.","- When the component is unloaded, call `window.electron.removeOnLogMsg(handleLogMsg)` to clean up.","- the root of the main window consists out of a configProvider component (from antd) which is used to apply the theme to the antd components: `theme={{algorithm: theme === 'dark' ? darkAlgorithm : defaultAlgorithm}}`","  - the first child of configProvider is a div that makes certain the user can scroll when the content is larger than the visible area.","- handleLogMsg: ","  - check if the root div was scrolled all the way to the end","  - convert the parameter to a json object","  - if the json object contains the field 'response', search the previous log message with the same key in `logMsgs`, add the response field and make certain that the component is refreshed.","  - if the json doesn't contain the field 'response': add the object to the component's state field `logMsgs`","  - if the root div was scolled down to the end, scollIntoView the endRef div so that the root div is scrolled down to the end again. Do this async (with setTimeout so that scrolling is done after rendering)","- the renderer of the log window:","  - first shows an extra div at the top, with classname `os-draggable`, used to drag the window around","  - loops over all the entries in logMsgs and displays the following fields of each object:","    - location (in bold)","    - transformerName (in bold)","    - inputData.model","    - inputData.max_tokens","    - inputData.temperature","    - for every item in inputData.messages:","       - item.role (in bold)","       - item.content","    - if inputData.response exist","      - show this value","      - show a vertical line","- Make certain that:","  - all the text is displayed using the styling `white-space: pre-wrap` so that new lines are rendered correctly",""],"state":"still-valid"},"8308b963-e815-48b2-a8a7-ce85d1353533":{"result":[],"prompt":["","the application uses a toolbar similar to applications like mS Access, excel, word or draw: a single integrated menu and toolbar","","- At the top of the toolbar are a nr of tabs (use the tabs from the antd library)","- all components on the toolbar show a tooltip (from the antd library) containing a short description of the action.","- create a json structure for all the tabs (fields: key, label, children). rebuild the list at every render so that the tabs are recreated, needed to apply the theme when it changes.","- assign the json structure to the items property.","","the following tabs are available:","- home: this is shown as the first tab when the application starts.","- transformers","- format","- preferences",""],"state":"still-valid"},"907586bd-b127-4fc8-925d-7374bc0a39b3":{"result":[],"prompt":["- the home-tab component is a wrapper that displays it's children in a row.","- This component contains the following child components :","  - file section","  - edit section","  - undo section","",""],"state":"still-valid"},"f740a1e5-7a90-47b9-a4b1-654a97531cf1":{"result":[],"prompt":["- the file-section component contains actions related to the project and file management.","- all buttons use an appropriate icon as content, no text.","- it supports the following actions","  - New Project: a button to create a new project","    - if `await trySave() == true` (if the action is canceled, dont create a new project)","      - call `storageService.new()`","    - disabled when `window.electron.isPluginMode == true`","    - icon: FileOutlined","  - open: a button to open an existing project.","    - disabled when `window.electron.isPluginMode == true`","    - if `await trySave() == true` (if the action is canceled, dont create a new project)","      - show a dialog box to select a file `dialogResult = await dialogService.showOpenDialog()`","      - if not dialogResult.canceled and dialogResult.filePaths, ask the storage-service to open the first file in filePaths (can only open 1 file at a time).","    - wrap in an exception handler that shows an error dialog","  - save: a button to save the current project to file.","    - enabled when the project service has a filename for the project (field 'filename' has a value) and projectService.isDirty == true","    - if the project file does not yet have a filename, show a save-as dialog `dialogResult = await dialogService.showSaveDialog()`","    - if the user doesn't provide a valid filename, stop the action `dialogResult.canceled or not dialogResult.filePath`","    - if the user provides a valid filename,","      - call the storage-service 'save' function with filename as param (with await so that the 'new' function can wait until the previous project is loaded).","    - if the project service already has a filename,","      - call storage-service save without param.","    - wrap in an error handler and show the error","  - save as: a button to save the current project to a new location.","    - show a save-as dialog `dialogResult = await dialogService.showSaveDialog()`","    - if not dialogResult.canceled and dialogResult.filePath, ask the storage-service to save the project to the new location.","    - wrap in an exceptions handler and show the error","  - auto-save: a toggle button, when pressed, asks the project service to update the auto-save state (setAutoSaveState).","    - the toggle button's state follows that of the project service's auto-save state (getAutoSaveState).","- The project-service needs to be monitored for changes so that the state of the buttons can be updated (field: eventTarget, event: 'is-dirty-changed').","- When the component is mounted, call `window.electron.onCanClose(this.tryCanClose)` so we can save the project if need be and also cancel the action. Call `window.electron.removeOnCanClose(this.tryCanClose)` when unmounting to remove the event handler","- functions:","  - trySave():","    ```python","      if this.state.isDirty:","        confirm = await dialogService.confirm('Do you want to save the changes first?')","        if confirm == None:","          return False","        elif confirm:","          await this.saveProject()","      return True","    ```","  - tryCanClose():","    ```python","      res = await this.trySave()","      window.electron.canCloseProcessed(res)","    ```",""],"state":"still-valid"},"41dc0b70-7750-46ef-a8ea-fd48d5c99b94":{"result":[],"prompt":["- the edit-section component contains actions related to the clipboard and the currently selected data.","- all buttons use an appropriate icon from the '@ant-design/icons' library as content, no text.","- it supports the following actions","  - cut: a button to initiate the cut command of the selection service","    - enabled when the selection service has any data marked as selected.","  - copy: a button to initiate the copy command of the selection service","    - enabled when the selection service has any data marked as selected.","  - paste: a button to initiate the paste command of the selection service","    - enabled when the clipboard contains text data && SelectionService.getEditor().","    - use the BiPaste icon from react-icons","    - call `clipboard.readText()` to get the data that needs to be pasted.","  - delete: a button to initiate the delete command of the selection service","    - enabled when the selection service has any data marked as selected.","  - select all: a button to select all the text in the currently active window.","    - use the icon MdSelectAll  from react-icons","  - clear selection: a button to clear the current selection buffer.","    - enabled when the selection service has any data marked as selected.","    - use the icon MdOutlineDeselect from react-icons","- to check if the clipboard contains text data:","  - use the clipboard imported from electron","  - when the component is loaded and when the ipcRenderer emits the 'focused' event, call `available = clipboard.availableFormats(); available.includes('text/plain')` to see if there is supported data in the clipboard.","- when loaded, subscribe the callback `handleSelectionChanged` to the selection service. Unsubscribe when unloading.","- `handleSelectionChanged`: update the state of the buttons.",""],"state":"still-valid"},"a544fcfc-0cbb-4b88-b2c1-5dcd7db0816b":{"result":[],"prompt":["- the undo-section component contains actions that the undo / redo service can perform.","- all buttons use an appropriate icon as content, no text.","- the service supports the following actions","  - undo: a button to undo the last action","    - enabled when the undo-service has undo actions. ","    - calls the undo-service's undo function","  - redo: a button to redo the last action, preformed by the project's undo service.","    - enabled when the undo-service has redo actions","    - calls the undo-service's redo function.","- The undo service needs to be monitored for changes so that the state of the buttons can be updated.","",""],"state":"still-valid"},"5f312819-504f-4fae-ab3d-c823668d659b":{"result":[],"prompt":["- the transformers-tab component is a wrapper that displays it's children in a row.","- This component contains the following child components :","  - configuration section","  - build section","",""],"state":"still-valid"},"6a3b7dc2-86c4-41e9-b132-9ed0a00a8dde":{"result":[],"prompt":["- The transformers-configuration section contains actions that are related to the transformers that are available in the application.","- all buttons are wrapped in a tooltip (from the antd library) containing a description of the action.","- it contains the following actions:","  - edit transformers: a button that which will open a new window of the Mark editor in plugin-mode, using the project at the specified path.","    - disabled when `window.electron.isPluginMode == true`","    - icon: MdRebaseEdit","    - do:","      ```python","        result = await window.electron.openPluginEditor(folderService.plugins)","        if result:","          await AllSparkService.refreshPlugins()","      ```","    - wrap round try-catch and show error.","  - active entry point: a drop down list, populated with the names of the transformers (entryPoint.name) found in `cybertronService.entryPoints`. The selected item in the dropdownlist comes from `cyberTronService.activeEntryPoint`. Whenever the selection changes in the drop down list, this field is updated.","  - Monitors for events dispatched from the all-spark service (field: eventTarget, event: transformers-loaded): whenever this event comes in, rebuild the list of entry points.",""],"state":"still-valid"},"d1d83d0c-fde7-47a6-af75-696b0181f037":{"result":[],"prompt":["- the build-section component contains actions that the build-service can perform.","- all buttons use an appropriate icon as content, no text.","- all buttons are wrapped in a tooltip (from the antd library) containing an extensive description of the action.","- it contains the following actions:","  - all: a button to start rendering the currently active transformer for the entire project.","    - disabled when project-service.isAnyFragmentOutOfDate() == false or when buildService.isBuilding or !positionTrackingService.activeTransformer","    - calls `build-service.buildAll()`","  - active fragment with active transformer: a button to start rendering the result for the currently active fragment and transformer.","    - disabled when `!positionTrackingService.activeFragment || !positionTrackingService.activeTransformer || positionTrackingService.activeTransformer.isFullRender || buildService.isBuilding`","    - calls `build-service.runTransformer(positionTrackingService.activeFragment, positionTrackingService.activeTransformer)`","  - separator (type='vertical', height='24px')","  - show log: a toggle button, when pressed, asks the log-service to update the showLogWindow state.","    - the toggle button's state follows that of the log-service's showLogWindow state. ","  - show debugger: a toggle button, when pressed, asks the build-service to update the showDebugger state.","    - the toggle button's state follows that of the build-service's showDebugger state. ","  - separator (type='vertical', height='24px')","  - debug: a toggle button, when pressed, asks the build-service to update the debug state.","    - the toggle button's state follows that of the build-service's debug state. ","  - run next: a button that will continue rendering to the next transformer","    - disabled when `!debug || !isBuilding || !isPaused`","  - stop run: a button that calls  `buildService.stopRun()`","    - use the icon TbPlayerStop (from react-icons/tb)","    - disabled when `!debug || !isBuilding || !isPaused`","  - `isPaused = !!buildService.debugResolver`","- Store the disabled value of all the buttons in the state so that they can be updated from the event handlers.","- initialize the button states when loaded","- register event handlers to monitor for changes with:","  - project-service (field: eventTarget, event: fragment-out-of-date): update disabled state of the buttons","  - position-tracking service (field: eventTarget, event: change): update disabled state of the buttons","  - build-service (field eventTarget, events: is-building, is-pausing, has-resumed, show-debugger): update disabled state of the buttons","  - log-service (field eventTarget, event: log-window-visibility): update the disabled state of show-log.","- unregister the event handlers when unloaded.",""],"state":"still-valid"},"65b637c7-f0ca-4672-aa83-8306b386db2b":{"result":[],"prompt":["- the format-tab component is a wrapper that displays it's children in a row.","- This component contains the following child components :","  - style section","  - paragraph section","  - font section",""],"state":"still-valid"},"489a33cf-f216-48c2-9d18-987c3bc46280":{"result":[],"prompt":["- the style-section component contains actions related to the markup used in the text for applying markdown formatting.","- all buttons use an appropriate icon (from react-icons) as content, no text.","- there is a button for each of the following formatting styles:","  - heading 1 (btn: LuHeading1)","  - heading 2 (btn: LuHeading2)","  - heading 3 (btn: LuHeading3)","  - heading 4 (btn: LuHeading4)","  - heading 5 (btn: LuHeading5)","  - heading 6 (btn: LuHeading6)","  - paragraph (btn: PiParagraph)","  - quote (btn: LuCode2LuQuote)","  - code (btn: LuCode2)","  - bullet list (btn: LuList)","  - numbered list (btn: PiListNumbers)","- when a button is pressed, the formatting style is applied to the currently selected text in the selection-service.","- only 1 button can be selected at the same time, it is not possible to have no selection at all.","- all the buttons are lined up in a single row.    ","- the selection-service (not a component) is monitored for changes in the currently selected text. whenever the text selection is changed, the state of the toggle buttons is updated to reflect the style of the currently selected text. The selection service provides a method for retrieving the style of the currently selected text.","","Remember that each button needs it's own appropriate icon.",""],"state":"still-valid"},"048ce355-2a85-45c2-9d30-70eae30e832b":{"result":[],"prompt":["- the paragraph-section component contains actions related to the markup used in the text for applying markdown formatting.","- all buttons use an appropriate icon as content, no text.","- all buttons are wrapped in a tooltip (from the antd library) containing an extensive description of the action.","- it supports the following actions","  - indent: a button to increase the indent of the current line or selection. The selection-service performs this action on the selected text or current cursor position.","    - use the icon MdFormatIndentDecrease from react-icons","  - unindent: a button to decrease the indent of the current line or selection. The selection-service performs this action on the selected text or current cursor position.","    - icon: MdOutlineFormatIndentDecrease from react-icons",""],"state":"still-valid"},"366c660c-4aa7-4160-9e22-e6ef4469c411":{"result":[],"prompt":["- the font-section component contains actions related to the markup used in the text for applying markdown formatting.","- all buttons use an appropriate icon as content, no text.","- all buttons are wrapped in a tooltip (from the antd library) containing an extensive description of the action.","- whenever the text selection is changed (in the selection-service), the state of the toggle buttons is updated to reflect the state of the selected text.","- whenever the cursor position is changed (in the position-tracking-service, event: pos-changed), update the state of the buttons. ","- it supports the following actions","  - bold: a toggle button to set the bold state on/off on the selected text and to show the state of the current selection. ","  - italic: a toggle button to set the italic state on/off on the selected text and to show the state of the current selection. ","  - underline: a toggle button to set the underline state on/off on the selected text and to show the state of the current selection. ","  - strike-though: a toggle button to set the strike-through state on/off on the selected text and to show the state of the current selection. ","- all actions call the `selectionService.setBlockStyle` function to apply the selection and `selectionService.getBlockStyles` to set the state of te buttons.",""],"state":"still-valid"},"982c423f-5854-4c77-af54-9ae223a79db9":{"result":[],"prompt":["- the preferences-tab component is a wrapper that displays it's children in a row.","- This component contains the following child components :","  - GPT","  - View",""],"state":"still-valid"},"c25f5105-2ce2-4322-9637-09c2d74ac80a":{"result":[],"prompt":["- the GPT-section component contains actions related to the configuration of the GPT service.","- all buttons use an appropriate icon as content, no text.","- The GPT-section component keeps track of the open state of the 'open-ai configuration dialog'","- it supports the following actions","  - key: this button opens the 'open-ai configuration dialog'.","    - use a key for the icon.","  - model: the ModelComboBox component (Select in antd) where the user can select the default model for requests sent to open-ai.","    - the list of available models used to populate the combobox, comes from the gpt-service.","    - get the initial value for the combobox from the gpt-service (getDefaultModel function).","    - when the value is changed, save to the gpt-service (setDefaultModel function).","    - Whenever the prop openApiKey is updated, refresh the list of available models",""],"state":"still-valid"},"f7a265c4-53b4-4c62-af43-adf2695e4272":{"result":[],"prompt":["- The open-ai configuration dialog is a modal dialog (from the antd library) implementation that is used to edit the open-ai configuration settings.","- the top of the dialog contains a title with short description.","- the dialog contains an input box where the user can enter his api-key that will be used for api-calls with the open-ai platform.","  - When the dialog box opens, the current value of the api-key is retrieved from the gpt-service and shown in the input box.","- At the bottom of the dialog box are 2 buttons:","  - cancel: close the modal dialog without saving the value.","  - ok: close the modal dialog after saving the new api-key value to the gpt-service. ",""],"state":"out-of-date"},"b49f427c-4dfe-4510-8e8b-ba3befef77e0":{"result":[],"prompt":["- the view-section component contains actions related to the configuration of the appearance of the application","- all buttons use an appropriate icon as content, no text.","- it supports the following actions","  - theme: this is a combobox where the user can select the preferred color mode: light or dark mode. This value is linked to the value of the theme-service that manages the currently selected theme (get & set current theme).","  - font: this is a combobox that the user can use to select the font for the markdown text. This value is linked to the value of the theme-service (get & set current font). Supported fonts: Consolas (monospace) Helvetica (sans-serif), Arial (sans-serif), Arial Black (sans-serif), Verdana (sans-serif), Tahoma (sans-serif), Trebuchet MS (sans-serif), Impact (sans-serif), Gill Sans (sans-serif), Times New Roman (serif), Georgia (serif), Palatino (serif), Baskerville (serif), Andalé Mono (monospace), Courier (monospace), Lucida (monospace), Monaco (monospace), Bradley Hand (cursive), Brush Script MT (cursive), Luminari (fantasy), Comic Sans MS (cursive)","  - font-size: this is a combobox that the user can use to select the size of the font for the markdown text. This value is linked to the value of the theme-service (get & set current font-size). It supports values ranging from 6px up to 50px.",""],"state":"still-valid"},"60d16ad6-73cf-4bde-845c-000dff979205":{"result":[],"prompt":["- the body component represents the main body of the application.","- it's entire area is filled with a Split component of the  @geoffcox/react-splitter library ","  - initialPrimarySize = this.state.verticalSplitSize","  - minPrimarySize='50px'","  - minSecondarySize='15%'","  - defaultSplitterColors = colors, note:","    ``` javascript","      if (theme === 'light') {","        colors = {","          color: '#e8e8e8',","          hover: 'gray',","          drag: '#f5f5f5',","        };","      } else {","        colors = {","          color: '#323233',","          hover: 'gray',","          drag: '#979797',","        };","      }","    ```","  - children:","    - outline component","    - Split component:","      - initialPrimarySize = this.state.horizontalSplitSize","      - minPrimarySize='50px'","      - minSecondarySize='15%'","      - horizontal","      - children:","        - editor component","        - results view component","- The body component has an event handler for the 'onSplitChanged' callback of both the horizontal and vertical split that will store the new value for it's position (% value) (verticalSplitSize / horizontalSplitSize).","- When the body component is unloaded, the last position of the horizontal and vertical splitters are stored in the local storage.","- When the body component is loaded:","  - the last position of the horizontal and vertical splitters are restored from the local storage, if no value is found, the default '30%' is used.","",""],"state":"still-valid"},"c9ce52a1-c141-47ec-a32c-f087b6174c3e":{"result":[],"prompt":["- The editor component displays markdown text. ","- to display the markdown text, the monaco editor npm package is used.","- When the editor is loaded:","  - the text for the monaco editor is retrieved from the project service (`projectService.content`).","  - theme (convert light to vs-light or dark to vs-dark), font & font-size are retrieved from the theme-service and applied to the monaco editor.","- Whenever the project service triggers the 'content-changed' event, the editor will reload the text. Before reloading the text in the editor, set the flag `settingValue` to true. This is used to prevent parsing the text after loading the project (the editor triggers handleDidChangeModelContent when loading)","  - note: register using `projectService.eventTarget.addEventListener('content-changed', handleContentChanged)`, unregister when component unloads ","- Whenever the position-tracking service raises the event 'moveTo', do: `if (this.editorRef.current) this.editorRef.current.revealLineNearTop(e.detail)`, unregister when component unloads","- subscribe to the theme-service for changes `themeService.subscribe(this.handleThemeChanged)` when the component is loaded and unsubscribe upon unloading `themeService.unsubscribe(this.handleThemeChanged)`","  - return if no this.editorRef.current","  - update the options of the editor, call `this.editorRef.current.updateOptions(newOptions)`","- monitor the following events on the monaco editor:","  - editorDidMount: store a reference to the editor for further use, set `this.settingValue = true` so that during loading no content changes are processed and register the other event handlers (bound) with the mounted editor:","    - onDidChangeModelContent: ask the change-processor-service to process the changes. in pseudo:","    ```python (pseudo)","    def handleDidChangeModelContent(ev):","        try:","          if not editor: # ref to the editor needs to be loaded, should be the case cause event is triggered","            return","          if this.settingValue:","            this.settingValue = False","            return","          changeProcessorService.process(ev.changes, editor)","        catch (e):","          dialogService.showErrorDialog(e)","    ```","    - onDidFocusEditorWidget: store a reference to the monaco editor in the selection service to indicate so that it can work with the correct editor (setEditor).","    - onDidChangeCursorPosition: if the selection service currently references this monaco editor, ask the position-tracking service to update the current line with the new cursor position `setCurrentPos(e.position)`","    - onDidChangeCursorSelection: if the selection service currently references this monaco editor, inform the subscribers of the selection-service that the selection has changed `selectionService.notifySubscribers()`","- the monaco editor always occupies all the space that is available.","- always include these options for the monaco editor:","  - automaticLayout: true","  - selectOnLineNumbers: true","  - roundedSelection: false","  - readOnly: false,",""],"state":"still-valid"},"dba35a53-38b0-41e8-b276-d62e24872944":{"result":[],"prompt":["- the outline component is positioned to the left of the editor","- it contains a tree representing the outline of the currently active project: all markdown headings in the document are present in the outline","- When the component is loaded and whenever the project-service raises the 'content-changed' event to indicate that a new project was loaded, the project data (field: textFragments) is retrieved from the project-service and converted into a tree structure using the function 'convertToTreeData'.","  - note: register using `projectService.eventTarget.addEventListener('content-changed', handleContentChanged)`","- Whenever the project service raises an event that a data item was removed (event: fragment-deleted), call the 'handleContentChanged' function","- Whenever the project service raises an event that a data item was added (fragment-inserted) or (multiple) item(s) were changed (the event 'title-changed'), rebuild the tree structure.","- whenever the user expands a tree item (callback: onExpand), the key of the expanded item is added to the list of expanded items, when the user collapses an item, the key is removed from the list of expanded items.","- this component monitors the position-tracking service for changes to the currently selected text-fragment.","  - use `positionTrackingService.eventTarget.addEventListener('change', eventHandler)` to attach the event handler","  - when the position changes and `this.isMoving == false`, set the tree's selectedKeys and defaultExpandedKeys properties to the key (if any) of the text-fragment so that the corresponding tree node becomes selected. `key = e.detail?.key`","- show the tree with lines","- when the user clicks on a tree-item (onSelect):","  ```python","    if len(selectedKeys) > 0:","      if selectedKeys.length == 0:","        return","      fragment = projectService.getFragment(selectedKeys[0])","      if fragment:","        try:","          this.isMoving = True","          positionTrackingService.setActiveFragment(fragment)","          if this.state.expandedKeys.indexOf(selectedKeys[0]) == -1:","            this.setState({ expandedKeys: [...this.state.expandedKeys, selectedKeys[0]] })","          this.setState({ selectedKeys })","        finally:","          this.isMoving = False","  ```","- when the user expands a tree-item (onExpand):","  ```python","  ```","- the function 'convertToTreeData' is described as:","  set parent to null","  for every data item:","    Create a new node for the data item. ","      Set the title & key of the node to the title & key of the data item.","      Use the fragment-status-icon component as the icon for the node. Assign the data item as the value for the property 'fragment' .","      Also keep a reference to the data item itself in the node.","    If the item's field depth = 1, add the new node to the root node and make that node the parent ","    Else if there is no parent yet, skip the item","    If the item's depth is higher then parent.data.depth: add the new node to the parent's children. assign node.parent = parent. make the new node parent ","    If the item's depth equals parent.data.depth or is lower:","      get the parent of the current parent until the depth of this new parent is 1 higher then the depth of the item and add the item as a child of this new parent. assign node.parent = parent. Make the item the new parent.","","",""],"state":"still-valid"},"c25bd76e-af9b-4020-abe0-1ba023c9df76":{"result":[],"prompt":["- The fragment-status icon component is used to indicate the current status of a text-fragment object.","- the component has the following properties that need to be supplied by consumers of the component:","  - fragment: a reference to the text-fragment object for which the status needs to be shown","- based on `fragment?.depth` value, the following icon should be shown:","  - 1: LuHeading1","  - 2: LuHeading2","  - ...","  - 6 or more: LuHeading6","- selecting the icon needs to happen in the render function so that no object or function needs to be kept in the state","- if `fragment?.isBuilding && buildService.isBuilding` show a spin component (from the antd lib) instead of an icon. ","- the LuHeading1, LuHeading2, LuHeading3, LuHeading4, LuHeading5, LuHeading6 icons are imported from the 'react-icons/lu' library.","- select which icon to use in the render function. Use the state 'depth' to select which icon to use.","- the component shows a tooltip (from the antd library) which shows the status of the component. ","- for the color of the icon, use:","  - green if `!fragment?.isOutOfDate`","    - this status indicates that the fragment is fully up to date","  - orange if `fragment?.isOutOfDate && fragment?.outOfDateTransformers?.length > 0`","    - this indicates that the fragment is no longer up to date for a sub-set of the transformers. This list contains the transformer objects. Display the `name` of each transformer in the tooltip. ","  - red if `fragment?.isOutOfDate && !(fragment?.outOfDateTransformers?.length > 0)`","    - this indicates that the fragment is no longer up to date for all of the transformers. ","- upon construction register an event handler with the project-service (prop: eventTarget) to handle the following events (Unregister when unloading):","  - `fragment-out-of-date`: ","    - if `e.detail === fragment?.key` then refresh the color of the icon and content of the tooltip when the event is triggered.","  - `title-changed`:","    - if `e.detail?.key === fragment?.key` then refresh the icon that is used, based on the new value for `fragment?.depth`","  - `fragment-building`:","    - if `e.detail?.fragment?.key === fragment?.key` then set the icon to null, so that the spinner is shown instead","  - `fragment-up-to-date`:","    - if `e.detail === fragment?.key` then refresh the icon, tooltip and the color. Do the full recalculation cause this event indicates that the fragment is only up to date for a single transformer, it could still be out-of-date for other transformers.","- upon construction register an event handler with the build-service (prop: eventTarget) to handle the following events (Unregister when unloading):","  - `is-building`: if `!e.detail.isBuilding` then hide the spinner and show the icon again.","- load tooltip, depth & color from prop.fragment when component is loaded",""],"state":"still-valid"},"912f3e5b-8b82-47e9-af50-50e97a5e03b1":{"result":[],"prompt":["- the results-view component is positioned at the bottom of the main body","- the user can view the results that were generated by the transformers that were registered with the cybertron-service, for the currently selected text block.","- tabs are placed at the bottom of the results view, size = small, tabBarStyle={{marginTop: 0}}","- For each transformer in the transformers list provided by the cybertron-service (field: transformers), this view creates a tab.","  - the transformer name is used as the title and key of the tab.","  - Put a transformer-status-icon component in front of the transformer name, set property 'transformer'","  - the tab content shows a results-view-tab component","  - when a tab gets selected, do: `positionTrackingService.setActiveTransformer(transformer)`","- when first initialized and the list is not empty, set the selected tab to the first item in the list and make certain that `positionTrackingService.setActiveTransformer(transformer)` is called for the correct transformer (first in the list)","- create a json structure for all the tabs (fields: key, label, children).","- assign the json structure to the items property.","- Monitors for events dispatched from the all-spark service (field: eventTarget, event: transformers-loaded): whenever this event comes in, rebuild the list of entry points.","",""],"state":"still-valid"},"d809ef28-5a75-4f2a-8e28-9f895aa87bae":{"result":[],"prompt":["- The transformer-status icon component is used to indicate the status of the currently selected text-fragment object in relationship to the transformer that is assigned to the component.","- the component has the following properties that need to be supplied by consumers of the component:","  - transformer: a reference to the transformer object for which status info is shown","- upon construction register an event handler with the position-tracking-service (field: eventTarget) to handle the following events (Unregister when unloading):","  - `change`: handles changes to the currently selected text-fragment:","    - refresh the status","- upon construction register an event handler with the project-service (field: eventTarget) to handle the following events (Unregister when unloading):","  - `fragment-out-of-date`:  refresh the status","  - `fragment-building`: refresh the status","  - `fragment-up-to-date`: refresh the status","- upon construction register an event handler with the build-service (field: eventTarget) to handle the following events (Unregister when unloading):","  - `is-pausing`: refresh the status","  - `has-resumed`: refresh the status","- The different states to show:","  - building: ","    - shows a spin component (from the antd lib)","    - when `positionTrackingService.activeFragment && buildStackService.isRunning(this.props.transformer, positionTrackingService.activeFragment) && !buildService.isPaused`","  - paused:","    - shows a pause icon","    - when `positionTrackingService.activeFragment && buildStackService.isRunning(this.props.transformer, positionTrackingService.activeFragment) && buildService.isPaused`","  - overwritten:","    - use the LuType icon (from react-icons)","    - when `transformer.cache.isOverwritten(positionTrackingService.activeFragment?.key)`","    - when `transformer.cache.isOutOfDate(positionTrackingService.activeFragment?.key)`: show the icon in red","  - rendered:","    - use the MdAutoFixNormal icon (from react-icons)","    - when not building and not overwritten","    - when `transformer.cache.isOutOfDate(positionTrackingService.activeFragment?.key)`: show the icon in red","  - not yet rendered:","    - use the LuArrowDownToDot icon","    - when `!transformer.cache.getResult(positionTrackingService.activeFragment?.key)`","    - show in orange","- the component shows a tooltip (from the antd library) which shows the status of the component. If the fragment is out-of-date, include this in the tooltip ","",""],"state":"still-valid"},"581dcdbb-6401-4025-b898-606326a92aae":{"result":[],"prompt":["- the results-view-tab component displays the results of a transformer for a particular text-fragment, identified by it's key.","- to display the results as markdown, json data, javascript, html or css, the monaco editor npm package is used.","- The monaco editor fills the full width and height that are available to the component.","- When the results-view-tab is loaded:","  - the text for the monaco editor is retrieved from the result-cache of the transformer that is assigned to this component using the currently assigned key, if available (could be that it's null): ","  ```python","  editorKey = positionTrackingService.activeFragment?.key","  if editorKey:","    toDisplay = this.props.transformer.cache.getFragmentResults(editorKey)","    if this.props.transformer.isJson:","      toDisplay = JSON.stringify(toDisplay, 0, 2) # do a pretty format with 2 tabs spacing","  ```","  - theme (convert light to vs-light or dark to vs-dark), font & font-size are retrieved from the theme-service and applied to the monaco editor.","- the results-cache of the transformer is monitored for changes in the result (only for changes in the result with the current key).","  - if the result is marked as 'out-of-date' or 'deleted', show the text as grayed-out.","  - if the result is marked as 'overwritten', show the text in red ","- when the user changes the text in the monaco editor, the new text is saved to the result-cache of the transformer, marked as overwritten. In pseudo: ","  ```python","  if this.props.transformer.isJson:","    try:","      newValue = JSON.parse(newValue)","    except:","      continue # if we cant parse to json, save as text so we still have the value.  ","  transformer.cache.overwriteResult(editorKey, newValue)","  ```","- subscribe to the theme-service for changes `themeService.subscribe(this.handleThemeChanged)` when the component is loaded and unsubscribe upon unloading `themeService.unsubscribe(this.handleThemeChanged)`","  - return if no this.editorRef.current","  - update the options of the editor, call `this.editorRef.current.updateOptions(newOptions)`  ","- monitor the following events on the monaco editor:","  - editorDidMount: store a reference to the editor for further use and register the other event handlers (bound) with the mounted editor:","    - onDidFocusEditorWidget: ","      - store a reference to the monaco editor in the selection service to indicate so that it can work with the correct editor.","      - set `position-tracking-service.activeTransformer = transformer`","    - onDidChangeCursorSelection: if the selection service currently references this monaco editor, inform the subscribers of the selection-service that the selection has changed","- put a results-view-context-menu component below the monaco editor (so it's rendered after the editor)","- the component monitors events triggered by the position-tracking service (field: eventTarget, event: change) and the project-service (field: eventTarget, event: content-changed) for changes to the currently selected text-fragment and when the project changes. ","  - For both events, update the key value and retrieve the data from the result-cache, if the data is not a string, but a json object, convert to a string and show in the monaco-editor. If there is no key, show an empty string.","- When the component is loaded and whenever the `transformer` property changes, register an event handler on the transformer's cache, if there is a valid transformer assigned (transformer.cache.eventTarget, event: result-changed).","  - If there was a previous transformer, unregister the event handler first.","  - Also unregister the event handler when the component unloads and props.transformer != null","  - when the event triggers retrieve the data again from the result-cache of the transformer (if the data is not a string, but a json object, convert to a string and show in the monaco editor)","- always include these options for the monaco editor:","  - automaticLayout: true","  - selectOnLineNumbers: true","  - roundedSelection: false","  - readOnly: false","",""],"state":"still-valid"},"5a4c3d1a-0e09-424b-8fd0-6de342e56291":{"result":[],"prompt":["- the results-view-context-menu is a component that is a wrapper for the Dropdown antd component.","- it has the properties 'transformer' and 'key' that needs to be supplied ","- The dropdown's content is a 'more' button icon and the trigger for the dropdown is 'click'.","- the 'more' button is positioned in the top-right corner of the parent as a floating button (position: 'absolute', top: 0, right: 16).","- it contains the following menu items:","  - model for all: select the gpt model to be used by the transformer.","    - the sub menu items are provided by the gpt-service's list of available models. `await gptService.getModels()`","    - the menu item that contains the name of the currently selected model, is shown as selected.","      - Get the value for the current model, registered for the current transformer, from the gpt-service. `gptService.getModelForTransformer(transformer)`","    - when an other model is selected, ask the gpt-service to update the model-name used for the transformer. `gptService.setModelForTransformer(model, transformer)`","  - model for fragment: select the gpt model to be used by the transformer, for the current key.","    - the sub menu items are provided by the gpt-service's list of available models.","    - the menu item that contains the name of the currently selected model, is shown as selected.","      - Get the value for the current model, registered under the name of the current transformer and current key, from the gpt-service `gptService.getModelForFragment(transformer, key)`","    - when an other model is selected, ask the gpt-service to update the model-name of the transformer and the current title. `gptService.setModelForFragment(model, transformer, key)`","  - a splitter (Menu.Divider)","  - refresh: when pressed, the transformer associated with the current tab recalculates the result","  - upon construction register an event handler with the project-service (field: eventTarget) to handle the event 'content-changed' (Unregister when unloading). Refresh the current model for all and the current model for the fragment.",""],"state":"still-valid"},"866c4850-179f-4ba5-9e56-ec37fdd1fe97":{"result":[],"prompt":[""],"state":"still-valid"},"9c672829-a31d-47cb-9d66-e676423a06da":{"result":[],"prompt":["- the dialog service is a global singleton that provides a common interface for other components and services to show dialog boxes.","- the service can show a dialog box for errors, warnings and info.","- all actions or functions that the user can trigger from a component, should be wrapped in a proper error handler so that when an error occurs, an electron dialog box is shown to the user with details on the error. ","- electron.openDialog is globally available through the contextBridge loade by the preloader script. Dont import the dialog module from electron. ","- functions:","  - showErrorDialog(param1, param2): ","    ```python (pseudo) ","      config = { title: (param2 ? param1 : 'Error'), content: param2 or param1 }","      electron.openDialog('showErrorBox', config)","    ```","  - showSaveDialog():","    ```python (pseudo)","      config = { filters: [{ name: 'markdown', extensions: ['md']}, { name: 'any', extensions: ['*']}] }","      return electron.openDialog('showSaveDialog', config)","    ```","  - showOpenDialog():","    ```python (pseudo)","      config = { filters: [{ name: 'markdown', extensions: ['md']}, { name: 'any', extensions: ['*']}] }","      return electron.openDialog('showOpenDialog', config)","    ```","  - confirm(message):","    ```python","      config = { type: 'question', buttons: ['Yes', 'No', 'Cancel'], message }","      res = await window.electron.openDialog('showMessageBox', config)","      if (res.response === 2) return null","      return res.response === 0","    ```",""],"state":"still-valid"},"fc366a69-db91-4f35-b538-182295436d18":{"result":[],"prompt":["- The theme service is a global singleton, responsible for managing the currently selected theme font & font-size: when the selected theme, font or font-size is changed, the new value is saved to the local storage (the global `localStorage`) and subscribers are notified. When the service is created, the values previously stored in local storage, are retrieved.","- The service allows for a selection between a light or dark theme.","- Every component uses this service to retrieve the currently selected theme (not the font or font-size)  so it can apply this. Components don't need to subscribe for changes to the selected theme value, they only need to retrieve this value from the theme service and use the styling names, based on the selected. theme.","- The main window refreshes it's entire content when the selected theme is updated.",""],"state":"still-valid"},"6e52cca8-7baf-4c4f-97c5-effbf603eb14":{"result":[],"prompt":["- the project service is a global singleton that:","  - manages a data-list of the currently loaded text-fragments (field: text-fragments). This stores the parsed text.","  - stores the raw data content (field: content): this is the text displayed to the user.","  - keep track of the filename of the currently loaded project (field: filename)","  - isDirty: a property, when set and the value changes, raises the 'is-dirty-changed' event.","  - provide the following functions to work with the text-fragments:","    - deleteTextFragment(fragment): remove the object from the text-fragments list & raise the fragment-deleted event, parameter = fragment.key","    - addTextFragment(fragment, index): if index is at end of the text-fragments list, add to list, otherwise insert the fragment at the specified position in the text-fragments list. raise the fragment-inserted event.","    - markOutOfDate(fragment): fragment.isOutOfDate = true, raise the event fragment-out-of-date, param = fragment.key","    - markUpToDate(fragment, transformer): called when a transformer has updated the result for the fragment. do:","      - decrement fragment.buildCount","      - fragment.isBuilding = fragment.buildcount > 0,","      - if not fragment.outOfDateTransformers?.length > 0: [...CybertronService.transformers]","      - fragment.outOfDateTransformers.remove(transformer)","      - if fragment.outOfDateTransformers.length = 0:","        - fragment.isOutOfDate = false","        - raise the event fragment-up-to-date, param = fragment.key","      - otherwise, raise the event 'fragment-building', params: fragment & transformer cause the state has changed for transformers, let them update","    - markIsBuilding(fragment, transformer): called to indicate that a fragment is being built. do: ","      - fragment.isBuilding = true","      - fragment.buildCount = (fragment.buildCount || 0) + 1","      - raise the event 'fragment-building, param {fragment: fragment, transformer: transformer}","    - getFragment(key): search for the text-fragment with the specified key and return it: `return this.textFragments.find(t => t.key == key)`","    - tryAddToOutOfDate(key, transformer):","      ```python","      fragment = this.getFragment(key)","      if not fragment:","        dialogService.showError('Unknown key: ' + key)","        return","      if not fragment.isOutOfDate: # first tranformer out of date","        fragment.outOfDateTransformers = [transformer]","        this.markOutOfDate(fragment)","      elif len(fragment.outOfDateTransformers) > 0: # only part is dirty, not yet full fragment","        fragment.outOfDateTransformers.push(transformer)","        if len(fragment.outOfDateTransformers) == len(CybertronService.transformers): # fragment just became full dirty","          fragment.outOfDateTransformers = []","        this.dispatchEvent('fragment-out-of-date', key) # raise again so ui can adjust","# fragment is already marked as fully out-of-date (no specific fragment.outOfDateTransformers)","      ```","    - isAnyFragmentOutOfDate(): returns true if any of the fragments in textFragments array is marked as isOutOfDate.","    - dispatchEvent(event, value): dispatches events","      - creates a custom event object if there is a value, otherwise a regular event object, and ","      - calls eventTarget.dispatch if this.blockEvents == false (initialize blockEvents to false during construction)","    - setIsDirty(value): if this.isDirty !== value: this.isDirty = value; this.dispatchEvent('is-dirty-changed', value)","- the project service also keeps track of some user configs like:","  - wether auto-save is on or not. This value is stored in the local storage.","  - initialize this.autoSave during construction with the value from the local storage. ","- The project service uses an EventTarget field to dispatch events. Other objects can add / remove event listeners to / from the event target to receive events. ","- it raises the following events:","  - content-changed: when the project is loaded or a new project is created.","  - fragment-deleted: when a text fragment is removed from the list","  - fragment-inserted: when a text fragment is added to the list","  - fragment-out-of-date: when a fragment is marked as out of date.","  - fragment-building: when a fragment is being built by a transformer","  - fragment-up-to-date: when a fragment has been built by a transformer and is marked as (partially) up-to-date","  - title-changed: when the key of a fragment was changed (raised externally)","  - is-dirty-changed: when the project was saved or first time it is modified after saving/loading/creating.","",""],"state":"still-valid"},"7946446e-33e7-4bd5-a7b6-3d001271627c":{"result":[],"prompt":["- The project configuration service keeps track of various configurations of the project.","- fields:","  - eventTarget: to register/unregister event handlers that monitor configuration changes","  - config: json object that provides full access to the entire configuration set.","",""],"state":"still-valid"},"fd347c00-e1ea-4961-8544-3048650deb2b":{"result":[],"prompt":["- the storage service is a global singleton that is responsible for reading and writing project data to and from storage.","- at construction:","  - do `gptService.onMarkDirty = this.markDirty` so that the project is marked as dirty when the gpt-service's modelsMap changes.","- functions:","  - clear(): makes certain all references to data that was previously loaded, is cleared","    ```python (pseudo)","    projectService.textFragments = []","    projectService.content = ''","    lineParser.clear()","    positionTrackingService.clear()","    folderService.clear()","    for transformer in cybertronService.transformers:","      transformer.cache.clearCache()","    gptService.modelsMap = {}","    projectConfigurationService.loadConfig({})","    ```","  - new(): set everything up for a new project.","    ```python","      projectService.blockEvents = True","      this.loading = True # to prevent marking it dirty while loading","      try:","        this.clear()","        resourcesPath = window.electron.resourcesPath","        templatePath = path.join(resourcesPath, 'templates', 'default.md')","        if fs.existsSync(templatePath):","          content = fs.readFileSync(templatePath, 'utf8')","          projectService.content = content","          content.split('\\n').forEach((line, index) => lineParser.parse(line, index));","      finally:","        projectService.blockEvents = False","        projectService.dispatchEvent('content-changed')","        this.loading = False","        projectService.setIsDirty(False)","      ```","","  - open(filePath): load all the data from disk ","    ```python (pseudo)","      projectService.blockEvents = True","      this.loading = True # to prevent marking it dirty while loading","      try:","        this.clear()","        folderService.setLocation(filePath)","        content = fs.readFileSync(filePath, 'utf8')","        projectService.content = content","        projectService.filename = filePath","        this.loadKeys(filePath) # must be done before parsing so the parser can find the related keys","        content.split('\\n').forEach((line, index) => lineParser.parse(line, index))","        for transformer in cybertronService.transformers:","          transformer.cache.loadCache()","        this.loadModelsMap(filePath)","        this.loadProjectConfig(filePath)","        this.updateOutOfDate() # do before lifting the block on events otherwise the resultcaches keep resetting","      finally:","        keyService.loadUuidFromLocs = null # so the keyService knows loading the project is done.","        projectService.blockEvents = False","        projectService.dispatchEvent('content-changed')","        this.loading = False","        projectService.setIsDirty(False)","    ```","  - loadModelsMap(filePath): loads the json file that defines the models to be used with the project","    - build the json file name by replacing '.md' with '_models.json' at the end of the field 'file'","    - if the json file exists, load it and assign the parsed json to `gptService.modelsMap`","  - loadKeys(filePath): loads the json file that stores the mappings between the fragment keys and the location of the fragments in the text.","    - build the json file name by replacing '.md' with '_keys.json' at the end of the field 'file'","    - if the json file exists, load it and assign the parsed json to `keyService.loadUuidFromLocs`","  - loadProjectConfig(filePath): loads the json file that contains the configuration settings for the project","    - json file name = folderService.projectConfig","    - if the json file exists, load it and store the parsed json with `projectConfigurationService.loadConfig(configString)`","  - updateOutOfDate(): updates the list of out-of-date transformers for each text-fragment.","    ```python (pseudo)","    def updateOutOfDate():","      for fragment in projectService.textFragments:","        outOfDateTransformers = []","        for transformer in cybertronService.transformers:","          if transformer.cache.isOutOfDate(fragment.key):","            outOfDateTransformers.push(transformer)","        if len(outOfDateTransformers) == len(cybertronService.transformers): #all, so fragment is fully out-of-date","          projectService.markOutOfDate(fragment)","        elif len(outOfDateTransformers) > 0:","          fragment.outOfDateTransformers = outOfDateTransformers","          projectService.markOutOfDate(fragment)","        else:","          fragment.isOutOfDate = False","    ```","  - markDirty():","    ```python","    def markDirty():","      if this.loading: return # need this to prevent the project from being saved again after opening","      projectService.setIsDirty(True)","      if projectService.autoSave and projectService.filename and not this.saveTimer:","        this.saveTimer = setTimeout(() => {","          this.save(projectService.filename)","        }, 5000)","","    ```","  - save(file): saves the project to disk","    ```python (pseudo)","    async def save(file):","      if not projectService.filename and folderService.folder: # not yet saved, but did some building, so temp files","        folderService.moveTo(file)","      elif projectService.filename and projectService.filename != file:","        folderService.copyTo(file)","      elif not folderService.folder:","        folderService.init()","      await fs.writeFileASync(file, projectService.content, 'utf8')","      for transformer in cybertronService.transformers:","        await transformer.cache.saveCache()","      await this.saveModelsMap(file)","      await this.saveProjectConfig(file)","      projectService.filename = file","      projectService.setIsDirty(False)","      this.saveTimer = None","    ```","  - saveModelsMap(file): ","    - build the json file name by replacing '.md' wit '_models.json' at the end of the field 'file'","    - convert the json object in `gptService.modelsMap` to a string","    - save the stringified json to the json file name","  - saveKeys(file): ","    - build the json file name by replacing '.md' wit '_keys.json' at the end of the field 'file'","    - get the dictionary from `keyService.getLocations()` and convert the json object to a string","    - save the stringified json to the json file name","  - saveProjectConfig(file): ","    - json file name = folderService.projectConfig","    - convert the json object in `projectConfigurationService.config` to a string","    - save the stringified json to the json file name","","",""],"state":"still-valid"},"3cd6abe1-d84e-41c4-a421-07a63d196280":{"result":[],"prompt":["- the change-processor service is responsible for processing changes in the project content so that the project structure remains in sync with the source.","- functions:","  - static process(changes, full): makes certain that the project service remains in sync when the user performs edits. in pseudo:","  ```python (pseudo)","    def process(changes, editor):","      projectService.content = editor.getValue()","      model = editor.getModel()","      for change in changes:","        cleanedText = change.text.replace(/\\r/g, '') # remove carriage returns","        lines = cleanedText.split('\\n')","        curLine = change.range.startLineNumber - 1","        lineEnd = change.range.endLineNumber - 1","        lineIdx = 0","# first replace lines that are overwritten. change can contain only part of line so get full line","        if cleanedText.length > 0 or (change.rangeLength > 0 and curLine === lineEnd):","          while lineIdx < len(lines) and curLine <= lineEnd:","            lineParser.parse(model.getLineContent(curLine + 1), curLine)","            lineIdx += 1","            curLine += 1","# now there are either lines to delete or to insert","        while curLine < lineEnd:","          lineParser.deleteLine(lineEnd) # need to do in reverse otherwise the wrong line is removed","          lineEnd -= 1","        if curLine == 0 and lineEnd === 0:","          LineParser.parse(model.getLineContent(1), 0)","        if cleanedText.length > 0: # only insert if there is text (split of empty string gives array with 1 empty string)","          while lineIdx < len(lines):","            LineParser.insertLine(model.getLineContent(curLine + 1), curLine)","            lineIdx += 1","            curLine += 1","        storageService.markDirty()","  ``` ",""],"state":"still-valid"},"8c9e5644-55a8-44c2-ac7b-6fdea2680697":{"result":[],"prompt":["- the folder service is a global singleton, responsible for managing the location of the currently active project.","- it has:","  - folder: the current root folder of the project (this folder contains the project file)","  - project-name: the name of the currently active project. if no name has been provided, use 'new project'","  - project-file: folder + project name + '.json'","  - cache: sub-folder of the root folder = folder + '\\cache'","  - project-config: configuration file that accompanies the project = folder + project name + '_config.json'","  - plugins: sub-folder of the root folder = folder + '\\plugins'. This folder does not have to exist","  - pluginsOutput: sub-folder of the plugins folder = plugins + '\\output'. This is a prop that dynamically builds the result","  - output: sub-folder of the root folder = folder + '\\output'. This folder does not have to exist","- it can:","  - clear: called when a new project is created and the location & name is not yet known.","    - reset folder to null","    - create a temp name, set as project name","  - init: called when the project folders need to be initialized.","    - if this.folder is null: create a temp folder and assign to this.folder","    - create the cache folder if  it doesn't exist yet","    - create the output folder if  it doesn't exist yet","    - calculate the value for 'plugins', but don't try to create the folder","  - move to (new project file): moves the current project and related files to the new location","    - split 'new project file' into new-folder and new-project name (remove extension .md)","    - move the file project-file (if it exists) to the 'new project file'","    - build the new project config : new-folder + new-project-file + '_config.json'","    - move the configuration file (if it exists) to the new project config location.","    - create a new cache folder at new-folder + '\\cache', if this folder doesn't already exist","    - move all files from the cache (if it exists) to the new-cache-folder location","    - if the plugins folder exists in the current project:","      - create a new plugins folder at new-folder + '\\plugins', if this folder doesn't already exist","      - move all the files and sub-folders (recursively) to the new-plugins-folder location","    - if the output folder exists in the current project:","      - create a new output folder at new-folder + '\\output', if this folder doesn't already exist","      - move all the files and sub-folders (recursively) to the new-output-folder location","    - store the new folder and project name","  - copy (new project file): saves the current project to a new location.","    - split 'new project file' into new-folder and new-project name (remove extension .md)","    - copy the file project-file (if it exists) to the 'new project file'","    - build the new project config : new-folder + new-project-file + '_config.json'","    - copy the configuration file (if it exists) to the new project config location.","    - create a new cache folder at new-folder + '\\cache', if this folder doesn't already exist","    - copy all files from the cache (if it exists) to the new-cache-folder location","    - if the plugins folder exists in the current project:","      - create a new plugins folder at new-folder + '\\plugins', if this folder doesn't already exist","      - copy all the files and sub-folders (recursively, use fs.cpSync) to the new-plugins-folder location","    - if the output folder exists in the current project:","      - create a new plugins folder at new-folder + '\\output', if this folder doesn't already exist","      - copy all the files and sub-folders (recursively, use fs.cpSync) to the new-output-folder location","    - store the new folder and project name","  - set location (location)","    - store the new folder and project name","      - this.folder = path.dirname(location)","      - this.projectName = path.basename(location)","      - this.init()",""],"state":"still-valid"},"7ed49936-ac3f-4a7c-a70d-8ccd51b1c327":{"result":[],"prompt":["- The selection service is a global singleton object that keeps track of the currently selected text.","- the selection service keeps track of the currently active editor (an object from the monaco editor npm package)","- the service can be monitored for changes in the selection.","- supports the following actions / functions:","  - cut: if there is a reference to an editor, focus it and ask the monaco editor to cut the selected text to the clipboard.","  - copy: if there is a reference to an editor, focus it and ask the monaco editor to copy the selected text to the clipboard.","  - paste: if there is a reference to an editor, focus it and ask the monaco editor to paste the clipboard content at the current cursor position.","  - delete: if there is a reference to an editor, focus it and ask the monaco editor to replace the selected text with an empty value:","    ```javascript","      var selection = this.editor.getSelection();","      var id = { major: 1, minor: 1 };             ","      var text = \"\";","      var op = {identifier: id, range: selection, text: text, forceMoveMarkers: true};","      this.editor.executeEdits(\"my-source\", [op]);","    ```","  - clear selection: if there is a reference to an editor, ask the monaco editor to clear the current selection.","  - select all: if there is a reference to an editor, ask the monaco editor to select all the text.","  - hasSelection: returns true if there is an editor and it has a non-empty selection","  - getCurrentStyle: return the type of the currently selected line. This is done by checking the comparing the start of the line (after trimming) with all the possible markdown values (heading1, heading2, ..., heading6, code, quote,..) ","","",""],"state":"still-valid"},"d0b23425-dc3b-46f2-92c5-451b2b648400":{"result":[],"prompt":["- The undo service is a global singleton that keeps track of all the text edits that the user performs on the various monaco-editors.","- It has an undo and redo list.","- don't freeze the global object",""],"state":"still-valid"},"958692be-22c0-452b-90ac-6c36a431fafd":{"result":[],"prompt":["- the Key service is responsible for creating and loading UUID keys for text-fragment.","- to map a key to a text fragment during loading, the location of the text fragment within the text is used.","- A text fragment's location is a string built up out of the sequence of titles of all the parent text fragments in the project, concatenated with ' > '. ex: 'root > title1 > subtitle > item'. ","Use the 'calculateLocation' function to build this string.","- fields:","  - loadUuidFromLocs: a dictionary, when assigned, indicates that the project is being loaded and these uuids should be used.","- functions:","  - assignKey(fragment, index): ","    - if there is a loaduuidFromLocs dict, ","      - create the location, ","      - search the location, ","      - if it exists: ","        - assign the uuid to the fragment and remove the entry from the dict so that we know this was a valid key.","    - if  there is no loaduuidFromLocs dict or the location wasn't in the dict:","      - create a new UUID key and assigns the key to the fragment. ","  - getLocations(): creates a dictionary of location - key pairs from the project service's fragments list and returns it. ","  - calculateLocation: for calculating the key of a text-fragment. It accepts as input a text-fragment and the index position of that text-fragment in the project. it goes as follows:","    - if the index position is not provided, get the index from `projectService.textFragments.indexOf(fragment)`","    - the current depth = the depth-level of the text-fragment","    - the result value = the title of the text-fragment","    - loop from the given index position until 0 using the field idx","      - prev-fragment = the text-fragment that the project-service has at position 'idx' `ProjectService.textFragments[idx]`","      - if there is a prev-fragment and the depth-level of the prev-fragment is smaller then the current depth:","        - store the new current depth","        - prepend the title of the prev-fragment + ' > ' to the result","        - if the new current depth == 1, stop the loop",""],"state":"still-valid"},"31da607d-07e2-4c54-9b1c-9a11a786c58f":{"result":[],"prompt":["- the line-parser service is a global singleton object used to parse markdown lines and update the the text-fragments stored in the project-service.","- It has:","  - fragmentIndex: the line-parser service maintains an array of text-fragment objects. When the service is created, this list is empty.","  - createTextFragment: a function for creating new text-fragments (json objects). it accepts as input a string which is the line that is being processed and the index nr at which the object should be placed.","    - trim the line and convert it to lower case.","    - count the nr of '#' that are in front of the title and assign to the depth-level of the text-fragment. so '#' is level 1, '##' is level 2, '###' is level 3 and so on.","    - remove all the '#' from the line, trim again (to remove any spaces at the front) and assign to the title value of the text-fragment.","    - set the 'is-out-of-date' flag to true, indicating that this fragment hasn't been processed yet","    - initialize an empty array for the 'lines' field","    - initialize an empty array for the 'outOfDateTransformers'","    - ask the key-service to assign a key to the text-fragment `assignKey(textFragment, index)`.","    - ask the project-service to add the text-fragment in it's list of text-fragments (projectService.addTextFragment(textFragment, index)).","    - do not add to the fragmentsIndex (is done separately)","    - return textFragment","  - clear: clear the fragmentsIndex list.","  - getStartLine(fragment): `return this.fragmentsIndex.indexOf(fragment)`","  - pseudo code for the parse function and related:","    ```python (pseudo)","","      def parse(line, index):","        trimmedLine = line.trim()","        if trimmedLine == '':","          lineParserHelpers.handleEmptyLine(this, index)","        elif trimmedLine.startsWith('#'):","          lineParserHelpers.handleTitleLine(this, trimmedLine, index)","        else:","          if line[-1] == '\\r':","            line = line[:-1]","          lineParserHelpers.handleRegularLine(this, line, index) # keep the full line with spaces cause it's regular text","","      def insertLine(line, index):","        this.fragmentsIndex.insert(index, null)","        this.parse(line, index)","","      def deleteLine(index):","        lineParserHelpers.deleteLine(this, index)","        del this.fragmentsIndex[index]","    ```",""],"state":"still-valid"},"3fdc58f1-93e1-4eb2-8e18-9be3282323a1":{"result":[],"prompt":["","The module 'LineParserHelpers' contains the following helper functions used by the line parser service, described in pseudo code:","","    ```python (pseudo)","","      def getFragmentAt(service, index):","        curFragment = service.fragmentsIndex[index]","        while not curFragment and index >= 0:","          index -= 1","          curFragment = service.fragmentsIndex[index]","        if curFragment and index > 0:","          while index > 0 and service.fragmentsIndex[index-1] == curFragment:","            index -= 1","        return curFragment, index","","","      def handleEmptyLine(service, index):","        fragmentsIndexEmpty = service.fragmentsIndex.length == 0 or service.fragmentsIndex.find(t => t==null)?.length == service.fragmentsIndex.length","        if fragmentsIndexEmpty:","          while service.fragmentsIndex.length <= index:","             service.fragmentsIndex.push(null)","        else:","          fragment, fragmentStart = getFragmentAt(service, index)","          if not fragment:","            raise Exception('internal error: no fragment found in non empty index table')","          if index == fragmentStart:","            this.removeFragmentTitle(service, fragment, null, index)","          else:","            fragmentLineIndex = index - fragmentStart - 1","            while fragment.lines.length < fragmentLineIndex:","              fragment.lines.push('')","              service.fragmentsIndex[fragmentStart + fragment.lines.length] = fragment","            if fragment.lines.length > fragmentLineIndex:","              fragment.lines.insert(fragmentLineIndex, '')","              service.fragmentsIndex[index] = fragment","","","      def updateFragmentTitle(service, fragment, line):","        line = line.trim().toLowerCase()","        fragment.depth = line.split('#').length - 1","        fragment.title = line.replace(/#/g, '').trim();","        eventParams = { fragment }","        projectService.dispatchEvent('title-changed', eventParams)","","","      def removeFragmentTitle(service, fragment, line, index):","        prevFragment, prevIndex = getFragmentAt(service, index-1)","        if not prevFragment: # title of first was removed, set title to empty","          if line:","            fragment.lines.insert(0, line)","          updateFragmentTitle(service, fragment, '')","        else:","          if line:","            prevFragment.lines.push(line)","#copy all the lines to the previous fragment","          for l in fragment.lines:","            prevFragment.lines.push(l)","# update the index cause the fragment will be replaced by the previous","          while (service.fragmentsIndex[index] == fragment):","            service.fragmentsIndex[index] = prevFragment","            index += 1","          projectService.deleteTextFragment(fragment)","          projectService.markOutOfDate(prevFragment)","","","      def insertFragment(service, fragment, fragmentStart, line, fragmentPrjIndex, index):","        toAdd = service.createTextFragment(line, fragmentPrjIndex)","        service.fragmentsIndex[index] = toAdd","        localIndexOfNewFragment = index - (fragmentStart + 1) # add 1 to fragment start for the title","# the index of the new fragment local to the previous now contains a title instead of line, so remove","        if localIndexOfNewFragment < fragment.lines.length:","          fragment.lines.deleteAtIndex(localIndexOfNewFragment)","#everything that came after local-index needs to be copied to the new fragment","          while localIndexOfNewFragment < fragment.lines.length:","            index += 1","            service.fragmentsIndex[index] = toAdd","            toAdd.lines.insert(0, fragment.lines.pop())","        projectService.markOutOfDate(fragment)","","","      def isInCode(fragment):","        linesStartingWithCode = 0","        for line in fragment.lines:","          trimmed = line.trim()","          if trimmed.startsWith('```'):","            linesStartingWithCode += 1","        return linesStartingWithCode % 2 == 1","","","      def handleTitleLine(service, line, index):","        fragment, fragmentStart = getFragmentAt(service, index)","        if (fragmentsIndex.length == 0 or fragmentsIndex.length < index or fragmentsIndex[index] == null) and (not fragment or not isInCode(fragment)):","          toAdd = service.createTextFragment(line, projectService.textFragments.length)","          while service.fragmentsIndex.length <= index:","             service.fragmentsIndex.push(null)","          service.fragmentsIndex[index] = toAdd","        else:","          if not fragment:","            raise Exception('internal error: no fragment found in non empty index table')","          fragmentPrjIndex = projectService.textFragments.indexOf(fragment)","          if fragmentStart == index:","            updateFragmentTitle(service, fragment, line)","          elif isInCode(fragment):","            handleRegularLine(service, line, index)","          else:","            insertFragment(service, fragment, fragmentStart, line, fragmentPrjIndex + 1, index)","","","      def updateFragmentLines(service, fragment, line, index, fragmentStart):","        fragmentLineIndex = index - fragmentStart - 1 # extra - 1 cause the text starts at the line below the title","        isChanged = True","        if fragmentLineIndex < fragment.lines.length: # changing existing line","          isChanged = fragment.lines[fragmentLineIndex] !== line","          fragment.lines[fragmentLineIndex] = line","        else:","          while fragment.lines.length < fragmentLineIndex:","            service.fragmentsIndex[fragmentStart + fragment.lines.length] = fragment","            fragment.lines.push('')","          fragment.lines.push(line)","          service.fragmentsIndex[index] = fragment","        if isChanged:","          projectService.markOutOfDate(fragment)","","","      def handleRegularLine(service, line, index):","        fragment, fragmentStart = service.getFragmentAt(index)","# no fragment yet at this line or in front of it, create new one","        if not fragment:","          toAdd = service.createTextFragment('', 0)","          toAdd.lines.push(line)","          while service.fragmentsIndex.length <= index:","             service.fragmentsIndex.push(null)","          service.fragmentsIndex[index] = toAdd","        elif fragmentStart == index and fragment.title: # went from title to regular","          removeFragmentTitle(service, fragment, line, index)","        else:","          updateFragmentLines(service, fragment, line, index, fragmentStart)","","","      def deleteLine(service, index):","        fragment, fragmentStart = service.getFragmentAt(index)","        if fragment:","          if fragmentStart == index: # fragment is being removed. if it still has lines, copy to prev, if no prev, leave with no title","            removeFragmentTitle(service, fragment None, index)","          else:","            del fragment.lines[index - fragmentStart - 1]","","    ```",""],"state":"still-valid"},"45fd1335-5429-47ea-a577-c11db18a28a0":{"result":[],"prompt":["- the position-tracking service is a global singleton object responsible for tracking the text-fragment and transformer that the user is currently working on / with.","- The service keeps track of:","  - the currently selected line nr","  - the text-fragment related to the currently selected line. This is an object that can be assigned (property: activeFragment). When this value changes, an event needs to be raised so that other parts of the application can move to the new active fragment.","  - a reference to the currently active transformer. This is used to run a build only for the active transformer (field: activeTransformer)","  - an eventTarget that stores the events which monitor changes in the currently selected text-fragment.","- it provides the following methods:","  - setCurrentPos: set currently selected line and column, input: pos.","    - col-index = pos.column - 1","    - line-index = pos.lineNumber - 1","    - if the new line-index is different from the currently stored line index:","      - get the object at the line-index position found on the fragmentsIndex array of the line-parser service.","        - if undefined was found, try again with `lineIndex - 1`. (This is because when adding an empty line at the end, no text-fragment index is kept for as long as the line remains empty) ","      - If this object differs from currently selected text-fragment, then store the object as the new currently selected text-fragment and trigger the 'change' event for all the registered event handlers, passing the text-fragment as event data.","    - trigger the 'pos-changed' event for all the registered event handlers so that components that need to be updated at every position change, can be updated","  - clear:","    - set activeFragment & currentLine to null","  - setActiveFragment(fragment):","    ```python","      if not this.activeFragment == fragment:","        startPos = lineParser.getStartLine(fragment)","        if startPos > -1:","          event = new CustomEvent('moveTo', {detail: startPos + 1})","          this.eventTarget.dispatchEvent(event)","","    ```","  - setActiveTransformer(transformer): called when the user selected a different transformer","    ```python","      if not this.activeTransformer == transformer:","        this.activeTransformer = transformer","        event = new CustomEvent('change', {detail: transformer})","        this.eventTarget.dispatchEvent(event)","","    ```",""],"state":"still-valid"},"68dbb9c3-e1a8-4287-b68a-db5070e55505":{"result":[],"prompt":["- the log service is a global singleton that is responsible for keeping track of messages that should be shown to the user.","- fields:","  - eventTarget: a field used to dispatch events.","- properties:","  - showLogWindow: when set:","    - call  `window.electron.showLogWindow(value)`","    - trigger the `log-window-visibility` event through the 'eventTarget' field","- functions:","  - beginMsg(transformerName, fragmentKey, inputData): ","    - creates a gpt msg log item, ","    - convert the fragmentKey to a location using `keyService.calculateLocation(ProjectService.getFragment(fragmentKey))`","    - store all the data and assigns a UUID to the log object. ","    - if in debug mode (buildService.debug), then make certain that the log window is open","    - This log object is then serialized to a string (pretty print) and send to the log window using the global function `window.electron.logMsg`. ","    - Finally returns the log object.","  - logMsgResponse(logObj, response): creates an object containing the response and the UUID field of the logObj, serializes this object and sends it to the log window using `window.electron.logMsg`. If in debug mode (buildService.debug), then make certain that the log window is open","  - setLogWindowVisibility: a function that ","    - should be registered as a callback with `window.electron.onLogWindowVisibility`, unregistered using `window.electron.removeOnLogWindowVisibility`","    - when called:","      - don't call `window.electron.showLogWindow(value)` cause the window is reporting it's new state","      - update the internal state of showLogWindow","      - trigger the `log-window-visibility` event through the 'eventTarget' field",""],"state":"still-valid"},"0136ea45-e1de-4444-b833-2d8cfd2cc956":{"result":[],"prompt":["- the GPT service is a global singleton that is responsible for communicating with the open-ai api backend. It is primarily used by transformers that perform more specific tasks.","- the service uses:","  - the openai node.js library to communicate with the backend.","  - the js-tiktoken library for calculating the token size of the input.","- defaultModel: stores the default model to use during api calls.","  - setDefaultModel: store the default model in the field & in localStorage","  - getDefaultModel: return the field","  - during construction, load the defaultModel from localStorage","- onMarkDirty: a field that optionally contains a callback that gets called when the modelsMap changes","- modelsMap: a field (initialized as dictionary), stores which model should be used for individual transformers and also per transformer, for each individual text-fragment.","  - setModelForTransformer(model, transformer): assign a model to a transformer:","    ```python","      if not transformer.name in this.modelsMap:","        map = {}","        this.modelsMap[transformer.name] = map","      else:","        map = this.modelsMap[transformer.name]","      map['__default'] = model","      if onMarkDirty:","        onMarkDirty()","    ```","  - getModelForTransformer(transformer): `return this.modelsMap[transformer.name]?.['__default']`","  - setModelForFragment(model, transformer, key): assign a model to a transformer:","    ```python","      if not transformer.name in this.modelsMap:","        map = {}","        this.modelsMap[transformer.name] = map","      else:","        map = this.modelsMap[transformer.name]","      map[key] = model","      if onMarkDirty:","        onMarkDirty()","    ```","  - getModelForFragment(transformer, key): `return this.modelsMap[transformer.name]?.[key]`","- sendRequest: other services (or components) can call to send an api request to open-ai.","  - function parameters:","    - transformer: the transformer that is calling the function","    - fragmentKey: the key of the fragment that is being processed","    - messages: json objects that contain a `role` and `content` field.","  ```python","    if not this.openai:","      return","    model = this.getModelForRequest(transformer.name, fragmentKey)","    tokens = this.calculateTokens(messages, model)","    inputData = {","      model: model,","      messages: messages,","      max_tokens: transformer.calculateMaxTokens(tokens),","      temperature: transformer.temperature or 0","    }","    config = {","      maxRetries: 3,","    }","    logMsg = logService.beginMsg(transformer.name, fragmentKey, inputData)","    await BuildService.tryPause()","    response = await this.openai.chat.completions.create(inputData, config)","    reply = None","    if response:","      reply = response.choices[0]?.message?.content","      if transformer.isJson:","        try:","          reply = JSON.parse(reply)","        except(err):","          dialogService.showError('Failed to convert result to json', err)","    await logService.logMsgResponse(logMsg, reply)      ","    await BuildService.tryPause()","    return reply","  ```","- getModelForRequest: search for the model to use in the modelsMap dictionary:","  ```python","  def getModelForRequest(transformerName, fragmentKey):","    if transformerName in this.modelsMap:","      section = this.modelsMap[transformerName]","      if fragmentKey in section:","        return section[fragmentKey]","      if '__default' in section:","        return section['__default']","    return this.getDefaultModel()","  ```","- calculateTokens(messages, model): calculates the nr of tokens used by the input message using the  function getEncoding from the js-tiktoken library","  ```python","    result = {}","    encoding = getEncoding(model)","    for message in messages:","      result[message.role] = len(encoding.encode(message.content))","    return result ","  ```","- getModels: a method to retrieve the list of available models. ","  - To retrieve this list, the openai nodejs library is used. `(await this.openai.models.list())?.data?.map((model) => model.id) ?? [];`","  - only try to retrieve the list of models if there is a key available","  - if there is no key available, show a dialog message to the user asking him to provide a valid open-ai api key. Only ask 1 time. Return an empty list.","  - sort the list","  - after retrieving the list from openai, store in local variable. if this variable is set, return this instead of retrieving the value.","- apiKey: stores the api key to use when creating the openAI object.","  - load from localStorage (globally available) during construction of the service","- setApiKey: updates the api key","  - save to localStorage","  - recreate openAI object `new OpenAI({apiKey, dangerouslyAllowBrowser: true})`.","  - reset flag so errors can be shown again","- only instantiate the OpenAI library if a valid apiKey is provided",""],"state":"still-valid"},"96aad863-3686-497b-8638-99081b0c947e":{"result":[],"prompt":["- this service manages previously retrieved results for transformers.","- for each transformation that the transformer creates, the cache stores: ","  - the result of the transformation","  - a state to keep track if the result has become out of date or not (any of the inputs of the transform operation has changed).","  - the input that was used to generate the output. this is used to verify if the result has become out-of-date or not. This is an array of json objects.","- because some transformers use data from the project directly and others use the results of other transformers, the result cache must be able to monitor changes in a project service and result-caches of other transformers.","- A transformer that wants to cache it's results uses an instance of this class to perform these tasks on it's results.","- internally, the cache uses a dictionary that maps the keys to their results.","- whenever the transformer calculates a result, it asks the cache to update it's dictionary by calling 'setResult'.","- the cache stores the results in a json file (saveCache).","  - if the 'is-dirty' flag is not set, no need to save the results","  - file writes are done async. ","  - after saving the cache, the 'is-dirty' flag is reset.","  - the name of this file is specified as follows: `FolderService.projectName + transformer.name` (the transformer is a constructor parameter, store a ref to the transformer for later usage)","  - the location of the file (folder) is provided by folder-service.cache","  - the json file contains:","    - the primary dictionary that contains the results.","    - the secondary dictionary that contains the relationships between keys of text-fragments and full dictionary entries in the primary dict (which can consist out of multiple keys cause 1 result value can have multiple inputs).","    - a third dictionary that contains all the overwritten values of the results (if any)","    - a date that specifies the last save date of the project file. This is used when loading the dictionary back from file to verify if the results are still valid or not (when this date doesn't match the last-modified date of the project, something is out-of sync and consider the results in the file out-of-date).","  - the cache tries to load this json file during construction of the instance. If the file doesn't exist, clearCache() is called to make certain that the cache is empty again.","- When the result-cache-service is created, it:","  - initializes the 'is-dirty' flag to false","  - initialize eventTarget `this.eventTarget = new EventTarget()`","- load(inputServices): a function that is called after construction to load the cache from file and register all the event handlers:","  - registers the event handler 'handleFragmentDeleted' with the project service to monitor when a fragment is deleted","    - register using pseudo: `projectService.eventTarget.addEventListener('fragment-deleted', handleFragmentDeleted)`","  - registers an event handler with the project service to monitor when text fragments have changed","    - register using pseudo: `projectService.eventTarget.addEventListener('fragment-out-of-date', handleTextFragmentChanged)`","  - and registers the same event handler for the `result-changed` event with each of the inputServices (each service has a field 'cache')","  - whenever the event handler is triggered (event.detail = fragment-key), the cache service checks in the secondary dictionary if there are any entries for that key. This allows the system to react to changes in single text-fragments, even though there were multiple input text-fragments (and so the keys in the primary dictionary are a concatenation of multiple titles).","    - for each key in the list:","      - search in the primary dictionary, if this contains an item for the key, store a reference to the item","      - if not yet marked as out-of-date and `this.transformer.hasPromptChanged(key, item.prompt)`:","        - mark as out-of-date","        - set the 'is-dirty' flag","        - if there are any other cache services that monitor this cache-service (instead of the project service directly), then let them know that the specified text-fragment (from the result) has gone out-of-date.","    - after all items in the list have been processed, call projectService.tryAddToOutOfDate(fragmentKey, this.transformer)","- the result-cache has a function to overwrite the result for a key. this overwritten text value is stored in the 'overwrites' dictionary, under the supplied key. When called, set the 'is-dirty' flag.","- the result-cache has a function to retrieve the result for a particular key: the key is first searched in the 'overwrites' dictionary. if this has a result, return this value, otherwise try to return the value found in the results dictionary.","- the result-cache has a function to retrieve if a text fragment is out-of-date or not (from the key): if the result is marked as out-of-date, returns true","- clearCache(): a function to clear the cache, secondary cache & overwrites","- handleFragmentDeleted: an event handler called when a fragment is deleted. in pseudo:","  ```python (pseudo)","  def handleFragmentDeleted(e):","    fragmentKey = e.detail","    this.deleteResultsFor(fragmentKey)","# all values that are part of the result of another fragment, should also be deleted and the fragments marked out of date.","    cacheKeys = this.secondaryCache[fragmentKey]","    if cacheKeys:","      for key in cacheKeys: ","        if this.cache[key].state != 'out-of-date':","          this.cache[key].state = 'out-of-date'","          keyParts = key.split(' | ')","          outOfDateFragment = keyParts[0]","          ProjectService.tryAddToOutOfDate(outOfDateFragment, this.transformer)","      delete this.secondaryCache[fragmentKey]          ","      this.isDirty = True    ","  ```","- deleteResultsFor(fragmentKey): all full-keys in the secondary cache for the specified key that start with that key, are deleted from the primary cache.","  ```python","    cacheKeys = this.secondaryCache[fragmentKey]","    if cacheKeys:","      leftOver = []","      for key in cacheKeys:","# we are only interested in the results of specified fragment, so it must be it's first key","        if not key.startsWith(fragmentKey): ","          leftOver.push(key)","          continue","        delete this.cache[key]        ","        this.removeKeyFromSecondary(fragmentKey, key)","        this.isDirty = True","      if len(leftOver) > 0:","        this.secondaryCache[fragmentKey] = leftOver","      else:","        delete this.secondaryCache[fragmentKey]","  ```","- removeKeyFromSecondary(forFragmentKey, key):","  ```python","    keyParts = key.split[' | ']","    for part in keyParts:","      if part != forFragmentKey:","        refKeys = this.secondaryCache[part]","        refKeys.remove(key)","        if len(refKeys) == 0:","          delete this.secondaryCache[part]","  ```  ","- deleteAfterUpdate(fragmentKey, keysToRemove): removes the results that are no longer valid after an update for the fragment with the specified key.","  ```python","    allKeys = this.secondaryCache[fragmentKey]","    for oldKey in keysToRemove:","      if allKeys:","        allKeys.remove(oldKey)","      this.removeKeyFromSecondary(fragmentKey, oldKey)        ","      delete this.cache.cache[oldKey]","  ```","- getFragmentResults: a function to retrieve all the results related to a particular fragment. Definition in pseudo:","  ```python (pseudo)","  def getFragmentResults(fragmentKey):","    if this.overwrites[key]: # entire fragment could be overwritten, if so, return this","      return this.overwrites[key]","    result = None","    cacheKeys = this.secondaryCache[fragmentKey]","    if cacheKeys:","      for key in cacheKeys:","# we are only interested in the results of specified fragment, so it must be it's first key","        if not key.startsWith(fragmentKey): ","          continue","        cacheValue = this.getResult(key)","        keyParts = key.split(' | ')","        addTo = None","        if len(keyParts) > 1:","          if not result: # if the result is already created, reuse so we can append values.","            result = {}","          addTo = result","        for part in keyParts[:-1]: # last is the key for the cache value","          nextAddTo = None","          if not part in addTo:","            nextAddTo = {}","            addTo[part] = nextAddTo","          else:","            nextAddTo = addTo[part]","          addTo = nextAddTo","        if addTo:","          addTo[keyParts[-1]] = cacheValue","        elif result:","          if Array.isArray(result):","            result.push(cacheValue)","          else:","            result = [result, cacheValue]","        else:","          result = cacheValue","    return result","  ```","- setResult: stores the result in the cache. in pseudo:","  ```python (pseudo)","  def setResult(key, result, prompt):","    isModified = True","    if not key in this.cache:","      this.cache[key] = { result, prompt, state: 'still-valid' }","      keyParts = key.split(' | ')","      for part in keyParts:","        if not part in this.secondaryCache:","          this.secondaryCache[part] = [key]","        else:","          this.secondaryCache[part].push(key)","    elif this.cache[key].result != result:","      this.cache[key].result = result","      this.cache[key].state = 'still-valid'","    elif this.cache[key].state != 'stil-valid':","      this.cache[key].state = 'still-valid'","    else:","      isModified = False","    if isModified:","      this.isDirty = True","      storageService.markDirty()","      this.eventTarget.dispatchEvent(new CustomEvent('result-changed', { detail: key }))","  ```","getResult(key): `if key in this.overwrites: return this.overwrites[key] else if key in this.cache: return this.cache[key].result else return null`","- isOutOfDate(keyPart): checks if the specified key is present and marked as still-valid","  ```python (pseudo)","  def isOutOfDate(keyPart):","    if keyPart in this.cache:","      return this.cache[keyPart].state != 'still-valid'","    if keyPart in this.secondaryCache:","      for key in this.secondaryCache[keyPart]:","        if this.cache[key].state != 'still-valid':","          return True","      return False","    return True","  ```","- overwriteResult(key, value):","  ```python","    if value:","      if this.overwrites[key] == value: return","      this.overwrites[key] = value","    else:","      delete this.overwrites[key]","    this.isDirty = true","    this.eventTarget.dispatchEvent(new CustomEvent('result-changed', { detail: key }))","    storageService.markDirty()","  ```","- isOverwritten(key): `return key in this.overwrites`","",""],"state":"still-valid"},"33a93cd2-11ee-4ec2-9263-101b212474ab":{"result":[],"prompt":["- the build service is a global singleton that processes all the text-fragments of the project-service. It uses a set of transformers to iteratively generate conversions on the different text-fragments.","- eventTarget: a field used to dispatch events.","- showDebugger: a property, when set:","  - call `window.electron.showDebugger(value)`","  - trigger the `show-debugger` event through the 'eventTarget' field","- async buildAll(transformer): to build the project, do:","  - make certain that the folder service is initialized","  - if `transformer.isFullRender` exists","    - call `await transformer.getResults(ProjectService.textFragments)`","  - otherwise: for each fragment in project-service.textFragments: ","     - `await transformer.getResult(fragment)`","  - on error: `DialogService.showErrorDialog(error)`","- async runTransformer(fragment, transformer):","  - make certain that the folder service is initialized","  - ask the transformer to get it's result (`getResult(fragment)`) (async)","  - on error: `DialogService.showErrorDialog(error)`","- debug: a property to indicate if the build service is currently in debug mode or not. Load the value from local storage upon creation. When the value is updated, save to local storage","- isBuilding: a property to indicate if one of the build functions (buildAll, runTransformer, buildFragment) is currently running or not. These functions set isBuilding to true at the start and use a try-finally to make certain that the isBuilding flag is also turned to false at the end.","  - set isBuilding: trigger the 'is-building' event through the 'eventTarget' field","- isPaused: a property that gets wether currently paused or not. `!!this.debugResolver;`","- tryPause: a method to pause execution until user presses continue or stop button, if in debug mode.","  ```python","    def tryPause():","    if this.debug:","      pause = new Promise((resolve, reject) => {","        this.debugResolver = resolve","        this.debugRejector = reject","      })","      this.eventTarget.dispatchEvent(new CustomEvent('is-pausing'))","      await pause","      this.eventTarget.dispatchEvent(new CustomEvent('has-resumed'))","  ```","- runNext: raise the debugResolver (if assigned) and reset to null    ","- stopRun: raise the debugRejector (if assigned) and reset to null","- setDebuggerVisibility: a function that ","    - should be registered as a callback with `window.electron.onDebuggerVisibility`, unregistered using `window.electron.removeOnDebuggerVisibility`","    - when called:","      - don't call `window.electron.showDebugger(value)` cause the window is reporting it's new state","      - update the internal state of showDebugger","      - trigger the `show-debugger` event through the 'eventTarget' field",""],"state":"still-valid"},"1056ce6a-ac4b-410e-91d3-f8117a6084b0":{"result":[],"prompt":["- the build-stack service is used during the build process to make certain that there are no circular references in the process. This occurs when a transformer depends on the result of another transformer that (eventually) again relies on the result of the first transformer, which can't be rendered yet.","- fields:","  - running = {} : a dictionary that keeps track of the textframe - transformer pairs that are currently running. Key calculation for the dict = transformer.name + textframe.key","  - state = `normal`. A transformer can set this to `validating` when it wants to block calls to the llms when rebuilding the message to check if the input has changed (and the cached result has become out of date).","- functions:","  - tryRegister(transformer, fragment):","    ```python","    toSearch = fragment?.key + '-' + transformer?.name","    if toSearch in this.running:","      return False","    this.running[toSearch] = True","    if fragment:","      ProjectService.markIsBuilding(fragment, transformer) # do here cause all transformers need to pass the stack","    return True","    ```","  - unRegister(transformer, fragment):","    ```python","    toSearch = fragment?.key + '-' + transformer?.name","    delete this.running[toSearch]","    if fragment:","      ProjectService.markUpToDate(fragment, transformer) # do here cause all transformers need to pass the stack","    ```","  - isRunning(transformer, fragment):","    ```python","    toSearch = fragment?.key + '-' + transformer?.name","    return toSearch in this.running","    ```",""],"state":"still-valid"},"849a7ae4-6a95-43dd-9c90-6ef41dc86a80":{"result":[],"prompt":["- the cybertron-service is a global singleton that is responsible for managing the list of available transformers.","- the service also maintains a list of entry-points: this is a sub-list of the available transformers which can be used as starting points for building text-fragments.","- the field `activeEntryPoint` keeps track of the currently selected entrypoint, which is one of the transformers of the entryPoints list. ","- Transformers can be registered. this adds them to the list. A second parameter indicates if the transformer should also be added as an entry-point. If the field 'activeEntryPoint' is still empty and the transformer being registered, is an entrypoint, set it as the activeEntryPoint.","- Transformers can also be unregistered. this will remove them from the list of available transformers and the list of entry-points.","- getTransformer(name): search for the transformer with the specified name in this.transformers and return the result","- load(): loads all the transformers","",""],"state":"still-valid"},"ccbe1be3-fea6-4080-bce3-e13de89e4e42":{"result":[],"prompt":["- the all-spark service is a global singleton that is responsible for creating all the transformers and registering them into the cybertron service. ","- fields:","  - eventTarget: to register/unregister event handlers that monitor changes in the loaded transformers","  - transformers: a dictionary that stores a reference to all the transformer objects that get created. The url from where the transformer is loaded from is used as the key. This is used to unregister transformers again.","- functions:","  - getPlugins: returns a list of plugin definitions","    - if the list has not yet been loaded, call: `this.getPluginsList()`","    - return this.plugins","  - getPluginsList: If the current project contains a plugins folder, load the project-local file, otherwise load the globally available set of plugins.","    ```python pseudo","      pluginFolder = folderService.pluginsOutput","      path = os.path.join(pluginFolder, 'plugins.json')","      if not fs.existsSync(path):","        resourcesPath = window.electron.resourcesPath","        pluginFolder = path.join(resourcesPath, 'plugins')","        path = os.path.join(pluginFolder, 'plugins.json')","      if fs.existsSync(path):","        plugins = fs.readSync(path)","        this.plugins = json.parse(plugins)","        for (i = 0; i < this.plugins.length; i+=1)","          this.plugins[i] = path.join(pluginFolder, this.plugins[i]);","      else:","        this.plugins = []","    ```","  - refreshPlugins: unloads the old plugins, refreshes the list of plugins and loads all the new plugins","    ```python","      for plugin in this.plugins:","        await this.unloadPlugin(plugin)","      await this.getPluginsList() # forces a reload of the list","      await this.loadPlugins()","    ```","  - loadPlugin(definition):","    - do: `return global.require(definition)`","    - wrap round try-catch. On error, show an error dialog.","  - unloadPlugin(definition):","    - do: ","      ```python","        cybertronService.unregister(this.transformers[definition])","        delete require.cache[definition]","        delete this.transformers[definition]","      ```","    - wrap round try-catch. On error, show an error dialog.","  - load: create the transformers and register them with the cybertron-service. ","    - This function is called after the application has loaded.","    - don't run if `window.electron.isLogMode === true`","    - to register, use: `cybertronService.register(transformer, false)`, to register as entry point, use: `cybertronService.register(transformer, true)`","    - register every transformer after construction so that it can be found in the list by other transformers.","    - transformers to create:","      - constant-extractor service","      - plugin-renderer service (entry point)","      - plugin-list renderer service (entry point)","      - constants-resource renderer (entry point)","      - parser validator service","    - call `await this.loadPlugins()`","  - loadPlugins: when not in pluginMode (cause when in that mode, we are editing the plugins and can only use the built in ones), loads all the plugins and creates a transformer for each","    - when `window.electron.isPluginMode == false and window.electron.isLogMode == false`:","      - for every transformer url in this.getPlugins():","        - pluginObj = this.loadPlugin(ul)","        - create a new plugin-transformer service, with constructor param 'pluginObj'","        - store a reference of the new plugin-transformer object in the 'transformers' dictionary, key: url so that we can unload it again if required.","        - register plugin-transformer, to determine if it's an entry-point, use 'pluginTransformer.isEntryPoint'","      - after all transformers are loaded, dispatch the event 'transformers-loaded'",""],"state":"still-valid"},"421a1524-3e5c-431e-8444-470cae1d6cbb":{"result":[],"prompt":["- The transformer-base service acts as a base class for transformers: it provides a common interface and functionality","- constructor:","  - name: the name of the transformer","  - dependencies: a list of names of transformers.","  - isJson: when true, the result values should be treated as json structures, otherwise as regular text.","  - language: in which language the result data should be shown. if not provided, defaults to 'markdown'","  - temperature: temp to use for the llm requests. defaults to 0","  - isFullRender: when true, a renderResults function is available that performs a task on all fragments at once. Default = false.","- this service uses a result-cache-service (field: cache) to store all the results and keep track of when the build has gone out-of-date. ","  - constructor params:","    - transformer = this","    - dependencies = this.dependencies","- functions:","  - load(): load the dependencies (the list of names of transformers) and create the cache. Replace every name in the list with the object found in the cybertron-service's list of transformers. If a name can not be found, raise an exception with the necessary info. Store the list of objects as 'dependencies'. Ask the Cybertron service and the cache object to load as well.","  - renderResults(fragments): for transformers that require the entire project as input. throws a not-implemented error since inheritors need to supply this function.","  - renderResult(textFragment): do a full rerender for the fragment","    ```python (pseudo)","    def renderResult(textFragment):","      keyedMessage = await this.buildMessage(textFragment)","      if not keyedMessage: ","        return None","      message, keys = keyedMessage","      result = await GPT-service.sendRequest(this, textFragment.key, message) # need name and key so the gpt service can select the correct model","      if keys:","        keys.insert(0, textFragment.key)","      else:","        keys = [textFragment.key]","      key = ' | '.join(keys)","      this.cache.setResult(key, result, message)","      return result","    ```","  - hasPromptChanged(key, prompt): rebuilds the prompt that the transformer should send to the llm to calculate the result. This is used to check if the current result is out of date or not (when the prompt remains the same, the result is still valid).","  ```python","    buildStackService.mode = 'validating' # make certain that only cache values are used, no calls to the llm ","    try:","      key = key.split(' | '))","      args = this.keyToMessageParams(key) # some transformers require multiple parameters which need to be rebuild","      keyedMessage = await this.buildMessage(*args)","      if not keyedMessage: ","        return None","      message, keys = keyedMessage","      return JSON.stringify(message) != JSON.stringify(prompt) # structure and everything must remain the same","    finally:","      buildStackService.mode = 'normal'","  ```","  - keyToMessageParams(key): converts the key to text fragments when possible. This is used while checking if a result has gone out of date, to recreate the llm-prompt based on the latest values. If a transformer uses custom data for the parameters of the buildMessage parameters, these should be supplied here as well.","    ```python","      result = []","      for part in key:","        fragment = projectService.getFragment(part)","        if fragment:","          result.push(fragment)","        else:","          result.push(part)","      return result","    ```","  - updateResult(fragment): only do an update if (part of) the cache is not up to date. allows for partial updates by descendent. not for external consumption cause it does not register the call with the build-stack.","    ```python","      if not this.cache.isOutOfDate(fragment.key):","        return this.cache.getFragmentResults(fragment.key)","      return this.renderResult(fragment)","    ```","  - getResult(fragment): get an up-to-date result value for the specified key. Use the cache when possible. This function should be used instead of updateResult cause it registers the call with the buildStack service and makes certain that only the cache is used when in validation mode.","    ```python (pseudo)","    async def getResult(fragment):","      if buildStackService.mode == 'validating':","          result = this.cache.getFragmentResults(fragment.key)","      if not buildStackService.tryRegister(this, fragment):","        return # circular reference, not good, stop the process","      try:","        result = await this.updateResult(fragment)","        return result","      finally:","        buildStackService.unregister(this, fragment)","    ```","  - getResults(): get an up-to-date result value. This function should be used instead of updateResult cause it wraps","    ```python (pseudo)","    async def getResult():","      if not buildStackService.tryRegister(this):","        return # circular reference, not good, stop the process","      try:","        result = await this.renderResults()","        return result","      finally:","        buildStackService.unregister(this)","    ```","  - calculateMaxTokens(inputTokens): calculate the maximum tokens for the llm to optimize speed and cost","    ```python (pseudo)","      totalInput = 0","      for key, value in inputTokens.items():","        totalInput += value","      return totalInput * 2","    ```","  - buildMessage(textFragment): builds the message from the text fragment. throws a not-implemented error since inheritors need to supply this function.",""],"state":"still-valid"},"8593a8f2-cefd-4ae4-b7e3-57bec9014a87":{"result":[],"prompt":[""],"state":"still-valid"},"32ab0827-4dc7-4078-bd8a-88ea9064239d":{"result":[],"prompt":["- The constant-extractor service makes certain all constant definitions (between quotes) are extracted from the source code, rendered to a json file and replaced with references to the json-entries in the source texts.","- inherits from transformer-base service. Constructor parameters:","  - name: 'constants'","  - dependencies: []","  - isJson: true","- functions:","  - load: ask super to load and set the field `constantsService = this.dependencies[0]`","  - extract-quotes: extract all the locations in the text that contain quotes","  ```python (pseudo)","    def extractQuotes(fragment):","      key = fragment.key","      lines = fragment.lines","      quotes = []","      current_quote = None","      cur_lines = []","      line_nr = 0","      count = 0","      for line in lines:","          line = line.lstrip()","          if line.startswith('>'):","              line = line[1:] # remove the > ","              if len(line) > 0 and line[0] == ' ':  # and the space but leave everything else cause we want the exact quote","                  line = line[1:]","              cur_lines.append(line)","              if not current_quote:","# could be that the previous line was empty, in that case, start the quote a line earlier","                  if line_nr > 0 and not lines[line_nr - 1].strip():","                      current_quote = {'start': line_nr - 1}","                  else:","                      current_quote = {'start': line_nr}","          elif not line and current_quote: # empty line so we need to close the quote","              count += 1","              collectResponse(current_quote, line_nr, cur_lines, fragment, count, quotes)","              current_quote = None","              cur_lines = []","          line_nr += 1","      if current_quote:","          count += 1","          collectResponse(current_quote, line_nr, cur_lines, fragment, count, quotes)","      return quotes","  ```","  - collect-response: add a quote to the list of quotes","  ```python","    def collectResponse(toAdd, end, lines, fragment, count, quotes):","      title = keyService.calculateLocation(fragment)","      title = 'res_' + title.replaceAll(' > ', '_').replaceAll(' ', '_').replaceAll('-', '_').strip()","      toAdd['end'] = line_nr","      toAdd['lines'] = lines","      toAdd['name'] = '{0}_{1}'.format(title, count)","      quotes.append(current_quote)","  ```","  - render-result(pseudo):","    ```python (pseudo)","    def renderResult(textFragment):","      result = this.extractQuotes(textFragment)","      this.cache.setResult(textFragment.key, result, [*textFragment.lines]) # duplicate lines so that the cache has a local copy that doesn't change if the lines in the text fragment change","      return result","    ```","  - get-result(key): get an up-to-date result value for the specified key. Use the cache when possible.","    ```python (pseudo)","    async def getResult(fragment):","      quotes = []","      if BuildStackService.mode === 'validating' or not this.cache.isOutOfDate(fragment.key):","        quotes = this.cache.getFragmentResults(fragment.key)","      else:","        if not BuildStackService.tryRegister(this, fragment):","          return","        try:","          quotes = await this.renderResult(fragment)","        finally:","          BuildStackService.unRegister(this, fragment)","      if not quotes or len(quotes) == 0:","        return fragment.lines.join('\\n')","      else:","        lines = fragment.lines","        new_lines = []","        consts = [*quotes] # make a copy of the list so we can remove items from it","        current_const = consts.pop(0)","        cur_line = 0","        while cur_line < len(lines):","            if current_const and cur_line == current_const['start']:","# add the constant to the previous line","                new_lines[-1] += f' the value of the constant resources.{current_const[\"name\"]}'","                cur_line = current_const['end'] + 1","                if len(consts) > 0:","                    current_const = consts.pop(0)","                else:","                    current_const = None","            else:","                new_lines.append(lines[cur_line])","                cur_line += 1","        return new_lines.join('\\n')","    ```",""],"state":"still-valid"},"8ac6d3c7-0806-4d9f-a790-88bbb45f9106":{"result":[{"start":171,"end":181,"lines":["Act as a full-stack ai software developer.","It is your task to write a javascript module according to the specifications.","","The module should export all the functions that are declared in the specification ","use the following development stack:","- developed in javascript (ES5)","- The UI is built using react and antd","","Do not include an introduction or any explanation, only generate the code. Only include function that are required or the user included"],"name":"res_mark_services_transformers_plugin_transformer_service_1"},{"start":183,"end":186,"lines":["specification:","{{content}}"],"name":"res_mark_services_transformers_plugin_transformer_service_2"},{"start":192,"end":243,"lines":["Act as a full-stack ai software developer.","It is your task to write a javascript module according to the specifications.","","The module should export an object containing the following fields:","- getDescription(): (required) a function that returns a json object containing the fields:","  - name: (required) name of the transformer","  - dependencies: (required)list of names of other transformers","  - isJson: (required)boolean, true if the transformer produces json data.","  - description: (optional) a string that describes what the transformer does","- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.","- renderResult(fragment): (optional) a function that renders the result for the specified fragment.","- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.","- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt","- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. ","- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.","","use the following development stack:","- developed in javascript (ES5)","- The UI is built using react and antd","","example response:","","```javascript","const resources = require('./resources.json');","const services = {}; // must always be present","const deps = {}; // must always be present","{{sharedImport}}","function getDescription() {","  return {name: 'test', dependencies: ['constants'], isJson: true};","}","async function buildMessage(fragment) {","  var result = [","      {","        role: 'system',","        content: resources.mark_services_transformers_compress_service_0,","      },","      {","        role: 'user',","        content: await deps.constants.getResult(fragment),","      },","    ];","","    return [result, [ ]];","}","function calculateMaxTokens(inputTokenCount) {","  return inputTokenCount + 1;","}","module.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };","```","Do not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."],"name":"res_mark_services_transformers_plugin_transformer_service_3"},{"start":248,"end":251,"lines":["{{title}}","{{content}}"],"name":"res_mark_services_transformers_plugin_transformer_service_4"}],"prompt":["- the plugin-transformer service forms a wrapper round a javascript object that was provided by a plugin. ","  - The plugin provides the configuration info of the transformer","  - The transformer asks the plugin to build the transformer's result and it allows the plugin the overwrite the default behavior at various points.  ","- inherits from transformer-base service.","- constructor:","  - parameters:","    - plugin: object created by the plugin code that provides access to the functions that should be used","  - if the plugin does not have a function `getDescription`, raise an error to indicate that the provided plugin is invalid and can't be used as a transformer","  - do:","  ```python","    this.plugin = plugin","    description = plugin.getDescription()","    if not description:","      raise Exception('Invalid plugin: no description provided')","    super(description.name, description.dependencies, description.isJson, description.language, description.temperature or 0, description.isFullRender)","    this.description = description","    plugin.services.projectService = projectService","    plugin.services.folderService = folderService","    plugin.services.gptService = gptService","    plugin.services.cybertronService = cybertronService","    plugin.services.keyService = keyService","    plugin.services.cache = this.cache","  ```","- load:","  ```python","    super.load()","    for const dep in this.dependencies:","      this.plugin.deps[dep.name] = dep","    if this.plugin.load:","      this.plugin.load()","  ```","- calculateMaxTokens(inputTokens)","  ```python","    if this.plugin.calculateMaxTokens:","      return this.plugin.calculateMaxTokens(inputTokens)","    return super.calculateMaxTokens(inputTokens)","  ```","- buildMessage(fragment): if not this.plugin.buildMessage: raise error else return this.plugin.buildMessage(fragment)","- renderResults():","  ```python","    if this.plugin.renderResults:","      return this.plugin.renderResults()","    return super.renderResults(fragment)","  ```","- renderResult(fragment)","  ```python","    if this.plugin.renderResult:","      result, message = this.plugin.renderResult(fragment)","      this.cache.setResult(fragment.key, result, message)","      return result","    if this.plugin.iterator:","      result = {}","      def iteratorStepHandler(*args):","        message, keys = await this.plugin.buildMessage(*args)","        if not message:","          return","        itemResult = await GPTService.sendRequest(transformer, fragment.key, message)","        if this.plugin.cleanResponse:","          itemResult = this.plugin.cleanResponse(itemResult, *args)","        key = keys.join(' | ')","        this.cache.setResult(key, itemResult, message)","        result[keys[-1]] = itemResult","      this.cache.deleteResultsFor(fragment.key)","      await this.plugin.iterator(fragment, result)","      return result","    else:","      return super.renderResult(fragment)","  ```","- updateResult(fragment)","  ```python","    if this.plugin.updateResult:","      return this.plugin.updateResult(fragment)","    if this.plugin.iterator:","      result = {}","      oldResultKeys = this.cache.secondaryCache(fragment.key).filter(x => x.startsWith(fragment.key))","      def iteratorStepHandler(*args):","        message, keys = await this.plugin.buildMessage(*args)","        if not message:","          return","        key = keys.join(' | ')","        if this.cache.isOutOfDate(key):","          itemResult = await GPTService.sendRequest(transformer, fragment.key, message)","          if this.plugin.cleanResponse:","            itemResult = this.plugin.cleanResponse(itemResult, *args)","          this.cache.setResult(key, itemResult, message)","        else:","          itemResult = this.cache.getResult(key)","        result[keys[-1]] = itemResult","        oldResultKeys.remove(key)","      await this.plugin.iterator(fragment, result)","      this.cache.deleteAfterUpdate(fragment.key, oldResultKeys)","    else:","      return super.updateResult(fragment)","  ```","- hasPromptChanged(key, prompt): rebuilds the prompt that the transformer should send to the llm to calculate the result. This is used to check if the current result is out of date or not (when the prompt remains the same, the result is still valid).","  ```python","    if this.plugin.hasPromptChanged:","      return this.plugin.hasPromptChanged(fragment, prompt)","    if this.plugin.iterator:","      result = {}","      def iteratorStepHandler(*args):","        message, keys = await this.plugin.buildMessage(*args)","        newKey = keys.join(' | ')","        if newKey == key and not isChanged:","          isChanged = JSON.stringify(message) == JSON.stringify(prompt)","        else:","          itemResult = this.cache.getResult(key)","        result[keys[-1]] = itemResult","      buildStackService.mode = 'validating' # make certain that only cache values are used, no calls to the llm ","      try:","        this.plugin.iterator(fragment, result)","        return isChanged","      finally:","        buildStackService.mode = 'normal'","    else:","      return super.updateResult(fragment)","","","#### plugin-renderer service","- The plugin-renderer service is responsible for translating a plugin definition into a javascript module.","- Used to build plugin transformers that can be loaded and used by the application","- inherits from transformer-base service. Constructor parameters for transformer-base:","  - name: 'plugin renderer'","  - dependencies: ['constants']","  - isJson: false","  - isFullRender: true","- functions:","  - load: ask super to load and set the field `constantsService = this.dependencies[0]`","  - saveFile(fragment, content):","    ```python","      rootFolder = folderService.output","      if not fs.existsSync(rootFolder):","        fs.mkdirSync(rootFolder)","      location = KeyService.calculateLocation(fragment)        ","      fileName = location.replaceAll(\" > \", \"_\").replaceAll(\" \", \"_\").replaceAll(\"-\", \"_\")","      file_path = path.join(rootPath, fileName + \".js\")","      with open(file_path, \"w\") as writer:","        writer.write(content)","      return file_path","    ```","  - cleanResult(content):","    ```python","      if content:","        content = content.strip() # need to remove the newline at the end","        if content.startswith(\"```javascript\"):","          content = content[len(\"```javascript\"):]","        if content.endswith(\"```\"):","          content = content[:-len(\"```\")]","        return content","    ```","  - renderResult(fragment):","    ```python","      location = keyService.calculateLocation(fragment)","      haShared = ProjectService.textFragments.some(f => f.title === 'shared')","      message, = await this.buildMessage(fragment, location.endsWith('> shared'), hasShared)","      if not message:","        return None","      if not len(fragment.lines):","        filename = ''","      else:","        result = await GPTService.sendRequest(this, fragment.key, message)","        result = this.cleanResult(result)","        filename = this.saveFile(fragment, result)","      this.cache.setResult(fragment.key, filename, message)","      return filename","    ```","  - buildMessage(fragment, asShared, hasShared):","    - count the nr of non-empty lines in fragment.lines. When 0, return null","    - if asShared:","      - result (json array):","        - role: system, content:","","          > Act as a full-stack ai software developer.","          > It is your task to write a javascript module according to the specifications.","          > ","          > The module should export all the functions that are declared in the specification ","          > use the following development stack:","          > - developed in javascript (ES5)","          > - The UI is built using react and antd","          > ","          > Do not include an introduction or any explanation, only generate the code. Only include function that are required or the user included","","        - role: user, content:","","          > specification:","          > {{content}}","","          replace:","          - {{content}}: `await this.constantsService.getResult(fragment)`","    - if not asShared:","      - result (json array):","        - role: system, content:","","          > Act as a full-stack ai software developer.","          > It is your task to write a javascript module according to the specifications.","          > ","          > The module should export an object containing the following fields:","          > - getDescription(): (required) a function that returns a json object containing the fields:","          >   - name: (required) name of the transformer","          >   - dependencies: (required)list of names of other transformers","          >   - isJson: (required)boolean, true if the transformer produces json data.","          >   - description: (optional) a string that describes what the transformer does","          > - buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.","          > - renderResult(fragment): (optional) a function that renders the result for the specified fragment.","          > - renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.","          > - calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt","          > - iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. ","          > - cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.","          > ","          > use the following development stack:","          > - developed in javascript (ES5)","          > - The UI is built using react and antd","          > ","          > example response:","          > ","          > ```javascript","          > const resources = require('./resources.json');","          > const services = {}; // must always be present","          > const deps = {}; // must always be present","          > {{sharedImport}}","          > function getDescription() {","          >   return {name: 'test', dependencies: ['constants'], isJson: true};","          > }","          > async function buildMessage(fragment) {","          >   var result = [","          >       {","          >         role: 'system',","          >         content: resources.mark_services_transformers_compress_service_0,","          >       },","          >       {","          >         role: 'user',","          >         content: await deps.constants.getResult(fragment),","          >       },","          >     ];","          > ","          >     return [result, [ ]];","          > }","          > function calculateMaxTokens(inputTokenCount) {","          >   return inputTokenCount + 1;","          > }","          > module.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };","          > ```","          > Do not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible.","","          replace:","          - {{sharedImport}}: hasShared ? `const shared = require('./shared.js');` : ''","","        - role: user, content:","","          > {{title}}","          > {{content}}","","          replace:","          - {{title}}: `textFragment.title`","          - {{content}}: `await this.constantsService.getResult(fragment)`","    - return result, [ ]","","","#### plugin-list renderer service","- the plugin-list renderer service is responsible for generating a file containing all the plugins that need to be loaded.","- Used to let the application know which files to load from where for the transformer-plugins.","- inherits from transformer-base service. Constructor parameters for transformer-base:","  - name: 'plugin-list renderer'","  - dependencies: ['plugin renderer']","  - isJson: true","- set during construction: `this.isFullRender = true;`","- functions:","  - load: ask super to load and set the field `this.pluginRendererService = this.dependencies[0]`","  - saveFile(items): saves the array to file","    ```python","      rootFolder = folderService.output","      if not fs.existsSync(rootFolder):","        fs.mkdirSync(rootFolder)","      file_path = os.path.join(rootPath, \"plugins.json\")","      with open(file_path, \"w\") as writer:","        writer.write(content)","    ```","  - renderResults(fragments): builds the array of files, (a file for each fragment), provided by the plugin-renderer and saves it to the output folder.","    ```python","      items = []","      outPath = folderService.output","      for fragment in fragments:","        item = await this.pluginRendererService.getResult(fragment)","        if item and not item.endsWith('shared.js'):","          item = path.relative(output, item)","          items.append(item)","        this.cache.setResult(fragment.key, item, item) # set the cache so the rest of the system know this transformer is up to date for the fragment","      saveFile(items)","    ```","","#### constants-resource renderer","- The constants-resource renderer service is responsible for creating the resource file that contains all the constants that were found in the fragments.","- Used to render the resource file most of the plugins rely on.","- inherits from transformer-base service. Constructor parameters for transformer-base:","  - name: 'constants resource renderer'","  - dependencies: ['constants']","  - isJson: true","- set during construction: `this.constantsService = this.dependencies[0]; this.isFullRender = true`","- functions:","  - saveFile(items): saves the array to file","    ```python","      rootFolder = folderService.output","      if not fs.existsSync(rootFolder):","        fs.mkdirSync(rootFolder)","      file_path = os.path.join(rootPath, \"resources.json\")","      with open(file_path, \"w\") as writer:","        writer.write(content)","    ```","  - renderResults(fragments): builds the json dictionary of constants and saves it","    ```python","      items = {}","      for fragment in fragments:","        fragmentItems = {}","        constants = await this.constantsService.cache.getResult(fragment.key)","        if constants:","          for constant in constants:","            text = '\\n'.join(items.lines)","            items[constant.name] = text","            fragmentItems[constant.name] = text","        this.cache.setResult(fragment.key, fragmentItems, fragmentItems)","      await saveFile(items)","    ```","","#### parser validator service","- The parser-validator service is used to verify the internal markdown parser. It simply takes a copy of the current state of the text related to the specified text-fragment. (does not make use of any llm)","- Used to debug the application","- inherits from transformer-base service. Constructor parameters for transformer-base:","  - name: 'parser validator'","  - dependencies: []","  - isJson: false","- functions:","  ```python","    def renderResult(fragment):","      result = '\\n'.join(fragment.lines)","      this.cache.setResult(key, result, [*fragment.lines])","      return result","  ```"],"state":"still-valid"},"03c15033-710c-4035-8591-0017a7461ca9":{"result":[{"start":52,"end":62,"lines":["Act as a full-stack ai software developer.","It is your task to write a javascript module according to the specifications.","","The module should export all the functions that are declared in the specification ","use the following development stack:","- developed in javascript (ES5)","- The UI is built using react and antd","","Do not include an introduction or any explanation, only generate the code. Only include function that are required or the user included"],"name":"res_mark_services_transformers_plugin_renderer_service_1"},{"start":64,"end":67,"lines":["specification:","{{content}}"],"name":"res_mark_services_transformers_plugin_renderer_service_2"},{"start":73,"end":124,"lines":["Act as a full-stack ai software developer.","It is your task to write a javascript module according to the specifications.","","The module should export an object containing the following fields:","- getDescription(): (required) a function that returns a json object containing the fields:","  - name: (required) name of the transformer","  - dependencies: (required)list of names of other transformers","  - isJson: (required)boolean, true if the transformer produces json data.","  - description: (optional) a string that describes what the transformer does","- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.","- renderResult(fragment): (optional) a function that renders the result for the specified fragment.","- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.","- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt","- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. ","- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.","","use the following development stack:","- developed in javascript (ES5)","- The UI is built using react and antd","","example response:","","```javascript","const resources = require('./resources.json');","const services = {}; // must always be present","const deps = {}; // must always be present","{{sharedImport}}","function getDescription() {","  return {name: 'test', dependencies: ['constants'], isJson: true};","}","async function buildMessage(fragment) {","  var result = [","      {","        role: 'system',","        content: resources.mark_services_transformers_compress_service_0,","      },","      {","        role: 'user',","        content: await deps.constants.getResult(fragment),","      },","    ];","","    return [result, [ ]];","}","function calculateMaxTokens(inputTokenCount) {","  return inputTokenCount.total + 1;","}","module.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };","```","Do not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."],"name":"res_mark_services_transformers_plugin_renderer_service_3"},{"start":129,"end":132,"lines":["{{title}}","{{content}}"],"name":"res_mark_services_transformers_plugin_renderer_service_4"}],"prompt":["- The plugin-renderer service is responsible for translating a plugin definition into a javascript module.","- Used to build plugin transformers that can be loaded and used by the application","- inherits from transformer-base service. Constructor parameters for transformer-base:","  - name: 'plugin renderer'","  - dependencies: ['constants']","  - isJson: false","  - isFullRender: true","- functions:","  - load: ask super to load and set the field `constantsService = this.dependencies[0]`","  - saveFile(fragment, content):","    ```python","      rootFolder = folderService.output","      if not fs.existsSync(rootFolder):","        fs.mkdirSync(rootFolder)","      location = KeyService.calculateLocation(fragment)        ","      fileName = location.replaceAll(\" > \", \"_\").replaceAll(\" \", \"_\").replaceAll(\"-\", \"_\")","      file_path = path.join(rootPath, fileName + \".js\")","      with open(file_path, \"w\") as writer:","        writer.write(content)","      return file_path","    ```","  - cleanResult(content):","    ```python","      if content:","        content = content.strip() # need to remove the newline at the end","        if content.startswith(\"```javascript\"):","          content = content[len(\"```javascript\"):]","        if content.endswith(\"```\"):","          content = content[:-len(\"```\")]","        return content","    ```","  - renderResult(fragment):","    ```python","      location = keyService.calculateLocation(fragment)","      haShared = ProjectService.textFragments.some(f => f.title === 'shared')","      message, = await this.buildMessage(fragment, location.endsWith('> shared'), hasShared)","      if not message:","        return None","      if not len(fragment.lines):","        filename = ''","      else:","        result = await GPTService.sendRequest(this, fragment.key, message)","        result = this.cleanResult(result)","        filename = this.saveFile(fragment, result)","      this.cache.setResult(fragment.key, filename, message)","      return filename","    ```","  - buildMessage(fragment, asShared, hasShared):","    - count the nr of non-empty lines in fragment.lines. When 0, return null","    - if asShared:","      - result (json array):","        - role: system, content:","","          > Act as a full-stack ai software developer.","          > It is your task to write a javascript module according to the specifications.","          > ","          > The module should export all the functions that are declared in the specification ","          > use the following development stack:","          > - developed in javascript (ES5)","          > - The UI is built using react and antd","          > ","          > Do not include an introduction or any explanation, only generate the code. Only include function that are required or the user included","","        - role: user, content:","","          > specification:","          > {{content}}","","          replace:","          - {{content}}: `await this.constantsService.getResult(fragment)`","    - if not asShared:","      - result (json array):","        - role: system, content:","","          > Act as a full-stack ai software developer.","          > It is your task to write a javascript module according to the specifications.","          > ","          > The module should export an object containing the following fields:","          > - getDescription(): (required) a function that returns a json object containing the fields:","          >   - name: (required) name of the transformer","          >   - dependencies: (required)list of names of other transformers","          >   - isJson: (required)boolean, true if the transformer produces json data.","          >   - description: (optional) a string that describes what the transformer does","          > - buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.","          > - renderResult(fragment): (optional) a function that renders the result for the specified fragment.","          > - renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.","          > - calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt","          > - iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. ","          > - cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.","          > ","          > use the following development stack:","          > - developed in javascript (ES5)","          > - The UI is built using react and antd","          > ","          > example response:","          > ","          > ```javascript","          > const resources = require('./resources.json');","          > const services = {}; // must always be present","          > const deps = {}; // must always be present","          > {{sharedImport}}","          > function getDescription() {","          >   return {name: 'test', dependencies: ['constants'], isJson: true};","          > }","          > async function buildMessage(fragment) {","          >   var result = [","          >       {","          >         role: 'system',","          >         content: resources.mark_services_transformers_compress_service_0,","          >       },","          >       {","          >         role: 'user',","          >         content: await deps.constants.getResult(fragment),","          >       },","          >     ];","          > ","          >     return [result, [ ]];","          > }","          > function calculateMaxTokens(inputTokenCount) {","          >   return inputTokenCount.total + 1;","          > }","          > module.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };","          > ```","          > Do not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible.","","          replace:","          - {{sharedImport}}: hasShared ? `const shared = require('./shared.js');` : ''","","        - role: user, content:","","          > {{title}}","          > {{content}}","","          replace:","          - {{title}}: `textFragment.title`","          - {{content}}: `await this.constantsService.getResult(fragment)`","    - return result, [ ]","",""],"state":"still-valid"},"15110a27-64e0-45a5-b6ac-23df16688604":{"result":[],"prompt":["- The constants-resource renderer service is responsible for creating the resource file that contains all the constants that were found in the fragments.","- Used to render the resource file most of the plugins rely on.","- inherits from transformer-base service. Constructor parameters for transformer-base:","  - name: 'constants resource renderer'","  - dependencies: ['constants']","  - isJson: true","- set during construction: `this.constantsService = this.dependencies[0]; this.isFullRender = true`","- functions:","  - saveFile(items): saves the array to file","    ```python","      rootFolder = folderService.output","      if not fs.existsSync(rootFolder):","        fs.mkdirSync(rootFolder)","      file_path = os.path.join(rootPath, \"resources.json\")","      with open(file_path, \"w\") as writer:","        writer.write(content)","    ```","  - renderResults(fragments): builds the json dictionary of constants and saves it","    ```python","      items = {}","      for fragment in fragments:","        fragmentItems = {}","        constants = await this.constantsService.cache.getResult(fragment.key)","        if constants:","          for constant in constants:","            text = '\\n'.join(items.lines)","            items[constant.name] = text","            fragmentItems[constant.name] = text","        this.cache.setResult(fragment.key, fragmentItems, fragmentItems)","      await saveFile(items)","    ```",""],"state":"still-valid"},"9b56f8e2-0e81-4cce-9555-4f163eda2294":{"result":[],"prompt":["- the plugin-list renderer service is responsible for generating a file containing all the plugins that need to be loaded.","- Used to let the application know which files to load from where for the transformer-plugins.","- inherits from transformer-base service. Constructor parameters for transformer-base:","  - name: 'plugin-list renderer'","  - dependencies: ['plugin renderer']","  - isJson: true","- set during construction: `this.isFullRender = true;`","- functions:","  - load: ask super to load and set the field `this.pluginRendererService = this.dependencies[0]`","  - saveFile(items): saves the array to file","    ```python","      rootFolder = folderService.output","      if not fs.existsSync(rootFolder):","        fs.mkdirSync(rootFolder)","      file_path = os.path.join(rootPath, \"plugins.json\")","      with open(file_path, \"w\") as writer:","        writer.write(content)","    ```","  - renderResults(fragments): builds the array of files, (a file for each fragment), provided by the plugin-renderer and saves it to the output folder.","    ```python","      items = []","      outPath = folderService.output","      for fragment in fragments:","        item = await this.pluginRendererService.getResult(fragment)","        if item and not item.endsWith('shared.js'):","          item = path.relative(output, item)","          items.append(item)","        this.cache.setResult(fragment.key, item, item) # set the cache so the rest of the system know this transformer is up to date for the fragment","      saveFile(items)","    ```",""],"state":"still-valid"},"99052aeb-ef71-4cdb-ba64-1036a33417cc":{"result":[],"prompt":["- The parser-validator service is used to verify the internal markdown parser. It simply takes a copy of the current state of the text related to the specified text-fragment. (does not make use of any llm)","- Used to debug the application","- inherits from transformer-base service. Constructor parameters for transformer-base:","  - name: 'parser validator'","  - dependencies: []","  - isJson: false","- functions:","  ```python","    def renderResult(fragment):","      result = '\\n'.join(fragment.lines)","      this.cache.setResult(key, result, [*fragment.lines])","      return result","  ```"],"state":"still-valid"}},"secondaryCache":{"be67508d-8316-462a-b24e-4df2b34def0f":["be67508d-8316-462a-b24e-4df2b34def0f"],"7bff2308-d88b-408e-8082-7f7034afa59e":["7bff2308-d88b-408e-8082-7f7034afa59e"],"58516b7b-3add-4daf-9f27-46e0ba1066ab":["58516b7b-3add-4daf-9f27-46e0ba1066ab"],"80a81923-8079-4820-b50c-5cd3df1b12e1":["80a81923-8079-4820-b50c-5cd3df1b12e1"],"af17bd18-7341-4623-af40-b35190024b95":["af17bd18-7341-4623-af40-b35190024b95"],"8308b963-e815-48b2-a8a7-ce85d1353533":["8308b963-e815-48b2-a8a7-ce85d1353533"],"907586bd-b127-4fc8-925d-7374bc0a39b3":["907586bd-b127-4fc8-925d-7374bc0a39b3"],"f740a1e5-7a90-47b9-a4b1-654a97531cf1":["f740a1e5-7a90-47b9-a4b1-654a97531cf1"],"41dc0b70-7750-46ef-a8ea-fd48d5c99b94":["41dc0b70-7750-46ef-a8ea-fd48d5c99b94"],"a544fcfc-0cbb-4b88-b2c1-5dcd7db0816b":["a544fcfc-0cbb-4b88-b2c1-5dcd7db0816b"],"5f312819-504f-4fae-ab3d-c823668d659b":["5f312819-504f-4fae-ab3d-c823668d659b"],"6a3b7dc2-86c4-41e9-b132-9ed0a00a8dde":["6a3b7dc2-86c4-41e9-b132-9ed0a00a8dde"],"d1d83d0c-fde7-47a6-af75-696b0181f037":["d1d83d0c-fde7-47a6-af75-696b0181f037"],"65b637c7-f0ca-4672-aa83-8306b386db2b":["65b637c7-f0ca-4672-aa83-8306b386db2b"],"489a33cf-f216-48c2-9d18-987c3bc46280":["489a33cf-f216-48c2-9d18-987c3bc46280"],"048ce355-2a85-45c2-9d30-70eae30e832b":["048ce355-2a85-45c2-9d30-70eae30e832b"],"366c660c-4aa7-4160-9e22-e6ef4469c411":["366c660c-4aa7-4160-9e22-e6ef4469c411"],"982c423f-5854-4c77-af54-9ae223a79db9":["982c423f-5854-4c77-af54-9ae223a79db9"],"c25f5105-2ce2-4322-9637-09c2d74ac80a":["c25f5105-2ce2-4322-9637-09c2d74ac80a"],"f7a265c4-53b4-4c62-af43-adf2695e4272":["f7a265c4-53b4-4c62-af43-adf2695e4272"],"b49f427c-4dfe-4510-8e8b-ba3befef77e0":["b49f427c-4dfe-4510-8e8b-ba3befef77e0"],"60d16ad6-73cf-4bde-845c-000dff979205":["60d16ad6-73cf-4bde-845c-000dff979205"],"c9ce52a1-c141-47ec-a32c-f087b6174c3e":["c9ce52a1-c141-47ec-a32c-f087b6174c3e"],"dba35a53-38b0-41e8-b276-d62e24872944":["dba35a53-38b0-41e8-b276-d62e24872944"],"c25bd76e-af9b-4020-abe0-1ba023c9df76":["c25bd76e-af9b-4020-abe0-1ba023c9df76"],"912f3e5b-8b82-47e9-af50-50e97a5e03b1":["912f3e5b-8b82-47e9-af50-50e97a5e03b1"],"d809ef28-5a75-4f2a-8e28-9f895aa87bae":["d809ef28-5a75-4f2a-8e28-9f895aa87bae"],"581dcdbb-6401-4025-b898-606326a92aae":["581dcdbb-6401-4025-b898-606326a92aae"],"5a4c3d1a-0e09-424b-8fd0-6de342e56291":["5a4c3d1a-0e09-424b-8fd0-6de342e56291"],"866c4850-179f-4ba5-9e56-ec37fdd1fe97":["866c4850-179f-4ba5-9e56-ec37fdd1fe97"],"9c672829-a31d-47cb-9d66-e676423a06da":["9c672829-a31d-47cb-9d66-e676423a06da"],"fc366a69-db91-4f35-b538-182295436d18":["fc366a69-db91-4f35-b538-182295436d18"],"6e52cca8-7baf-4c4f-97c5-effbf603eb14":["6e52cca8-7baf-4c4f-97c5-effbf603eb14"],"7946446e-33e7-4bd5-a7b6-3d001271627c":["7946446e-33e7-4bd5-a7b6-3d001271627c"],"fd347c00-e1ea-4961-8544-3048650deb2b":["fd347c00-e1ea-4961-8544-3048650deb2b"],"3cd6abe1-d84e-41c4-a421-07a63d196280":["3cd6abe1-d84e-41c4-a421-07a63d196280"],"8c9e5644-55a8-44c2-ac7b-6fdea2680697":["8c9e5644-55a8-44c2-ac7b-6fdea2680697"],"7ed49936-ac3f-4a7c-a70d-8ccd51b1c327":["7ed49936-ac3f-4a7c-a70d-8ccd51b1c327"],"d0b23425-dc3b-46f2-92c5-451b2b648400":["d0b23425-dc3b-46f2-92c5-451b2b648400"],"958692be-22c0-452b-90ac-6c36a431fafd":["958692be-22c0-452b-90ac-6c36a431fafd"],"31da607d-07e2-4c54-9b1c-9a11a786c58f":["31da607d-07e2-4c54-9b1c-9a11a786c58f"],"3fdc58f1-93e1-4eb2-8e18-9be3282323a1":["3fdc58f1-93e1-4eb2-8e18-9be3282323a1"],"45fd1335-5429-47ea-a577-c11db18a28a0":["45fd1335-5429-47ea-a577-c11db18a28a0"],"68dbb9c3-e1a8-4287-b68a-db5070e55505":["68dbb9c3-e1a8-4287-b68a-db5070e55505"],"0136ea45-e1de-4444-b833-2d8cfd2cc956":["0136ea45-e1de-4444-b833-2d8cfd2cc956"],"96aad863-3686-497b-8638-99081b0c947e":["96aad863-3686-497b-8638-99081b0c947e"],"33a93cd2-11ee-4ec2-9263-101b212474ab":["33a93cd2-11ee-4ec2-9263-101b212474ab"],"1056ce6a-ac4b-410e-91d3-f8117a6084b0":["1056ce6a-ac4b-410e-91d3-f8117a6084b0"],"849a7ae4-6a95-43dd-9c90-6ef41dc86a80":["849a7ae4-6a95-43dd-9c90-6ef41dc86a80"],"ccbe1be3-fea6-4080-bce3-e13de89e4e42":["ccbe1be3-fea6-4080-bce3-e13de89e4e42"],"421a1524-3e5c-431e-8444-470cae1d6cbb":["421a1524-3e5c-431e-8444-470cae1d6cbb"],"8593a8f2-cefd-4ae4-b7e3-57bec9014a87":["8593a8f2-cefd-4ae4-b7e3-57bec9014a87"],"32ab0827-4dc7-4078-bd8a-88ea9064239d":["32ab0827-4dc7-4078-bd8a-88ea9064239d"],"8ac6d3c7-0806-4d9f-a790-88bbb45f9106":["8ac6d3c7-0806-4d9f-a790-88bbb45f9106"],"03c15033-710c-4035-8591-0017a7461ca9":["03c15033-710c-4035-8591-0017a7461ca9"],"15110a27-64e0-45a5-b6ac-23df16688604":["15110a27-64e0-45a5-b6ac-23df16688604"],"9b56f8e2-0e81-4cce-9555-4f163eda2294":["9b56f8e2-0e81-4cce-9555-4f163eda2294"],"99052aeb-ef71-4cdb-ba64-1036a33417cc":["99052aeb-ef71-4cdb-ba64-1036a33417cc"]},"overwrites":{},"lastSaveDate":"2024-01-06T13:59:07.376Z"}