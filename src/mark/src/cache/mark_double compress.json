{"cache":{"af17bd18-7341-4623-af40-b35190024b95":{"result":"The log-window component displays log messages in the secondary window. It registers an event handler to receive messages when loaded and removes it when unloaded. The main window has a configProvider component for applying themes to antd components. The root div allows scrolling when content is larger than the visible area. The handleLogMsg function checks if the root div is scrolled to the end, converts the parameter to JSON, and performs actions based on its content. The log window renderer displays fields like location, transformerName, inputData, and response. Text is styled with \"white-space: pre-wrap\" for correct rendering of new lines.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The log-window component is used in the secondary window of the application to display log messages generated by the application. When the component is loaded, the event handler \"handleLogMsg\" is registered to receive messages. When the component is unloaded, the event handler is removed. The main window consists of a configProvider component that applies the theme to antd components. The root div of the main window allows scrolling when the content is larger than the visible area. The handleLogMsg function checks if the root div is scrolled to the end, converts the parameter to a JSON object, and performs different actions based on the content of the JSON object. The log window renderer displays various fields of each log message entry, including location, transformerName, inputData, and response. All text is displayed with the styling \"white-space: pre-wrap\" to render new lines correctly."}],"state":"still-valid"},"8308b963-e815-48b2-a8a7-ce85d1353533":{"result":"The application has a toolbar similar to popular applications like MS Access, Excel, Word, or Draw. It consists of a single integrated menu and toolbar with tabs at the top. Each tab displays a tooltip with a brief description. The tabs are created using a JSON structure with fields like key, label, and children. The available tabs are home, transformers, format, and preferences.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The application has a toolbar similar to popular applications like MS Access, Excel, Word, or Draw. It consists of a single integrated menu and toolbar.\n\nThe toolbar has tabs at the top, which are taken from the antd library. Each component on the toolbar displays a tooltip from the antd library, providing a brief description of the action.\n\nTo create the tabs, a JSON structure is used with fields like key, label, and children. This structure is rebuilt at every render to recreate the tabs and apply any theme changes.\n\nThe JSON structure is assigned to the items property.\n\nThe available tabs are: home (shown as the first tab when the application starts), transformers, format, and preferences."}],"state":"still-valid"},"907586bd-b127-4fc8-925d-7374bc0a39b3":{"result":"The home-tab component arranges its children horizontally and includes file, edit, and undo sections.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The home-tab component is a container that arranges its children horizontally. It includes the file, edit, and undo sections."}],"state":"still-valid"},"f740a1e5-7a90-47b9-a4b1-654a97531cf1":{"result":"The file-section component has actions for project and file management. Buttons have icons instead of text. It supports new project creation, opening existing projects, saving projects, saving projects to a new location, and toggling auto-save. The project service is monitored for changes. The component calls trySave() to save the project if needed and cancel the action. It also calls tryCanClose() to handle closing events.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The file-section component contains actions for project and file management. All buttons have icons instead of text. It supports the following actions:\n\n- New Project: Creates a new project. If the action is canceled, a new project is not created. This button is disabled in plugin mode and has the icon FileOutlined.\n\n- Open: Opens an existing project. This button is disabled in plugin mode. If the action is canceled, a new project is not created. If a file is selected from the dialog box, the storage service opens the file. An error dialog is shown if there is an exception.\n\n- Save: Saves the current project to a file. This button is enabled when the project service has a filename and the project is dirty. If the project file does not have a filename, a save-as dialog is shown. If the user provides a valid filename, the storage service saves the project. If the project already has a filename, the storage service saves the project without a parameter. An error dialog is shown if there is an exception.\n\n- Save As: Saves the current project to a new location. A save-as dialog is shown. If a file is selected from the dialog, the storage service saves the project to the new location. An error dialog is shown if there is an exception.\n\n- Auto-Save: A toggle button that updates the auto-save state of the project service when pressed. The state of the toggle button follows the auto-save state of the project service.\n\nThe project service is monitored for changes to update the state of the buttons. The component calls `window.electron.onCanClose(this.tryCanClose)` when mounted to save the project if needed and cancel the action. It calls `window.electron.removeOnCanClose(this.tryCanClose)` when unmounted to remove the event handler.\n\nThe following functions are defined:\n\n- trySave(): Checks if the project is dirty and asks the user to save changes. If the user cancels, it returns false. If the user confirms, it saves the project and returns true.\n\n- tryCanClose(): Calls trySave() and processes the result using `window.electron.canCloseProcessed()`."}],"state":"still-valid"},"41dc0b70-7750-46ef-a8ea-fd48d5c99b94":{"result":"The edit-section component has actions for clipboard and selected data. Buttons use icons from '@ant-design/icons'. Supported actions are cut, copy, paste, delete, select all, and clear selection. The paste action uses BiPaste icon from react-icons and calls `clipboard.readText()` to get data. To check if clipboard has text data, use electron's clipboard and check for 'text/plain' format. On load, subscribe `handleSelectionChanged` callback to selection service and update button state.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The edit-section component includes actions for clipboard and selected data. All buttons use icons from the '@ant-design/icons' library. It supports the following actions: cut, copy, paste, delete, select all, and clear selection. The paste action uses the BiPaste icon from react-icons and calls `clipboard.readText()` to get the data. To check if the clipboard contains text data, use the clipboard from electron and check if 'text/plain' is included in the available formats. When loaded, subscribe the `handleSelectionChanged` callback to the selection service and update the button state."}],"state":"still-valid"},"a544fcfc-0cbb-4b88-b2c1-5dcd7db0816b":{"result":"The undo-section component has icons for undo/redo actions. It supports undo and redo buttons that call the corresponding functions in the undo-service. The buttons are enabled based on the availability of undo and redo actions in the undo-service. The button states are updated by monitoring changes in the undo-service.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"- The undo-section component contains actions for the undo/redo service.\n- All buttons have icons instead of text.\n- The service supports the following actions:\n  - Undo: a button to revert the last action.\n    - Enabled when there are undo actions in the undo-service.\n    - Calls the undo function of the undo-service.\n  - Redo: a button to redo the last action performed by the project's undo service.\n    - Enabled when there are redo actions in the undo-service.\n    - Calls the redo function of the undo-service.\n- The undo service needs to be monitored for changes to update the button states."}],"state":"still-valid"},"5f312819-504f-4fae-ab3d-c823668d659b":{"result":"The transformers-tab component arranges children horizontally and includes configuration and build sections as child components.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The transformers-tab component is a wrapper that arranges its children horizontally. It includes the configuration and build sections as child components."}],"state":"still-valid"},"6a3b7dc2-86c4-41e9-b132-9ed0a00a8dde":{"result":"The transformers-configuration section contains actions for available transformers. Buttons have tooltips with action descriptions. Actions include:\n- Edit transformers: Opens Mark editor in plugin-mode, using specified project path. Disabled when `window.electron.isPluginMode == true`. Icon: MdRebaseEdit. Action includes opening plugin editor and refreshing plugins.\n- Active entry point: Dropdown list with names of transformers from `cybertronService.entryPoints`. Selected item based on `cyberTronService.activeEntryPoint`. Field updated when selection changes.\n- Monitors events from all-spark service (field: eventTarget, event: transformers-loaded). Rebuilds list of entry points when event occurs.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The transformers-configuration section contains actions related to the available transformers in the application. All buttons have tooltips with action descriptions. The section includes the following actions:\n- Edit transformers: Opens a new window of the Mark editor in plugin-mode, using the project at the specified path. This button is disabled when `window.electron.isPluginMode == true`. It has an icon of MdRebaseEdit. The action includes opening the plugin editor and refreshing the plugins.\n- Active entry point: A dropdown list populated with the names of transformers found in `cybertronService.entryPoints`. The selected item in the dropdown list is based on `cyberTronService.activeEntryPoint`. Whenever the selection changes, this field is updated.\n- Monitors events from the all-spark service (field: eventTarget, event: transformers-loaded). When this event occurs, the list of entry points is rebuilt."}],"state":"still-valid"},"d1d83d0c-fde7-47a6-af75-696b0181f037":{"result":"The build-section component has actions for the build-service. Buttons have icons and tooltips with descriptions. Actions include starting rendering for the project or active fragment, toggling visibility of log window and debugger, toggling debug state, continuing rendering to next transformer, and stopping the run. Button disabled state is stored and updated by event handlers for project-service, position-tracking service, build-service, and log-service. Event handlers are registered and unregistered when component is loaded and unloaded.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The build-section component contains actions that the build-service can perform. Buttons use icons instead of text and are wrapped in tooltips with detailed descriptions. The component includes the following actions: starting rendering for the entire project, starting rendering for the active fragment and transformer, toggling the log window visibility, toggling the debugger visibility, toggling the debug state, continuing rendering to the next transformer, and stopping the run. The disabled state of the buttons is stored in the state and updated by event handlers for changes in the project-service, position-tracking service, build-service, and log-service. Event handlers are registered and unregistered when the component is loaded and unloaded."}],"state":"still-valid"},"65b637c7-f0ca-4672-aa83-8306b386db2b":{"result":"The format-tab component arranges children horizontally, including style, paragraph, and font sections.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The format-tab component is a container that arranges its children horizontally. It includes the style, paragraph, and font sections as child components."}],"state":"still-valid"},"489a33cf-f216-48c2-9d18-987c3bc46280":{"result":"The style-section component formats text with markdown actions. Buttons represent styles like headings, paragraphs, quotes, code, bullet lists, and numbered lists. Pressing a button formats selected text. Only one button can be selected at a time. Buttons are in a single row. The selection-service updates toggle buttons based on selected text changes and retrieves the style. Buttons have icons.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The style-section component handles markdown formatting actions for text. Each button represents a formatting style, such as headings, paragraphs, quotes, code, bullet lists, and numbered lists. When a button is pressed, the selected text is formatted accordingly. Only one button can be selected at a time. The buttons are displayed in a single row. The selection-service monitors changes in the selected text and updates the toggle buttons accordingly. The selection-service also provides a method to retrieve the style of the selected text. Each button has an appropriate icon."}],"state":"still-valid"},"048ce355-2a85-45c2-9d30-70eae30e832b":{"result":"The paragraph-section component has markdown formatting actions with icon buttons wrapped in tooltips. It supports indent (MdFormatIndentDecrease icon) and unindent (MdOutlineFormatIndentDecrease icon).","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The paragraph-section component has actions for applying markdown formatting to the text. The buttons have icons instead of text and are wrapped in tooltips that provide detailed descriptions of the actions. It supports the following actions: indent (using the MdFormatIndentDecrease icon) and unindent (using the MdOutlineFormatIndentDecrease icon)."}],"state":"still-valid"},"366c660c-4aa7-4160-9e22-e6ef4469c411":{"result":"The font-section component applies markdown formatting to text using buttons with icons and tooltips. Toggle buttons update based on selected text and cursor position. Supported actions include bold, italic, underline, and strike-through, using `selectionService` functions.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The font-section component handles actions for applying markdown formatting to text. Buttons use icons instead of text and are wrapped in tooltips with detailed descriptions. The toggle buttons update their state based on the selected text and cursor position. The supported actions include bold, italic, underline, and strike-through. All actions use the `selectionService` functions to apply the selection and update button states."}],"state":"still-valid"},"982c423f-5854-4c77-af54-9ae223a79db9":{"result":"The preferences-tab component arranges its children horizontally and includes the GPT and View components.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The preferences-tab component is a container that arranges its children horizontally. It includes the GPT and View components."}],"state":"still-valid"},"c25f5105-2ce2-4322-9637-09c2d74ac80a":{"result":"- GPT-section handles GPT service configuration actions.\n- Buttons have icons instead of text.\n- GPT-section tracks the open state of the 'open-ai configuration dialog'.\n- It supports the following actions:\n  - Key button opens the 'open-ai configuration dialog' with a key icon.\n  - ModelComboBox component allows selecting default model for open-ai requests.\n    - Available models obtained from gpt-service.\n    - Initial value retrieved from gpt-service using getDefaultModel function.\n    - Value changes saved to gpt-service using setDefaultModel function.\n    - openApiKey prop update refreshes available models.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"- The GPT-section component handles actions related to configuring the GPT service.\n- All buttons have icons instead of text.\n- The GPT-section component keeps track of the open state of the 'open-ai configuration dialog'.\n- It supports the following actions:\n  - Key: This button opens the 'open-ai configuration dialog' and uses a key icon.\n  - Model: The ModelComboBox component (Select in antd) allows the user to select the default model for requests sent to open-ai.\n    - The list of available models for the combobox is obtained from the gpt-service.\n    - The initial value for the combobox is retrieved from the gpt-service using the getDefaultModel function.\n    - When the value is changed, it is saved to the gpt-service using the setDefaultModel function.\n    - Whenever the openApiKey prop is updated, the list of available models is refreshed."}],"state":"still-valid"},"f7a265c4-53b4-4c62-af43-adf2695e4272":{"result":"The open-ai configuration dialog is used to edit settings. It has a title, description, and an input box for the api-key. The current api-key is retrieved and displayed. There are \"cancel\" and \"ok\" buttons to close the dialog without saving or after saving the new api-key.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The open-ai configuration dialog is a modal dialog used to edit the open-ai configuration settings. It includes a title with a short description at the top. The dialog also has an input box for the user to enter their api-key, which is used for api-calls with the open-ai platform. When the dialog opens, the current api-key value is retrieved from the gpt-service and displayed in the input box. At the bottom of the dialog, there are two buttons: \"cancel\" to close the dialog without saving, and \"ok\" to close the dialog after saving the new api-key value to the gpt-service."}],"state":"still-valid"},"b49f427c-4dfe-4510-8e8b-ba3befef77e0":{"result":"The view-section component configures the app's appearance. Buttons have icons, not text. It supports theme, font, and font-size actions. Theme allows light/dark mode, managed by theme-service. Font allows font selection for markdown text, managed by theme-service. Supported fonts include Consolas, Helvetica, Arial, and more. Font-size ranges from 6px to 50px, managed by theme-service.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The view-section component handles actions for configuring the appearance of the application. All buttons have icons instead of text. It supports the following actions: \n- Theme: Allows the user to choose between light and dark mode. The selected theme is managed by the theme-service.\n- Font: Allows the user to select the font for the markdown text. The selected font is managed by the theme-service. Supported fonts include Consolas, Helvetica, Arial, and more.\n- Font-size: Allows the user to choose the size of the font for the markdown text. The selected size is managed by the theme-service and ranges from 6px to 50px."}],"state":"still-valid"},"60d16ad6-73cf-4bde-845c-000dff979205":{"result":"The application's main body is represented by the body component, which uses the Split component from the @geoffcox/react-splitter library. The body component is filled with the Split component, with the primary split initially sized based on the verticalSplitSize state value. The primary split has a minimum size of '50px' and the secondary split has a minimum size of '15%'. The splitter colors are determined by the theme. The body component includes an outline component and another Split component as children. The primary split in the second Split component is initially sized based on the horizontalSplitSize state value, with the same minimum sizes as before. The second Split component is horizontal and has an editor component and a results view component as children. The body component has event handlers for the 'onSplitChanged' callback of both splits, which store the new position value in the state. The last positions of the horizontal and vertical splitters are stored in local storage when the body component is unloaded and restored when it is loaded. If no value is found, the default value of '30%' is used.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The main body of the application is represented by the body component. It uses the Split component from the @geoffcox/react-splitter library. The entire area of the body component is filled with the Split component. The initial size of the primary split is set to the value of verticalSplitSize in the state. The minimum size of the primary split is set to '50px' and the minimum size of the secondary split is set to '15%'. The colors of the splitter are determined based on the theme. The children of the body component include an outline component and another Split component. The initial size of the primary split in the second Split component is set to the value of horizontalSplitSize in the state. The minimum size of the primary split is set to '50px' and the minimum size of the secondary split is set to '15%'. The second Split component is horizontal and its children include an editor component and a results view component. The body component has event handlers for the 'onSplitChanged' callback of both the horizontal and vertical splits, which store the new position value in the state. When the body component is unloaded, the last positions of the horizontal and vertical splitters are stored in the local storage. When the body component is loaded, the last positions of the horizontal and vertical splitters are restored from the local storage. If no value is found, the default value of '30%' is used."}],"state":"still-valid"},"c9ce52a1-c141-47ec-a32c-f087b6174c3e":{"result":"The editor uses Monaco Editor to display markdown text. It retrieves text from the project service and applies theme, font, and font-size from the theme service. When the 'content-changed' event is triggered, the editor reloads the text and prevents parsing. The position-tracking service moves the editor to the top line. The component subscribes to theme service changes and unsubscribes when unloaded. It monitors model content, focus, cursor position, and selection changes. The Monaco editor occupies all available space and has options like automatic layout, line number selection, rounded selection, and read-only mode.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The editor component uses the Monaco Editor npm package to display markdown text. When the editor is loaded, it retrieves the text from the project service and applies the theme, font, and font-size from the theme service. When the project service triggers the 'content-changed' event, the editor reloads the text and sets a flag to prevent parsing the text after loading. The position-tracking service raises the 'moveTo' event, and the editor reveals the line near the top. The component subscribes to the theme service for changes and unsubscribes when unloaded. It also monitors events on the Monaco editor, such as model content changes, focus changes, cursor position changes, and cursor selection changes. The Monaco editor always occupies all available space and includes specific options like automatic layout, selecting on line numbers, rounded selection, and read-only mode."}],"state":"still-valid"},"dba35a53-38b0-41e8-b276-d62e24872944":{"result":"The outline component on the left side of the editor displays a tree structure of headings in the markdown document. It retrieves project data from the project service and converts it into a tree structure using the 'convertToTreeData' function. It updates the tree structure when items are added, removed, or changed, and also monitors changes to the selected text-fragment. The tree is displayed with lines and when a tree item is clicked, the corresponding text-fragment is selected and the tree is updated. The 'convertToTreeData' function creates the tree structure from the project data.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"- The outline component is on the left side of the editor.\n- It displays a tree structure representing the headings in the active project's markdown document.\n- When the component is loaded or when a new project is loaded, the project data is retrieved from the project service and converted into a tree structure using the 'convertToTreeData' function.\n- The component listens for events from the project service to update the tree structure when items are added, removed, or changed.\n- The component also monitors the position-tracking service for changes to the selected text-fragment.\n- The tree is displayed with lines.\n- When a tree item is clicked, the corresponding text-fragment is selected and the tree is updated accordingly.\n- The 'convertToTreeData' function creates a tree structure from the project data."}],"state":"still-valid"},"c25bd76e-af9b-4020-abe0-1ba023c9df76":{"result":"The fragment-status icon component displays the status of a text-fragment object. It requires the fragment property, which is a reference to the text-fragment object. The icon displayed depends on the fragment's depth value. If the fragment is being built, a spin component is shown instead of an icon. The component uses LuHeading icons from the 'react-icons/lu' library and shows a tooltip with the status information. The icon's color is determined by the fragment's status: green for up-to-date, orange for partially out-of-date, and red for fully out-of-date. The component registers event handlers with the project-service and build-service to handle relevant events. The tooltip, depth, and color are loaded from the prop.fragment when the component is loaded.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The fragment-status icon component displays the status of a text-fragment object. It requires the following properties: fragment (a reference to the text-fragment object). The icon displayed depends on the fragment's depth value. If the fragment is being built, a spin component is shown instead of an icon. The component uses the LuHeading icons from the 'react-icons/lu' library. It also shows a tooltip with the status information. The color of the icon is determined by the fragment's status: green for up-to-date, orange for partially out-of-date, and red for fully out-of-date. The component registers event handlers with the project-service and build-service to handle relevant events. The tooltip, depth, and color are loaded from the prop.fragment when the component is loaded."}],"state":"still-valid"},"912f3e5b-8b82-47e9-af50-50e97a5e03b1":{"result":"The results-view component is at the bottom of the main body, showing results from registered transformers for the selected text block. Tabs at the bottom have a small size and marginTop: 0 style. Each transformer in the list has a tab with its name as the title and key. A transformer-status-icon component is placed before the name. The tab content displays a results-view-tab component. When a tab is selected, the positionTrackingService.setActiveTransformer(transformer) function is called. The first item in the list is selected as the active tab on initialization. A JSON structure is created for all tabs with key, label, and children fields. The structure is assigned to the items property. The application monitors the transformers-loaded event from the all-spark service to rebuild the list of entry points.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"- The results-view component is located at the bottom of the main body.\n- Users can see the results generated by registered transformers for the currently selected text block.\n- Tabs are placed at the bottom of the results view, with a small size and a tabBarStyle of marginTop: 0.\n- For each transformer in the provided transformers list, a tab is created with the transformer name as the title and key.\n- A transformer-status-icon component is placed before the transformer name, with the transformer property set.\n- The tab content displays a results-view-tab component.\n- When a tab is selected, the positionTrackingService.setActiveTransformer(transformer) function is called.\n- Upon initialization, if the list is not empty, the first item in the list is selected as the active tab and the positionTrackingService.setActiveTransformer(transformer) function is called for the correct transformer.\n- A JSON structure is created for all the tabs, including fields for key, label, and children.\n- The JSON structure is assigned to the items property.\n- The application monitors for events dispatched from the all-spark service, specifically the transformers-loaded event. When this event occurs, the list of entry points is rebuilt."}],"state":"still-valid"},"d809ef28-5a75-4f2a-8e28-9f895aa87bae":{"result":"The transformer-status icon component shows the status of the selected text-fragment object in relation to the assigned transformer. It requires the transformer property. Event handlers are registered with position-tracking-service, project-service, and build-service to refresh the status. The component has states: building, paused, overwritten, rendered, and not yet rendered, each with specific conditions and icons. It includes a tooltip displaying the status, including if the fragment is out-of-date.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The transformer-status icon component displays the status of the selected text-fragment object in relation to the assigned transformer. It requires the following properties: transformer (reference to the transformer object). \n\nUpon construction, event handlers are registered with the position-tracking-service, project-service, and build-service to handle specific events. These event handlers refresh the status of the component. \n\nThe component has different states to show: building, paused, overwritten, rendered, and not yet rendered. Each state is associated with specific conditions and icons. \n\nThe component also includes a tooltip that displays the status, including if the fragment is out-of-date."}],"state":"still-valid"},"581dcdbb-6401-4025-b898-606326a92aae":{"result":"The results-view-tab component displays transformer results for a text fragment using the monaco editor npm package. It retrieves text from the result-cache and applies theme settings from the theme-service. User changes are saved to the result-cache. The component also subscribes to theme changes and monitors editor events. A results-view-context-menu component is placed below the editor. It updates the key value and retrieves data from the result-cache. It registers an event handler on the transformer's cache and includes options for the editor.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The results-view-tab component displays the results of a transformer for a specific text fragment. It uses the monaco editor npm package to display the results in markdown, json data, javascript, html, or css format. The monaco editor fills the available width and height of the component. When the results-view-tab is loaded, it retrieves the text for the monaco editor from the result-cache of the assigned transformer using the assigned key. The theme, font, and font-size are retrieved from the theme-service and applied to the monaco editor. The component monitors changes in the result-cache for the current key and displays the text accordingly. When the user changes the text in the monaco editor, it is saved to the result-cache as overwritten. The component also subscribes to the theme-service for theme changes and updates the editor options accordingly. It monitors events on the monaco editor for further functionality. A results-view-context-menu component is placed below the monaco editor. The component also monitors events triggered by the position-tracking service and the project-service for changes to the selected text-fragment and project. It updates the key value and retrieves the data from the result-cache. When the component is loaded or when the transformer property changes, it registers an event handler on the transformer's cache. It includes certain options for the monaco editor."}],"state":"still-valid"},"5a4c3d1a-0e09-424b-8fd0-6de342e56291":{"result":"The results-view-context-menu is a component that wraps the Dropdown antd component. It requires the 'transformer' and 'key' properties. The dropdown contains a 'more' button icon and is triggered by a click. The 'more' button is positioned in the top-right corner. The menu includes options for selecting the GPT model for the transformer. The available models are provided by the gpt-service. The currently selected model is shown as selected. When a different model is selected, the gpt-service updates the model-name used by the transformer. The menu also includes a splitter, refresh option, and event handler for the 'content-changed' event.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The results-view-context-menu is a component that wraps the Dropdown antd component. It requires the 'transformer' and 'key' properties to be provided. The dropdown contains a 'more' button icon and is triggered by a click. The 'more' button is positioned as a floating button in the top-right corner of the parent. The menu includes options for selecting the GPT model to be used by the transformer, both for all and for a specific fragment. The available models are provided by the gpt-service. The currently selected model is shown as selected. When a different model is selected, the gpt-service is asked to update the model-name used by the transformer. The menu also includes a splitter, a refresh option, and an event handler that registers with the project-service to handle the 'content-changed' event."}],"state":"still-valid"},"6e52cca8-7baf-4c4f-97c5-effbf603eb14":{"result":"The project service manages text fragments globally. It stores parsed and raw content, tracks the loaded project's filename, and has an \"isDirty\" property that triggers an event when it changes. Functions include deleting, adding, marking fragments, and retrieving by key. It checks for outdated fragments using an EventTarget field. User configurations like auto-save settings are stored in local storage. Events are raised for project loading/creation, fragment deletion/insertion, marking as out of date/being built/up to date, external title changes, and dirty status changes.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The project service is a global singleton that manages a list of text fragments. It stores both the parsed text and the raw content displayed to the user. It also keeps track of the filename of the currently loaded project. The service has a property called \"isDirty\" that raises an event when its value changes. \n\nThe service provides several functions to work with the text fragments. These functions include deleting a fragment, adding a fragment at a specific position, marking a fragment as out of date, marking a fragment as up to date after a transformer has updated it, marking a fragment as being built by a transformer, and retrieving a fragment by its key. \n\nThe service also has the ability to check if any of the fragments are marked as out of date. It uses an EventTarget field to dispatch events, allowing other objects to listen for and handle these events. \n\nAdditionally, the service keeps track of user configurations such as auto-save settings, which are stored in local storage. \n\nThe service raises various events including when the project is loaded or created, when a fragment is deleted or inserted, when a fragment is marked as out of date or being built, when a fragment is marked as up to date, when the title of a fragment is changed externally, and when the project's dirty status changes."}],"state":"still-valid"},"fd347c00-e1ea-4961-8544-3048650deb2b":{"result":"The storage service is a global singleton that handles project data storage. It sets up a callback to mark the project as dirty when the gpt-service's modelsMap changes. Functions include clear(), new(), open(filePath), loadModelsMap(filePath), loadKeys(filePath), loadProjectConfig(filePath), updateOutOfDate(), markDirty(), save(file), saveModelsMap(file), saveKeys(file), and saveProjectConfig(file).","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The storage service is a global singleton that handles reading and writing project data to and from storage. When constructed, it sets up a callback to mark the project as dirty when the gpt-service's modelsMap changes. It provides several functions: clear() clears all references to previously loaded data, new() sets up everything for a new project, open(filePath) loads all data from disk, loadModelsMap(filePath) loads the json file that defines the models for the project, loadKeys(filePath) loads the json file that maps fragment keys to their locations, loadProjectConfig(filePath) loads the json file with project configuration settings, updateOutOfDate() updates the list of out-of-date transformers for each text fragment, markDirty() marks the project as dirty, save(file) saves the project to disk, saveModelsMap(file) saves the models map to a json file, saveKeys(file) saves the fragment key mappings to a json file, and saveProjectConfig(file) saves the project configuration to a json file."}],"state":"still-valid"},"958692be-22c0-452b-90ac-6c36a431fafd":{"result":"The Key service creates and loads UUID keys for text fragments based on their location within the text. The 'calculateLocation' function builds a string representing the location by concatenating the titles of parent fragments. The 'loadUuidFromLocs' field is a dictionary indicating which UUIDs to use during project loading.\n\nThe 'assignKey' function assigns a key to a fragment. If a 'loadUuidFromLocs' dictionary exists, it searches for the location and assigns the UUID if found. Otherwise, it creates a new UUID key.\n\nThe 'getLocations' function creates a dictionary of location-key pairs from the project service's fragments list.\n\nThe 'calculateLocation' function calculates the key of a text fragment by determining its depth and looping through previous fragments to update the location string.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The Key service creates and loads UUID keys for text fragments. The location of a text fragment within the text is used to map a key during loading. The location is a string that consists of the titles of all parent text fragments concatenated with ' > '. The 'calculateLocation' function is used to build this string. The 'loadUuidFromLocs' field is a dictionary that indicates which UUIDs should be used when the project is being loaded. \n\nThe 'assignKey' function assigns a key to a fragment. If there is a 'loadUuidFromLocs' dictionary, it creates and searches for the location. If the location exists, it assigns the UUID to the fragment and removes the entry from the dictionary. If there is no 'loadUuidFromLocs' dictionary or the location wasn't in the dictionary, it creates a new UUID key and assigns it to the fragment. \n\nThe 'getLocations' function creates a dictionary of location-key pairs from the project service's fragments list and returns it. \n\nThe 'calculateLocation' function calculates the key of a text fragment. It takes a text fragment and its index position in the project as input. If the index position is not provided, it gets the index from the project service. It then calculates the current depth, the result value (which is the title of the text fragment), and loops through the text fragments from the given index position until 0. For each previous fragment with a smaller depth level, it updates the current depth, prepends the title of the previous fragment to the result, and stops the loop if the new current depth is 1."}],"state":"still-valid"},"68dbb9c3-e1a8-4287-b68a-db5070e55505":{"result":"The log service is a global singleton that tracks user messages. It has an eventTarget field for event dispatching. The showLogWindow property triggers a function to display the log window and an event. The beginMsg function creates a log item, converts a key to a location, stores data with a UUID, and sends it to the log window. The logMsgResponse function creates an object with a response and UUID, and sends it to the log window. The setLogWindowVisibility function should be registered and unregistered as a callback, updates the internal state, and triggers an event.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The log service is a global singleton that tracks messages for the user. It has an eventTarget field for dispatching events. The showLogWindow property, when set, calls a function to show the log window and triggers an event. The beginMsg function creates a log item, converts a key to a location, stores data with a UUID, and sends the log object to the log window. The logMsgResponse function creates an object with a response and UUID, and sends it to the log window. The setLogWindowVisibility function should be registered and unregistered as a callback, updates the internal state, and triggers an event."}],"state":"still-valid"},"33a93cd2-11ee-4ec2-9263-101b212474ab":{"result":"- The build service processes text fragments using transformers.\n- The eventTarget field dispatches events.\n- The showDebugger property triggers the `show-debugger` event and calls `window.electron.showDebugger(value)`.\n- The buildAll function iterates through fragments and calls the transformer's getResults function. It handles errors with `DialogService.showErrorDialog(error)`.\n- The runTransformer function asks the transformer for a result for a specific fragment. It handles errors with `DialogService.showErrorDialog(error)`.\n- The debug property indicates if the build service is in debug mode.\n- The isBuilding property indicates if a build function is running.\n- The isPaused property indicates if execution is paused.\n- The tryPause method pauses execution until the user presses continue or stop.\n- The runNext method raises the debugResolver and resets it.\n- The stopRun method raises the debugRejector and resets it.\n- The setDebuggerVisibility function updates showDebugger and triggers the `show-debugger` event.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"- The build service is a global singleton that processes text fragments of the project service using a set of transformers.\n- The eventTarget field is used to dispatch events.\n- The showDebugger property, when set, calls `window.electron.showDebugger(value)` and triggers the `show-debugger` event through the eventTarget field.\n- The async buildAll(transformer) function builds the project by iterating through the text fragments and calling the transformer's getResults function. If the transformer has the isFullRender property, it calls `await transformer.getResults(ProjectService.textFragments)`. Otherwise, it calls `await transformer.getResult(fragment)` for each fragment. On error, it calls `DialogService.showErrorDialog(error)`.\n- The async runTransformer(fragment, transformer) function asks the transformer to get its result for a specific fragment. On error, it calls `DialogService.showErrorDialog(error)`.\n- The debug property indicates if the build service is in debug mode. Its value is loaded from local storage upon creation and saved to local storage when updated.\n- The isBuilding property indicates if one of the build functions is currently running. It is set to true at the start of the functions and set to false at the end using a try-finally block. Setting isBuilding triggers the 'is-building' event through the eventTarget field.\n- The isPaused property indicates if the execution is currently paused. It is determined by the presence of the debugResolver property.\n- The tryPause method pauses execution until the user presses the continue or stop button, if in debug mode.\n- The runNext method raises the debugResolver (if assigned) and resets it to null.\n- The stopRun method raises the debugRejector (if assigned) and resets it to null.\n- The setDebuggerVisibility function should be registered as a callback with `window.electron.onDebuggerVisibility` and unregistered using `window.electron.removeOnDebuggerVisibility`. When called, it updates the internal state of showDebugger and triggers the `show-debugger` event through the eventTarget field."}],"state":"still-valid"},"1056ce6a-ac4b-410e-91d3-f8117a6084b0":{"result":"The build-stack service prevents circular references in the build process by tracking running textframe - transformer pairs and their state. The state can be set to \"validating\" to block calls to the llms. The service offers functions to register, unregister, and check running transformers.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The build-stack service is used to prevent circular references in the build process. It keeps track of running textframe - transformer pairs and their state. The state can be set to \"validating\" to block calls to the llms. The service provides functions to register, unregister, and check if a transformer is running."}],"state":"still-valid"},"ccbe1be3-fea6-4080-bce3-e13de89e4e42":{"result":"The All-Spark service creates and registers transformers in the Cybertron service. It has an eventTarget field for handling events and a transformers field for storing references to transformers. The getPlugins function loads and returns plugin definitions. The refreshPlugins function unloads old plugins, refreshes the list, and loads new ones. The loadPlugin function loads a plugin definition and handles errors. The unloadPlugin function unregisters and removes a plugin. The load function creates and registers transformers, excluding log mode, and calls loadPlugins. After loading all transformers, it dispatches the 'transformers-loaded' event.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The All-Spark service is responsible for creating and registering transformers into the Cybertron service. It has an eventTarget field for registering/unregistering event handlers and a transformers field that stores references to all created transformers. The getPlugins function returns a list of plugin definitions, loading them if necessary. The refreshPlugins function unloads old plugins, refreshes the list, and loads new plugins. The loadPlugin function loads a plugin definition and handles errors. The unloadPlugin function unregisters a plugin and removes it from the transformers dictionary. The load function creates and registers transformers, excluding log mode. It also calls loadPlugins. The loadPlugins function loads plugins and creates transformers for each, excluding plugin mode and log mode. After loading all transformers, it dispatches the 'transformers-loaded' event."}],"state":"still-valid"},"32ab0827-4dc7-4078-bd8a-88ea9064239d":{"result":"The constant-extractor service extracts constant definitions from source code, stores them in a json file, and replaces them with references in the source texts. It inherits from the transformer-base service and has a constructor with the parameter 'constants' and no dependencies. It has functions like 'load', 'extract-quotes', 'collect-response', 'render-result', and 'get-result'.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The constant-extractor service extracts constant definitions from source code, stores them in a json file, and replaces them with references in the source texts. It inherits from the transformer-base service and has a constructor with the parameter 'constants' and no dependencies. The service has several functions, including 'load' which loads the constants service, 'extract-quotes' which extracts locations in the text that contain quotes, and 'collect-response' which adds a quote to the list of quotes. The service also has a 'render-result' function that extracts quotes from a text fragment and caches the result, and a 'get-result' function that retrieves an up-to-date result value for a specified key, using the cache when possible."}],"state":"still-valid"},"80a81923-8079-4820-b50c-5cd3df1b12e1":{"result":"The app's main window uses a configProvider component to apply themes to antd components. It has a toolbar at the top and a draggable div for window movement. The body component fills the rest of the window.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"- The application's initial window is the main-window component.\n- The main window's root uses a configProvider component (from antd) to apply themes to antd components: `theme={{algorithm: theme === 'dark' ? darkAlgorithm : defaultAlgorithm}}`\n- It includes:\n  - A toolbar at the window's top.\n  - An additional div, `os-draggable`, paired with the toolbar in the header for window movement.\n  - A body component filling the remaining window space."}],"state":"still-valid"},"31da607d-07e2-4c54-9b1c-9a11a786c58f":{"result":"The line-parser service is a singleton object that parses markdown lines and updates text-fragments in the project-service. It has a fragmentIndex array. The createTextFragment function processes a line, assigns a depth-level, removes '#' symbols, trims the line, assigns a title, sets flags, initializes arrays, assigns a key, adds it to the project-service, and returns it. The clear function clears the fragmentsIndex list. The getStartLine function returns the index of a fragment. The parse function handles line parsing and list manipulation.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The line-parser service is a global singleton object that parses markdown lines and updates the text-fragments stored in the project-service. It has a fragmentIndex, which is an array of text-fragment objects. The createTextFragment function creates new text-fragments by processing a line and assigning it a depth-level based on the number of '#' symbols at the beginning. It also removes the '#' symbols, trims the line, and assigns a title value to the text-fragment. The function sets the 'is-out-of-date' flag to true, initializes arrays for 'lines' and 'outOfDateTransformers', assigns a key to the text-fragment, adds it to the project-service, and returns it. The clear function clears the fragmentsIndex list. The getStartLine function returns the index of a given fragment in the fragmentsIndex list. The parse function and related functions handle the parsing of lines and the insertion and deletion of lines in the fragmentsIndex list."}],"state":"still-valid","additionalKeys":[]},"421a1524-3e5c-431e-8444-470cae1d6cbb":{"result":"The transformer-base service is a base class for transformers, providing a common interface and functionality. The constructor has parameters for the transformer's name, dependencies, result format, language, temperature, and renderResults availability. This service uses a result-cache-service to store and track results. The load function loads dependencies and creates the cache. The renderResults, hasPromptChanged, keyToMessageParams, updateResult, getResult, getResults, calculateMaxTokens, and buildMessage functions have specific purposes and may need to be implemented by inheritors.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The transformer-base service is a base class for transformers. It provides a common interface and functionality. The constructor has parameters such as the name of the transformer, a list of transformer dependencies, a flag to indicate if the result values should be treated as JSON or regular text, the language in which the result data should be shown, the temperature to use for the llm requests, and a flag to indicate if a renderResults function is available. \n\nThis service uses a result-cache-service to store results and track when the build is out-of-date. The load function loads the dependencies and creates the cache. It replaces each dependency name with the corresponding object from the cybertron-service's list of transformers. The renderResults function is not implemented and needs to be provided by inheritors. The renderResult function performs a full rerender for a text fragment. The hasPromptChanged function checks if the prompt for the transformer has changed. The keyToMessageParams function converts a key to text fragments. The updateResult function updates the result if the cache is not up to date. The getResult function retrieves an up-to-date result value for a specified key. The getResults function retrieves an up-to-date result value. The calculateMaxTokens function calculates the maximum tokens for the llm. The buildMessage function builds the message from a text fragment and needs to be implemented by inheritors."}],"state":"still-valid","additionalKeys":[]},"8ac6d3c7-0806-4d9f-a790-88bbb45f9106":{"result":"The plugin-transformer service wraps a JavaScript object provided by a plugin, allowing the plugin to override default behavior. It inherits from the transformer-base service and checks for the validity of the plugin. The service loads the transformer, calculates max tokens, builds messages, and renders results based on the plugin's functions. It also updates results and checks for prompt changes using the plugin's functions. If the plugin lacks certain functions, it falls back to the base service's functions.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The plugin-transformer service acts as a wrapper around a JavaScript object provided by a plugin. The plugin provides configuration information for the transformer. The transformer interacts with the plugin to generate its result and allows the plugin to override default behavior at different points. \n\nThe service inherits from the transformer-base service and has a constructor that takes a plugin object as a parameter. If the plugin does not have a `getDescription` function, an error is raised to indicate that the plugin is invalid and cannot be used as a transformer. \n\nThe `load` function loads the transformer and adds its dependencies to the plugin. If the plugin has a `load` function, it is called. \n\nThe `calculateMaxTokens` function checks if the plugin has a `calculateMaxTokens` function. If it does, it returns the result of that function. Otherwise, it calls the `calculateMaxTokens` function of the base service. \n\nThe `buildMessage` function checks if the plugin has a `buildMessage` function. If it does, it returns the result of that function. Otherwise, it raises an error. \n\nThe `renderResults` function checks if the plugin has a `renderResults` function. If it does, it returns the result of that function. Otherwise, it calls the `renderResults` function of the base service. \n\nThe `renderResult` function checks if the plugin has a `renderResult` function. If it does, it calls that function and stores the result in the cache. If the plugin has an `iterator` function, it iterates over the fragments and builds a message using the plugin's `buildMessage` function. It then sends a request to the GPTService and stores the result in the cache. Finally, it returns the result. If the plugin does not have a `renderResult` function or an `iterator` function, it calls the `renderResult` function of the base service. \n\nThe `updateResult` function checks if the plugin has an `updateResult` function. If it does, it calls that function. If the plugin has an `iterator` function, it iterates over the fragments and builds a message using the plugin's `buildMessage` function. It then sends a request to the GPTService and updates the cache with the new result. Finally, it returns the result. If the plugin does not have an `updateResult` function or an `iterator` function, it calls the `updateResult` function of the base service. \n\nThe `hasPromptChanged` function checks if the plugin has a `hasPromptChanged` function. If it does, it calls that function. If the plugin has an `iterator` function, it iterates over the fragments and builds a message using the plugin's `buildMessage` function. It checks if the prompt has changed by comparing the message with the previous prompt. Finally, it returns the result. If the plugin does not have a `hasPromptChanged` function or an `iterator` function, it calls the `hasPromptChanged` function of the base service."}],"state":"still-valid","additionalKeys":[]},"03c15033-710c-4035-8591-0017a7461ca9":{"result":"The plugin-renderer service translates a plugin definition into a javascript module. It inherits from the transformer-base service and has specific constructor parameters. The load function loads and sets the `constantsService` field. The saveFile function saves a file. The cleanResult function removes unnecessary characters. The renderResult function builds a message, sends a request, cleans the result, saves the file, and caches the result. The buildMessage function counts non-empty lines and builds a message. The function returns the result and an empty array.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The plugin-renderer service translates a plugin definition into a javascript module. It is used to create plugin transformers that can be loaded and used by the application. This service inherits from the transformer-base service, which has specific constructor parameters. The load function asks the super class to load and sets the field `constantsService` to the first dependency. The saveFile function saves a file with a specific name and content. The cleanResult function removes unnecessary characters from the content. The renderResult function builds a message, sends a request, cleans the result, saves the file, and caches the result. The buildMessage function counts the number of non-empty lines in a fragment and builds a message based on whether it is shared or not. The function returns the result and an empty array."}],"state":"still-valid","additionalKeys":[]},"15110a27-64e0-45a5-b6ac-23df16688604":{"result":"The constants-resource renderer service creates a resource file with all constants from fragments. Plugins use this file for rendering. It inherits from transformer-base service and has a constructor with name, dependencies, and isJson parameters. It sets constantsService and isFullRender during construction. It has saveFile and renderResults functions for saving an array to a file and building a json dictionary of constants, respectively.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The constants-resource renderer service creates a resource file that contains all the constants found in the fragments. Most plugins rely on this file for rendering. It inherits from the transformer-base service and has a constructor with parameters for name, dependencies, and isJson. During construction, it sets the constantsService and isFullRender. It has two functions: saveFile, which saves an array to a file, and renderResults, which builds a json dictionary of constants and saves it."}],"state":"still-valid","additionalKeys":[]},"9c672829-a31d-47cb-9d66-e676423a06da":{"result":"The dialog service is a global singleton for displaying dialog boxes. It can show boxes for errors, warnings, and information. User-triggered actions in a component should have error handling, displaying an electron dialog box with error details. The electron.openDialog function is available through the contextBridge. Do not import the dialog module from electron.\n\nFunctions:\n- showErrorDialog(param1, param2): Displays an error dialog box with specified title and content.\n- showSaveDialog(): Displays a save dialog box with markdown and file type filters.\n- showOpenDialog(): Displays an open dialog box with markdown and file type filters.\n- confirm(message): Displays a question message box with \"Yes\", \"No\", and \"Cancel\" buttons. Returns true for \"Yes\", false for \"No\", and null for \"Cancel\".","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The dialog service is a global singleton that allows other components and services to display dialog boxes. It can show dialog boxes for errors, warnings, and information. All user-triggered actions or functions in a component should have proper error handling, which displays an electron dialog box with error details. The electron.openDialog function is globally available through the contextBridge loaded by the preloader script. Do not import the dialog module from electron.\n\nFunctions:\n- showErrorDialog(param1, param2): Displays an error dialog box with the title and content specified in the parameters.\n- showSaveDialog(): Displays a save dialog box with filters for markdown and any file types.\n- showOpenDialog(): Displays an open dialog box with filters for markdown and any file types.\n- confirm(message): Displays a message box with a question type, \"Yes\", \"No\", and \"Cancel\" buttons. Returns true if the user selects \"Yes\", false if \"No\" is selected, and null if \"Cancel\" is selected."}],"state":"still-valid","additionalKeys":[]},"fc366a69-db91-4f35-b538-182295436d18":{"result":"The theme service handles the selected theme font and size. It saves new values to local storage and notifies subscribers of changes. It retrieves stored values from local storage. It allows for light or dark theme selection. Components use the service to apply the selected theme to their styling. The main window refreshes content when the theme is updated.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The theme service manages the currently selected theme font and font-size. It saves the new values to local storage and notifies subscribers when the theme, font, or font-size is changed. The service retrieves previously stored values from local storage when created. It allows for selecting a light or dark theme. Components use the service to retrieve the selected theme and apply it to their styling. The main window refreshes its content when the selected theme is updated."}],"state":"still-valid","additionalKeys":[]},"7946446e-33e7-4bd5-a7b6-3d001271627c":{"result":"The project configuration service manages project configurations, including eventTarget for registering and unregistering event handlers for configuration changes. The config field is a JSON object providing full access to the configuration set.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The project configuration service manages project configurations. It includes the eventTarget field for registering and unregistering event handlers that monitor configuration changes. The config field is a JSON object that allows full access to the entire configuration set."}],"state":"still-valid","additionalKeys":[]},"3cd6abe1-d84e-41c4-a421-07a63d196280":{"result":"The change-processor service keeps the project structure in sync with the source by processing content changes. Its \"process\" function updates the project service when the user edits, replacing, deleting, inserting lines, and marking storage as dirty.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The change-processor service ensures that the project structure stays synchronized with the source by processing changes in the project content. It has a function called \"process\" that updates the project service when the user makes edits. The function replaces overwritten lines, deletes lines, inserts lines, and marks the storage as dirty."}],"state":"still-valid","additionalKeys":[]},"8c9e5644-55a8-44c2-ac7b-6fdea2680697":{"result":"The folder service is a global singleton that manages the location of the currently active project. It has properties for the project's root folder, name, file path, cache folder path, configuration file path, plugins folder path, plugins output folder path, and output folder path. \n\nThe folder service can perform actions like clearing, initializing, moving, copying, and setting a new location for the project. These actions involve tasks such as creating folders, moving and copying files, and updating project properties.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The folder service is a global singleton that manages the location of the currently active project. It has properties such as the current root folder of the project, the name of the project, the project file path, cache folder path, project configuration file path, plugins folder path, plugins output folder path, and output folder path. \n\nThe folder service can perform various actions such as clearing the project, initializing project folders, moving the project to a new location, copying the project to a new location, and setting a new location for the project. These actions involve tasks like creating folders, moving files, copying files, and updating the project properties."}],"state":"still-valid","additionalKeys":[]},"7ed49936-ac3f-4a7c-a70d-8ccd51b1c327":{"result":"The selection service tracks selected text and the active editor globally. It allows monitoring for selection changes and supports actions like cut, copy, paste, delete, clear selection, select all, and hasSelection. It also provides a function to retrieve the style of the selected line.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The selection service is a global object that keeps track of the currently selected text and the active editor. It can be monitored for changes in the selection. The service supports various actions such as cut, copy, paste, delete, clear selection, select all, and hasSelection. It also provides a function to get the style of the currently selected line."}],"state":"still-valid","additionalKeys":[]},"45fd1335-5429-47ea-a577-c11db18a28a0":{"result":"The position-tracking service tracks the user's current work on the text-fragment and transformer. It monitors the selected line number, related text-fragment, active transformer, and changes in the selected text-fragment. The service offers methods to set the current position, clear the active fragment and line, and set the active fragment and transformer.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The position-tracking service is responsible for tracking the text-fragment and transformer that the user is currently working on. It keeps track of the currently selected line number, the text-fragment related to the selected line, the active transformer, and events that monitor changes in the selected text-fragment. The service provides methods to set the current position, clear the active fragment and current line, and set the active fragment and transformer."}],"state":"still-valid","additionalKeys":[]},"0136ea45-e1de-4444-b833-2d8cfd2cc956":{"result":"The GPT service communicates with the open-ai api backend using the openai node.js library. It has a default model and stores information about maximum token size for known models. The sendRequest function sends API requests to open-ai and retrieves the appropriate model. The calculateTokens function calculates the number of tokens used. The getModels function retrieves available models. The apiKey field stores the API key and the setApiKey function updates it. The OpenAI library is instantiated with a valid API key.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The GPT service is responsible for communicating with the open-ai api backend and is used by transformers for specific tasks. It uses the openai node.js library and the js-tiktoken library for communication and token size calculation respectively. The service has a default model that can be set and retrieved, and it also stores information about the maximum token size for known models. The modelsMap field stores the model to be used for each transformer and text fragment. The sendRequest function is used to send an API request to open-ai, and it retrieves the appropriate model from the modelsMap. The calculateTokens function calculates the number of tokens used by the input message. The getModels function retrieves the list of available models. The apiKey field stores the API key used for authentication, and the setApiKey function updates the API key. The OpenAI library is only instantiated if a valid API key is provided."}],"state":"still-valid","additionalKeys":[]},"96aad863-3686-497b-8638-99081b0c947e":{"result":"This service manages cached results for transformers, storing the result and tracking its state. It also stores the input used to generate the output. The cache can monitor changes in a project service and other transformer result caches. Transformers use this class to cache their results. The cache uses a dictionary to map keys to results, saving them in a JSON file. The cache loads the file during construction and clears it if it doesn't exist. It can be updated with new results and provides functions to retrieve results, check if a fragment is out of date, and clear the cache. It handles events for fragment deletion, text fragment changes, and result changes from input services. Multiple keys are supported for a single result value.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"This service manages cached results for transformers. It stores the result of each transformation, along with a state to track if the result is out of date. The cache also stores the input used to generate the output. The cache can monitor changes in a project service and other transformer result caches. Transformers use an instance of this class to cache their results. The cache uses a dictionary to map keys to results. The cache saves the results in a JSON file, with the file name based on the project and transformer names. The cache loads the JSON file during construction and clears the cache if the file doesn't exist. The cache can be updated with new results using the 'setResult' function. The cache can also overwrite results for specific keys. The cache provides functions to retrieve results, check if a fragment is out of date, and clear the cache. The cache handles events for fragment deletion and text fragment changes. It also handles events for result changes from input services. The cache supports multiple keys for a single result value."}],"state":"still-valid","additionalKeys":[]},"849a7ae4-6a95-43dd-9c90-6ef41dc86a80":{"result":"The cybertron-service manages a global list of transformers and entry-points. The activeEntryPoint field indicates the currently selected entrypoint. Transformers can be registered, added to the list and optionally as an entry-point. If activeEntryPoint is empty and the registered transformer is an entrypoint, it becomes the activeEntryPoint. Transformers can also be unregistered, removed from both lists. The getTransformer(name) function searches for a transformer by name and returns the result. The load() function loads all transformers.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The cybertron-service manages a list of transformers globally. It also keeps track of entry-points, which are a subset of transformers used as starting points for text-fragments. The activeEntryPoint field indicates the currently selected entrypoint. Transformers can be registered, adding them to the list and optionally as an entry-point. If activeEntryPoint is empty and the registered transformer is an entrypoint, it becomes the activeEntryPoint. Transformers can also be unregistered, removing them from both lists. The getTransformer(name) function searches for a transformer by name and returns the result. The load() function loads all transformers."}],"state":"still-valid","additionalKeys":[]},"9b56f8e2-0e81-4cce-9555-4f163eda2294":{"result":"The plugin-list renderer service generates a file with all the plugins to load. It informs the application about which files to load for transformer-plugins. This service inherits from transformer-base and has a constructor with specific parameters. The load function asks the super class to load and sets a field. The saveFile function saves an array to a file. The renderResults function builds an array of files from the plugin-renderer and saves it to the output folder.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The plugin-list renderer service generates a file that contains all the plugins to be loaded. It is used to inform the application about which files to load for the transformer-plugins. This service inherits from the transformer-base service and has a constructor with specific parameters. The load function asks the super class to load and sets a field. The saveFile function saves an array to a file. The renderResults function builds an array of files provided by the plugin-renderer and saves it to the output folder."}],"state":"still-valid","additionalKeys":[]},"99052aeb-ef71-4cdb-ba64-1036a33417cc":{"result":"The parser-validator service is a debugging tool that verifies the internal markdown parser. It takes a snapshot of the current text state for a specified text-fragment. It does not use any llm. This service inherits from the transformer-base service, with the constructor parameters of name 'parser validator', empty dependencies, and isJson set to false. The main function, renderResult, takes a fragment as input, joins its lines into a string, caches the result, and returns it.","prompt":[{"role":"system","content":"condense the following text as much as possible, without loosing any meaning:"},{"role":"user","content":"The parser-validator service is a debugging tool that verifies the internal markdown parser. It takes a snapshot of the current text state for a specified text-fragment. It does not use any llm. This service inherits from the transformer-base service, with the constructor parameters of name 'parser validator', empty dependencies, and isJson set to false. The main function, renderResult, takes a fragment as input, joins its lines into a string, caches the result, and returns it."}],"state":"still-valid","additionalKeys":[]}},"secondaryCache":{"af17bd18-7341-4623-af40-b35190024b95":["af17bd18-7341-4623-af40-b35190024b95"],"8308b963-e815-48b2-a8a7-ce85d1353533":["8308b963-e815-48b2-a8a7-ce85d1353533"],"907586bd-b127-4fc8-925d-7374bc0a39b3":["907586bd-b127-4fc8-925d-7374bc0a39b3"],"f740a1e5-7a90-47b9-a4b1-654a97531cf1":["f740a1e5-7a90-47b9-a4b1-654a97531cf1"],"41dc0b70-7750-46ef-a8ea-fd48d5c99b94":["41dc0b70-7750-46ef-a8ea-fd48d5c99b94"],"a544fcfc-0cbb-4b88-b2c1-5dcd7db0816b":["a544fcfc-0cbb-4b88-b2c1-5dcd7db0816b"],"5f312819-504f-4fae-ab3d-c823668d659b":["5f312819-504f-4fae-ab3d-c823668d659b"],"6a3b7dc2-86c4-41e9-b132-9ed0a00a8dde":["6a3b7dc2-86c4-41e9-b132-9ed0a00a8dde"],"d1d83d0c-fde7-47a6-af75-696b0181f037":["d1d83d0c-fde7-47a6-af75-696b0181f037"],"65b637c7-f0ca-4672-aa83-8306b386db2b":["65b637c7-f0ca-4672-aa83-8306b386db2b"],"489a33cf-f216-48c2-9d18-987c3bc46280":["489a33cf-f216-48c2-9d18-987c3bc46280"],"048ce355-2a85-45c2-9d30-70eae30e832b":["048ce355-2a85-45c2-9d30-70eae30e832b"],"366c660c-4aa7-4160-9e22-e6ef4469c411":["366c660c-4aa7-4160-9e22-e6ef4469c411"],"982c423f-5854-4c77-af54-9ae223a79db9":["982c423f-5854-4c77-af54-9ae223a79db9"],"c25f5105-2ce2-4322-9637-09c2d74ac80a":["c25f5105-2ce2-4322-9637-09c2d74ac80a"],"f7a265c4-53b4-4c62-af43-adf2695e4272":["f7a265c4-53b4-4c62-af43-adf2695e4272"],"b49f427c-4dfe-4510-8e8b-ba3befef77e0":["b49f427c-4dfe-4510-8e8b-ba3befef77e0"],"60d16ad6-73cf-4bde-845c-000dff979205":["60d16ad6-73cf-4bde-845c-000dff979205"],"c9ce52a1-c141-47ec-a32c-f087b6174c3e":["c9ce52a1-c141-47ec-a32c-f087b6174c3e"],"dba35a53-38b0-41e8-b276-d62e24872944":["dba35a53-38b0-41e8-b276-d62e24872944"],"c25bd76e-af9b-4020-abe0-1ba023c9df76":["c25bd76e-af9b-4020-abe0-1ba023c9df76"],"912f3e5b-8b82-47e9-af50-50e97a5e03b1":["912f3e5b-8b82-47e9-af50-50e97a5e03b1"],"d809ef28-5a75-4f2a-8e28-9f895aa87bae":["d809ef28-5a75-4f2a-8e28-9f895aa87bae"],"581dcdbb-6401-4025-b898-606326a92aae":["581dcdbb-6401-4025-b898-606326a92aae"],"5a4c3d1a-0e09-424b-8fd0-6de342e56291":["5a4c3d1a-0e09-424b-8fd0-6de342e56291"],"6e52cca8-7baf-4c4f-97c5-effbf603eb14":["6e52cca8-7baf-4c4f-97c5-effbf603eb14"],"fd347c00-e1ea-4961-8544-3048650deb2b":["fd347c00-e1ea-4961-8544-3048650deb2b"],"958692be-22c0-452b-90ac-6c36a431fafd":["958692be-22c0-452b-90ac-6c36a431fafd"],"68dbb9c3-e1a8-4287-b68a-db5070e55505":["68dbb9c3-e1a8-4287-b68a-db5070e55505"],"33a93cd2-11ee-4ec2-9263-101b212474ab":["33a93cd2-11ee-4ec2-9263-101b212474ab"],"1056ce6a-ac4b-410e-91d3-f8117a6084b0":["1056ce6a-ac4b-410e-91d3-f8117a6084b0"],"ccbe1be3-fea6-4080-bce3-e13de89e4e42":["ccbe1be3-fea6-4080-bce3-e13de89e4e42"],"32ab0827-4dc7-4078-bd8a-88ea9064239d":["32ab0827-4dc7-4078-bd8a-88ea9064239d"],"80a81923-8079-4820-b50c-5cd3df1b12e1":["80a81923-8079-4820-b50c-5cd3df1b12e1"],"31da607d-07e2-4c54-9b1c-9a11a786c58f":["31da607d-07e2-4c54-9b1c-9a11a786c58f"],"421a1524-3e5c-431e-8444-470cae1d6cbb":["421a1524-3e5c-431e-8444-470cae1d6cbb"],"8ac6d3c7-0806-4d9f-a790-88bbb45f9106":["8ac6d3c7-0806-4d9f-a790-88bbb45f9106"],"03c15033-710c-4035-8591-0017a7461ca9":["03c15033-710c-4035-8591-0017a7461ca9"],"15110a27-64e0-45a5-b6ac-23df16688604":["15110a27-64e0-45a5-b6ac-23df16688604"],"9c672829-a31d-47cb-9d66-e676423a06da":["9c672829-a31d-47cb-9d66-e676423a06da"],"fc366a69-db91-4f35-b538-182295436d18":["fc366a69-db91-4f35-b538-182295436d18"],"7946446e-33e7-4bd5-a7b6-3d001271627c":["7946446e-33e7-4bd5-a7b6-3d001271627c"],"3cd6abe1-d84e-41c4-a421-07a63d196280":["3cd6abe1-d84e-41c4-a421-07a63d196280"],"8c9e5644-55a8-44c2-ac7b-6fdea2680697":["8c9e5644-55a8-44c2-ac7b-6fdea2680697"],"7ed49936-ac3f-4a7c-a70d-8ccd51b1c327":["7ed49936-ac3f-4a7c-a70d-8ccd51b1c327"],"45fd1335-5429-47ea-a577-c11db18a28a0":["45fd1335-5429-47ea-a577-c11db18a28a0"],"0136ea45-e1de-4444-b833-2d8cfd2cc956":["0136ea45-e1de-4444-b833-2d8cfd2cc956"],"96aad863-3686-497b-8638-99081b0c947e":["96aad863-3686-497b-8638-99081b0c947e"],"849a7ae4-6a95-43dd-9c90-6ef41dc86a80":["849a7ae4-6a95-43dd-9c90-6ef41dc86a80"],"9b56f8e2-0e81-4cce-9555-4f163eda2294":["9b56f8e2-0e81-4cce-9555-4f163eda2294"],"99052aeb-ef71-4cdb-ba64-1036a33417cc":["99052aeb-ef71-4cdb-ba64-1036a33417cc"]},"overwrites":{},"lastSaveDate":"2024-01-06T13:59:07.377Z"}