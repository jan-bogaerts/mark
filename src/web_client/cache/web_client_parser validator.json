{"cache":{"d810e70b-f331-4c5e-938c-fc7b81720651":{"result":"- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `await deps.classes.getResult(fragment)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n\n  - buildMessage(fragment,):\n- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `await deps.classes.getResult(fragment)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n\n  - buildMessage(fragment,):\n  - buildMessage(fragment, ):\n- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `await deps.classes.getResult(fragment)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n\n  - buildMessage(fragment,):\n- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `await deps.classes.getResult(fragment)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n\n  - buildMessage(fragment,):\n  - buildMessage(fragment, ):\n  - buildMessage(fragment, classes):\n- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `await deps.classes.getResult(fragment)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n\n  - buildMessage(fragment,):\n- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `await deps.classes.getResult(fragment)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n\n  - buildMessage(fragment,):\n  - buildMessage(fragment, ):\n- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `await deps.classes.getResult(fragment)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n\n  - buildMessage(fragment,):\n- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `await deps.classes.getResult(fragment)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n\n  - buildMessage(fragment,):\n  - buildMessage(fragment, ):\n  - buildMessage(fragment, classes):","prompt":["- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `await deps.classes.getResult(fragment)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`","","  - buildMessage(fragment,):","- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `await deps.classes.getResult(fragment)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`","","  - buildMessage(fragment,):","  - buildMessage(fragment, ):","- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `await deps.classes.getResult(fragment)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`","","  - buildMessage(fragment,):","- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `await deps.classes.getResult(fragment)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`","","  - buildMessage(fragment,):","  - buildMessage(fragment, ):","  - buildMessage(fragment, classes):","- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `await deps.classes.getResult(fragment)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`","","  - buildMessage(fragment,):","- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `await deps.classes.getResult(fragment)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`","","  - buildMessage(fragment,):","  - buildMessage(fragment, ):","- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `await deps.classes.getResult(fragment)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`","","  - buildMessage(fragment,):","- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `await deps.classes.getResult(fragment)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`","","  - buildMessage(fragment,):","  - buildMessage(fragment, ):","  - buildMessage(fragment, classes):"],"state":"still-valid"},"8325ad6e-bbd0-4925-8130-d30f0f257e3a":{"result":"- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n  - buildMessage(fragment, classes):\n    - result (json array):\n    - role: system, content:\n\n      > Act as an ai software analyst.\n      > It is your task to classify which of the following classes is the primary / root class described in the feature list.\n      > Only return the name of the class that is the primary / root, no explanation or any more text.\n\n    - role: user, content:\n\n      > classes:\n      > {{classes}}\n      >\n      > feature list:\n      > # {{title}}\n      > {{content}}\n\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `JSON.stringify(classes)`\n\n    - role: assistant, content:\n\n      > Remember: only return the name of the class that is the primary / root class.\n      > \n      > good response:\n      > x\n      >\n      > bad response:\n      > the primary / root class is x\n\n    - return: `result, [ ]`\n","prompt":["- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.","- part of determining which classes to render and which to import","- name: 'primary class'","- dependencies: ['classes', 'constants']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return 120 ","    just return a fixed size cause we only want 1 name coming back, shouldn't be too long","  - iterator(fragment, callback, resultSetter):","      ```python","        classes = await deps.classes.getResult(fragment)  ","        if len(classes) > 1:","          await callback(fragment, classes)","        elif len(classes) == 1:","          resultSetter(classes[0])","      ```    ","  - buildMessage(fragment, classes):","    - result (json array):","    - role: system, content:","","      > Act as an ai software analyst.","      > It is your task to classify which of the following classes is the primary / root class described in the feature list.","      > Only return the name of the class that is the primary / root, no explanation or any more text.","","    - role: user, content:","","      > classes:","      > {{classes}}","      >","      > feature list:","      > # {{title}}","      > {{content}}","","      replace:","      - {{title}}: `fragment.title`","      - {{content}}: `await deps.constants.getResult(fragment)`","      - {{classes}}: `JSON.stringify(classes)`","","    - role: assistant, content:","","      > Remember: only return the name of the class that is the primary / root class.","      > ","      > good response:","      > x","      >","      > bad response:","      > the primary / root class is x","","    - return: `result, [ ]`",""],"state":"still-valid"},"d295ba37-ab5b-41dc-b0ea-9ce333090530":{"result":"- The component-exact-description-service is responsible for generating descriptions of components based on the text-fragments that contain references to those components. A single description can only contain info about the requested component, any information about other components is removed.\n- Used as input for various other transformers that require the description of exactly only 1 component in a fragment instead of everything.\n- name: 'component exact description'\n- dependencies: ['compress', 'components', 'primary component']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return inputTokenCount.total\n  - iterator(fragment, callback):\n    ```python\n      components = await deps.components.getResult(fragment)\n      primary = await deps['primary component'].getResult(fragment)\n      for item in components:\n        await callback(fragment, components, primary, item)\n    ```\n\n  - buildMessage(fragment, components, primary, item):\n    - content, otherCompText, rememberPrompt = await buildContent(fragment, components, primary, item)\n    - if not content return null\n    - result (json array):\n      - role: system, content:\n\n        > Act as an ai software analyst.\n        > It is your task to write a description of the UI component '{{name}}' using the provided feature list.\n        > Only return what is in the feature list about {{name}}{{otherCompText}}. No introduction or explanation.\n\n        replaceAll:\n        - {{name}}: `item`\n        - {{otherCompText}}: `otherCompText`  \n\n      - role: user, content:\n\n        > the feature list:\n        > {{content}}\n\n        replaceAll:\n        - {{content}}: `content`\n\n    - if rememberPrompt, add to result: \n      - role: assistant, content: rememberPrompt\n    - return: `result, [ item ]`\n\n  - buildContent(fragment, components, primary, item):\n    ```python\n      info = await deps.compress.getResult(fragment)\n      if not info:\n        return None\n      other_components = [c for c in components if c != item]\n      remember_prompt = ''\n      if len(other_components) == 1:\n          to_be = ' is'\n          other_components = other_components[0]\n      elif len(other_components) > 1:\n          to_be = ' are'\n          if item == primary:\n              last_join = ' and '\n          else:\n              last_join = ' or '\n          other_components = ', '.join(other_components[:-1]) + last_join + other_components[-1]\n      else:\n          other_components = ''\n      if other_components:\n          if item == primary:\n              remember_prompt = 'Remember: mention where ' + other_components + to_be + ' used but not their features'\n              other_components = ', only mention where ' + other_components + to_be + ' used but not their features'\n          else:\n              other_components = ', do not mention anything about ' + other_components\n      return info, other_components, remember_prompt\n    ```\n","prompt":["- The component-exact-description-service is responsible for generating descriptions of components based on the text-fragments that contain references to those components. A single description can only contain info about the requested component, any information about other components is removed.","- Used as input for various other transformers that require the description of exactly only 1 component in a fragment instead of everything.","- name: 'component exact description'","- dependencies: ['compress', 'components', 'primary component']","- isJson: false","- functions:","  - calculateMaxTokens(inputTokenCount): return inputTokenCount.total","  - iterator(fragment, callback):","    ```python","      components = await deps.components.getResult(fragment)","      primary = await deps['primary component'].getResult(fragment)","      for item in components:","        await callback(fragment, components, primary, item)","    ```","","  - buildMessage(fragment, components, primary, item):","    - content, otherCompText, rememberPrompt = await buildContent(fragment, components, primary, item)","    - if not content return null","    - result (json array):","      - role: system, content:","","        > Act as an ai software analyst.","        > It is your task to write a description of the UI component '{{name}}' using the provided feature list.","        > Only return what is in the feature list about {{name}}{{otherCompText}}. No introduction or explanation.","","        replaceAll:","        - {{name}}: `item`","        - {{otherCompText}}: `otherCompText`  ","","      - role: user, content:","","        > the feature list:","        > {{content}}","","        replaceAll:","        - {{content}}: `content`","","    - if rememberPrompt, add to result: ","      - role: assistant, content: rememberPrompt","    - return: `result, [ item ]`","","  - buildContent(fragment, components, primary, item):","    ```python","      info = await deps.compress.getResult(fragment)","      if not info:","        return None","      other_components = [c for c in components if c != item]","      remember_prompt = ''","      if len(other_components) == 1:","          to_be = ' is'","          other_components = other_components[0]","      elif len(other_components) > 1:","          to_be = ' are'","          if item == primary:","              last_join = ' and '","          else:","              last_join = ' or '","          other_components = ', '.join(other_components[:-1]) + last_join + other_components[-1]","      else:","          other_components = ''","      if other_components:","          if item == primary:","              remember_prompt = 'Remember: mention where ' + other_components + to_be + ' used but not their features'","              other_components = ', only mention where ' + other_components + to_be + ' used but not their features'","          else:","              other_components = ', do not mention anything about ' + other_components","      return info, other_components, remember_prompt","    ```",""],"state":"out-of-date"}},"secondaryCache":{"d810e70b-f331-4c5e-938c-fc7b81720651":["d810e70b-f331-4c5e-938c-fc7b81720651"],"8325ad6e-bbd0-4925-8130-d30f0f257e3a":["8325ad6e-bbd0-4925-8130-d30f0f257e3a"],"d295ba37-ab5b-41dc-b0ea-9ce333090530":["d295ba37-ab5b-41dc-b0ea-9ce333090530"]},"overwrites":{},"lastSaveDate":"2024-01-26T15:43:23.997Z"}