{"cache":{"ac18eefb-e5c5-457e-b0b1-c68bbb862a85":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_shared.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export all the functions that are declared in the specification \nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included"},{"role":"user","content":"specification:\n\n- getIsDeclared(deps, transformerName, fragment, item): get the result of the declare-or-use transformer and see if the specified item is declared or not. \n  Do case insensitive search.\n  ```python\n    name = item.lower()\n    result = await deps[transformerName].getResult(fragment)\n    temp_items = {k.lower(): v for k, v in result.items()}\n    if name in temp_items:\n      return temp_items[name] == 'declare'\n    else:\n      return False\n  ```\n- getAllDeclared(deps, transformerName, fragment):\n  ```python\n    data = await deps[transformerName].getResult(fragment)\n    return [name for name in data if data[name] == 'declare']\n  ```\n- buildPath(services, declaredIn, filename):\n  ```python\n    declaredIn = services.keyService.calculateLocation(declaredIn.key) \n    declared_in_parts = declaredIn.split(\" > \")\n    declared_in_parts[0] = 'src' # replace the first part with src so that it replaces the name of the project which isn't the root of the source code\n    path = os.path.join(*declared_in_parts, filename.replaceAll(\" \", \"_\").replaceAll('-', '_') )\n    return path\n  ```\n- getDeclaredIn(deps, transformerName, fragment, item): Returns the key of the text fragment where the item is declared. \n  Do case insensitive search.\n  ```python\n    item = item.lower()\n    result = await deps[transformerName].getResult(fragment)\n    temp_items = {k.lower(): v for k, v in result.items()}\n    if item in temp_items:\n      return temp_items[item]\n    return None\n  ```\n- getToRenderAndUsed(deps, fragment, components): splits up the list of components into a list of components that are declared in the fragment and a list of components that are only used by the declared components in this fragment\n  ```python\n    to_render = []\n    used = []\n    classifications = await deps['declare or use component'].getResult(fragment)\n    classifications = {k.lower(): v for k, v in classifications.items()}\n    for component in components:\n      name = component.lower()\n      if classifications[name] === 'declare':\n          to_render.append(component)\n      else:\n          used.append(component)\n    return to_render, used\n  ```\n- getPath(services, fragment): calculate the path to the files we will generate cause we need it to get the import paths of the locally declared components\n  ```python\n    fullTitle = services.keyService.calculateLocation(fragment)\n    titleToPath = fullTitle.replaceAll(\":\", \"\").replaceAll('?', '').replaceAll('!', '')\n    pathItems = titleToPath.split(\" > \")\n    pathItems = [part.replaceAll(\" \", \"_\") for part in pathItems]\n    pathItems[0] = 'src' # the first item is the project name, we need to replace it with src so that the code gets rendered nicely\n    return os.path.join(services.folderService.output, *pathItems)\n  ```\n- readFile(filePath): read the contents of the specified file and return as a string.\n- getExternalDescription(deps, fragment, item): get how other code has used the class\n    ```python\n        results = {}\n        found = False\n        all = (await deps['usage-extractor'].getResult(fragment))?.[item]\n        if all:\n          for key, value in all.items():\n            for service, usage in value:\n              for feature, desc in usage:\n                if not feature in results:\n                results[feature] = desc\n                found = True\n        if found:\n          toJoin = []\n          for key, value in results.items():\n            toJoin.append(f'{key}: {value}')\n          return f'\\nMake certain that {item} has:\\n- ' + '\\n- '.join(toJoin) + '\\n'\n        return ''\n    ```\n- getOtherInterfaces(deps, fragment, item): get the interface definitions of other classes that are used by this class. Only include parts of the interface that are actually used in the code that needs to be rendered.\n    ```python\n        interfaceTxt = ''\n        all = (await deps['consumed interfaces class'].getResult(fragment))?.[item]\n        if all:\n          for key, value in all.items():\n            found = False\n            results = {}\n            for service, usage in value:\n              interfaceTxt += f'\\n{service} has the following interface:\\n' + JSON.stringify(usage) + '\\n'\n        return interfaceTxt\n    ```  \n- getAllImports(deps, depName, fragment, item, renderToPath): build the text that defines which modules should be imported\n   ```python\n      importsTxt = None\n      constants = deps.constants.cache.getFragmentResults(fragment.key)\n      if constants:\n        resourcesPath = os.path.join(services.folderService.output, 'src', 'resources.json')\n        relPath = os.path.relpath(resourcesPath, renderToPath)\n        relPath = relPath.replaceAll('\\\\', '/')\n        importsTxt += f\"The const 'resources' can be imported from {relPath}\\n\"\n      imports = await deps[depName].getResult(fragment)?.[item]\n      if imports:\n        for importDef in imports:\n          importsTxt += await getImportServiceLine(importDef, renderToPath)\n      if importsTxt:\n        importsTxt = '\\n\\nimports (only include the imports that are used in the code):\\n' + importsTxt\n      return importsTxt\n    ```   \n- getImportServiceLine(importDef, renderToPath):\n    ```python\n        service = importDef['service']\n        servicePath = importDef['path']\n        servicePath = os.path.relpath(servicePath, renderToPath)\n        isGlobal = (await deps['is service singleton'].getResult(importDef['key']))?.[service]\n        if isGlobal:\n            serviceTxt = \"global object\"\n            service = service.lower()\n        else:\n            serviceTxt = \"service\"\n        return f\"The {serviceTxt} {service} can be imported from {servicePath} (exported as default)\\n\"\n    ```      "}],"state":"out-of-date"},"0da9552a-d9c0-404a-a806-f02011371ff4":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_compress_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"compress service\n- The compress service takes a text fragment and makes it shorter.\n- Useful to check if the system understands the fragment and can be used as input for other processes.\n- name: 'compress'\n- dependencies: ['constants']\n- isJson: false\n- calculateMaxTokens(inputTokenCount): return inputTokenCount\n- build-message(text-fragment):\n  - result (json array):\n    - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_compress_service_1\n    - role: user, content: \n      ```python \n        content: await deps.constants.getResult(fragment)\n      ```\n  - return result, [ ]\n\n"}],"state":"still-valid"},"fecfce6f-c166-4101-b713-cb29fa7a6bcd":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_double-compress_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"double-compress service\n- The double-compress-service takes the result of compress-service and makes it even shorter.\n- Useful to check if the system understands the fragment and can be used as input for other processes.\n- name: 'double compress'\n- dependencies: ['compress']\n- isJson: false\n- calculateMaxTokens(inputTokenCount): return inputTokenCount\n- build-message(text-fragment):\n  - result (json array):\n    - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_double_compress_service_1\n    - role: user, content: await deps.compress.getResult(fragment)\n  - return result, [ ]\n\n"}],"state":"still-valid"},"1480dd97-cec4-402d-bc5e-3cb0ce666210":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_triple-compress_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"triple-compress service\n- The triple-compress-service takes the result of double-compress-service and shortens it to 1 line.\n- Used as a description for each fragment when searching for linked components and services.\n- name: 'triple compress'\n- dependencies: ['double compress']\n- isJson: false\n- calculateMaxTokens(inputTokenCount): return inputTokenCount\n- build-message(text-fragment):\n  - result (json array):\n    - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_triple_compress_service_1\n    - role: user, content: await deps['double compress'].getResult(text-fragment)\n  - return result, [ ]\n"}],"state":"out-of-date"},"318cec5a-9882-4320-96a6-e1ebc6762c6b":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_component-lister_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"component-lister service\n- the component-lister service is responsible for extracting all the component names it can find in a text-fragment.\n- part of finding out which components need to be rendered\n- name: 'components'\n- dependencies: []\n- isJson: true\n- calculateMaxTokens(inputTokenCount): return inputTokenCount / 2\n- build-message(textFragment):\n  - if refs.projectService.textFragments.indexOf(textFragment) < 2: return null\n  - result (json array):\n    - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_component_lister_service_1\n      replace:\n      - {{dev_stack_title}}: `services.projectService.textFragments[1]?.title`\n      - {{dev_stack_content}}: `services.projectService.textFragments[1]?.lines.join('\\n')`\n\n    - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_component_lister_service_2\n      replace:\n      - {{title}}: `textFragment.title`\n      - {{content}}: `textFragment.lines.join('\\n')`\n\n    - role: assistant, content: the value of the constant resources.res_web_client_plugins_transformers_component_lister_service_3\n  - return:\n    ```python\n    if len(services.projectService.textFragments) >= 1:\n      return result, [services.projectService.textFragments[1].key ]\n    else:\n      result, []\n    ```\n"}],"state":"still-valid"},"7338df56-c381-4acb-8f5e-25587f5bd08d":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web_client_plugins_transformers_class_lister_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, resultSetter) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount.total + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"class-lister service\n- the class-lister service is responsible for extracting all the names of the classes that are declared in a text fragment.\n- determines which classes need to be rendered\n- name: 'classes'\n- dependencies: ['constants']\n- isJson: true\n- calculateMaxTokens(inputTokenCount): return inputTokenCount.total / 2\n- build-message(textFragment):\n  - if services.projectService.textFragments.indexOf(textFragment) < 2: return null\n  - linesStr = textFragment.lines.join('\\n'); if (!linesStr.trim()) return null\n  - result (json array):\n    - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_class_lister_service_1\n      replace:\n        - {{dev_stack_title}}: `services.projectService.textFragments[1]?.title`\n        - {{dev_stack_content}}: `services.projectService.textFragments[1]?.lines.join('\\n')`\n\n    - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_class_lister_service_2\n      replace:\n      - {{title}}: `textFragment.title`\n      - {{content}}: `await deps.constants.getResult(textFragment)`\n\n  - return:\n    ```python\n    if len(services.projectService.textFragments) >= 1:\n      return result, [ services.projectService.textFragments[1].key ]\n    else:\n      result, [  ]\n   ```\n\n"}],"state":"out-of-date"},"892f1f34-3fd1-4a59-bfe4-16552f49a9e1":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_class-description_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"class-description service\n- The class-description-service is responsible for generating descriptions of classes based on the text-fragments that contain references to those classes.\n- Used as input for various other transformers that require the description of only 1 class in a fragment instead of everything.\n- name: 'class description'\n- dependencies: ['double compress', 'classes']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return inputTokenCount\n  - iterator(fragment, callback):\n    ```python\n      classes = await deps.classes.getResult(fragment)  \n      for item in classes:\n        callback(fragment, item)\n    ```\n  - buildMessage(fragment, item):\n    - content = await deps['double compress'].getResult(fragment)\n    - if not content return null\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_class_description_service_1\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_class_description_service_2\n        replace:\n        - {{name}}: `item`\n        - {{content}}: `content`    \n    - return: `result, [ item ]`\n\n"}],"state":"still-valid"},"53ce18ed-32d9-4d75-a1fb-daa6fca3055a":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_component-description_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"component-description service\n- The component-description-service is responsible for generating descriptions of components based on the text-fragments that contain references to those components. A single description can still contain info about other components that are mentioned in the fragment.\n- Used as input for various other transformers that require the description of only 1 component in a fragment instead of everything.\n- name: 'component description'\n- dependencies: ['double compress', 'components']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return inputTokenCount\n  - iterator(fragment, callback):\n    ```python\n      components = await deps.components.getResult(fragment)\n      for item in components:\n        callback(fragment, item)\n    ```\n  - buildMessage(fragment, item):\n    - content = await debs['double compress'].getResult(fragment)\n    - if not content return null\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_component_description_service_1\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_component_description_service_2\n        replace:\n        - {{name}}: `item`\n        - {{content}}: `content`    \n    - return: `result, [ item ]`\n\n"}],"state":"still-valid"},"d295ba37-ab5b-41dc-b0ea-9ce333090530":{"result":"C:\\Users\\janbo\\Documents\\dev\\markdownCode\\src\\web_client\\output\\web_client_plugins_transformers_component_exact_description_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, resultSetter) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount.total + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"component-exact-description service\n- The component-exact-description-service is responsible for generating descriptions of components based on the text-fragments that contain references to those components. A single description can only contain info about the requested component, any information about other components is removed.\n- Used as input for various other transformers that require the description of exactly only 1 component in a fragment instead of everything.\n- name: 'component exact description'\n- dependencies: ['components', 'primary component']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return inputTokenCount.total\n  - iterator(fragment, callback):\n    ```python\n      components = await deps.components.getResult(fragment)\n      primary = await deps['primary component'].getResult(fragment)\n      for item in components:\n        await callback(fragment, components, primary, item)\n    ```\n\n  - buildMessage(fragment, components, primary, item):\n    - content, otherCompText, rememberPrompt = await buildContent(fragment, components, primary, item)\n    - if not content return null\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_component_exact_description_service_1\n        replaceAll:\n        - {{name}}: `item`\n        - {{otherCompText}}: `otherCompText`  \n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_component_exact_description_service_2\n        replaceAll:\n        - {{content}}: `content`\n\n    - if rememberPrompt, add to result: \n      - role: assistant, content: rememberPrompt\n    - return: `result, [ item ]`\n\n  - buildContent(fragment, components, primary, item):\n    ```python\n      info = '\\n'.join(fragment.lines)\n      if not info:\n        return None\n      other_components = [c for c in components if c != item]\n      remember_prompt = ''\n      if len(other_components) == 1:\n          to_be = ' is'\n          other_components = other_components[0]\n      elif len(other_components) > 1:\n          to_be = ' are'\n          if item == primary:\n              last_join = ' and '\n          else:\n              last_join = ' or '\n          other_components = ', '.join(other_components[:-1]) + last_join + other_components[-1]\n      else:\n          other_components = ''\n      if other_components:\n          if item == primary:\n              remember_prompt = 'Remember: mention where ' + other_components + to_be + ' used but not their features'\n              other_components = ', only mention where ' + other_components + to_be + ' used but not their features'\n          else:\n              other_components = ', do not mention anything about ' + other_components\n      return info, other_components, remember_prompt\n    ```\n"}],"state":"still-valid"},"c04f4d5b-2cf5-46fb-8e99-6050acca9981":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_declare-or-use-component_classification_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"declare-or-use-component classification service\n- The declare-or-use-component classification service is responsible for figuring out if a component gets declared or used in a text-fragment.\n- Used to determine if a file needs to be generated for the component or the info needs to be used to find out from where to import the component.\n- name: 'declare or use component'\n- dependencies: ['triple compress', 'components', 'primary component', 'component description']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 250\n  - iterator(fragment, callback, result):\n    ```python\n      titles = await getOtherTitles(fragment.key)\n      components = await deps.components.getResult(fragment)\n      if len(components) > 0:\n        primary = await deps['primary component'].getResult(fragment)\n        for item in components:\n          if item == primary:\n            keys = [fragment.key, item]\n            key = keys.join(' | ')\n            result[key] = 'declare'\n          else:\n            callback(fragment, titles, item)\n    ```\n  - getOtherTitles(toExclude): get every short description and fragment-key in the project that currently has components associated with it. \n  ```python\n    result = []\n    for fragment in services.projectService.textFragments:\n      components = await deps.components.getResult(fragment)\n      if components and fragment.key != toExclude:\n        description = await deps['triple compress'].getResult(fragment)\n        value = f'# {services.keyService.calculateLocation(fragment.key)}:\\n{description}\\n'\n        result.push()\n    return result\n  ```    \n  - cleanResponse(response): if 'no' is returned, convert to 'declare'\n    ```python\n      if response.lower() == 'no':\n        return 'declare'\n      else:\n        if response.startswith(\"'\"):\n          response = response[1:]\n        if response.endswith(\"'\"):\n          response = response[:-1]\n      return response\n    ```\n  - buildMessage(fragment, item, titles):\n    - description = await deps['component description'].getResult(fragment)\n    - if not description return null\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_declare_or_use_component_classification_service_1\n        replace:\n        - {{name}}: `item`\n        - {{description}}: `description`  \n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_declare_or_use_component_classification_service_2\n        replace:\n        - {{name}}: `item`\n        - {{titles}}: `'\\n'.join(titles)`    \n    - return: `result, [ item ]`\n\n"}],"state":"out-of-date"},"0553c884-b0fd-41f6-8504-a26e63741a42":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_is-service-used_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"is-service-used service\n- The is-service-used classification service is responsible for figuring out if a text fragment uses any of the currently known service-classes in the project.\n- Used to determine which files should be imported and which interfaces should be known about.\n- name: 'is service used'\n- dependencies: ['declare or use class', 'class description', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): 4\n  - iterator(fragment, callback, result):\n    ```python\n      for toCheck in services.projectService.textFragments:\n        if toCheck.key == fragment.key: continue\n        classes = await deps['declare or use class'].getResult(toCheck)\n        for className, value in classes.items():\n          if value == 'declare':\n            callback(fragment, toCheck, className)\n    ```\n\n  - buildMessage(fragment, checkAgainst, className):\n    - description = await deps['class description'].getResult(checkAgainst)\n      if not description return null\n      description = description[className] # a fragment can have multiple classes, so get the description of the class we are searching for\n      if not description return null\n    - content = await deps.constants.getResult(fragment)\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_is_service_used_service_1\n        replace:\n        - {{class}}: `className`\n        - {{class_description}}: `description`  \n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_is_service_used_service_2\n        replace:\n        - {{feature_desc}}: `content`\n\n    - return: `result, [ checkAgainst.key, className ]`\n"}],"state":"still-valid"},"543b6187-6bb9-44fb-a2f0-3d1019a97794":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_is-service-singleton_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"is-service-singleton service\n- The is-service-singleton service is responsible for figuring out if a class that is declared in a text fragment is described as being a singleton or not.\n- Used to determine how a class should be rendered.\n- name: 'is service singleton'\n- dependencies: ['declare or use class', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): 5\n  - iterator(fragment, callback, result):\n    ```python\n        classes = await deps['declare or use class'].getResult(fragment)\n        for className, value in classes.items():\n          if value == 'declare':\n            callback(fragment, className)\n    ```\n\n  - buildMessage(fragment, className):\n    - content = await deps.constants.getResult(fragment)\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_is_service_singleton_service_1\n        replace:\n        - {{class}}: `className`\n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_is_service_singleton_service_2\n        replace:\n        - {{feature_desc}}: `content`\n\n    - return: `result, [ className ]`\n"}],"state":"still-valid"},"b85f66e1-2a2b-4739-ac8e-ed15cd62f716":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_list-component-props_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"list-component-props service\n- The list-component-props service builds a list of properties that a component is described to have.\n- Used to determine how a class should be rendered.\n- name: 'component props'\n- dependencies: ['declare or use component', 'component exact description']\n- isJson: true\n- functions:\n  - calculateMaxTokens(inputTokenCount): 240\n  - iterator(fragment, callback):\n    ```python\n        components = await deps['declare or use component'].getResult(fragment)\n        for compName, value in components.items():\n          if value == 'declare':\n            callback(fragment, compName)\n    ```\n  - buildMessage(fragment, compName):\n    - description = `await deps['component exact description'].getResult(fragment)`\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_list_component_props_service_1\n        replace:\n        - {{name}}: `compName`\n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_list_component_props_service_2\n        replace:\n        - {{feature_desc}}: `description`\n\n    - return: `result, [ compName ]`\n"}],"state":"still-valid"},"9914d2b4-da7a-4e0d-af78-502bdb31995d":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_is-service-for-all-components_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"is-service-for-all-components service\n- The is-service-for-all-components  service is responsible for figuring out if a class described in the fragment should be usd by all components or not.\n- Used to determine which files should be imported and which extra info needs to be added to component rendering.\n- name: 'is service for all components'\n- dependencies: ['declare or use class', 'class description']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): 5\n  - iterator(fragment, callback, result):\n    ```python\n        classes = await deps['declare or use class'].getResult(fragment)\n        for className, value in classes.items():\n          if value == 'declare':\n            callback(fragment, className)\n    ```\n\n  - buildMessage(fragment, className):\n    - description = await deps['class description'].getResult(fragment)\n      if not description return null\n      description = description[className] # a fragment can have multiple classes, so get the description of the class we are searching for\n      if not description return null\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_is_service_for_all_components_service_1\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_is_service_for_all_components_service_2\n        replace:\n        - {{feature_desc}}: `description`\n\n    - return: `result, [ className ]`\n\n"}],"state":"still-valid"},"42252887-b7ee-45f1-bf6f-dc692f996bc0":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_service-usage_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"service-usage service\n- The service-usage service is responsible for extracting all the features described in a fragment that relate to a particular service.\n- Used to determine the full set of feature requirements of a class.\n- name: 'service usage'\n- dependencies: ['declare or use class', 'is service used', 'constants']\n- isJson: true\n- functions:\n  - calculateMaxTokens(inputTokenCount): inputTokenCount\n  - iterator(fragment, callback, result):\n    ```python\n        for toCheck in services.projectService.textFragments:\n          if toCheck.key == fragment.key: continue\n          classes = await deps['declare or use class'].getResult(toCheck)\n          for className, value in classes.items():\n            if value == 'declare':\n              isUsed = await getIfClassIsUsed(fragment, toCheck, className)\n              if isUsed:\n                callback(fragment, className)\n    ```\n  - getIfClassIsUsed(fragment, toCheck, className):\n    ```python\n      isUsedData = await deps['is service used'].getResult(fragment)\n      if isUsedData and toCheck.key in isUsedData:\n        section = isUsedData[toCheck.key]\n        if section and className in section:\n          return section[className].lower() == 'yes'\n      return False\n\n    ``` \n  - cleanResponse(response, fragment, toCheck)\n    ```python\n      return {\n                'value': response,\n                'source': toCheck.key,\n              }\n    ```\n  - buildMessage(fragment, className):\n    - content = await deps.constants.getResult(fragment)\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_service_usage_service_1\n        replace:\n        - {{class}}: `className`\n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_service_usage_service_2\n        replace:\n        - {{feature_desc}}: `content`\n\n      - role: assistant, content: the value of the constant resources.res_web_client_plugins_transformers_service_usage_service_3\n        replace:\n        - {{class}}: `className`\n\n    - return: `result, [ className ]`\n"}],"state":"still-valid"},"fe77852e-f251-4480-b206-e83a0159bf0b":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_global-component-features_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"global-component-features service\n- The global-component-features service extracts the list of features that all components should implement according to a service.\n- Used to determine how a components should be rendered.\n- name: 'global component features'\n- dependencies: ['is service for all components', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): inputTokenCount\n  - iterator(fragment, callback):\n    ```python\n        toCheck = await deps['is service for all components'].getResult(fragment)\n        for service, value in toCheck.items():\n          if value == 'yes':\n            callback(fragment, service)\n    ```\n  - buildMessage(fragment, service):\n    - description = `await deps.constants.getResult(fragment)`\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_global_component_features_service_1\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_global_component_features_service_2\n        replace:\n        - {{feature_desc}}: `description`\n\n    - return: `result, [ service ]`\n"}],"state":"still-valid"},"35493b3f-918b-4441-b521-93269ef6921f":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_component-imports_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"component-imports service\n- The component-imports service is responsible for generating the list of modules that should be imported by a component.\n- Used to prepare the rendering of the code file for a component.\n- name: 'component imports'\n- dependencies: ['components', 'declare or use component', 'service usage', 'global component features', 'component description']\n- isJson: false\n- functions: \n  - calculateMaxTokens(inputTokenCount): 200\n  - iterator(fragment, callback, result):\n    ```python\n      components = await deps.components.getResult(fragment)\n      for component in components:\n        isDeclare = await shared.getIsDeclared(deps, 'declare or use component', fragment, component) \n        if isDeclare:\n            imports = await getServiceImports(fragment)\n            results[component] = imports\n        else:\n            await resolveComponentImports(fragment, component, callback, results)\n    ```\n  - getServiceImports(fragment):\n    ```python\n      imported = {} # so we don't list the same thing twice\n      results = []\n\n      services_used = await deps['service usage'].getResult(fragment)\n      if services_used:\n          for service, rec in services_used.items():\n              if not rec['value']:\n                  continue # some services are included in the list cause the previous step had flagged them (cheap run), but then list_service_usage didn't find any usage of them (expensive run)\n              service_loc = rec['source']\n              cur_path_parts = service_loc.split(\" > \")\n# replace all spaces with underscores\n              cur_path_parts = [part.replaceAll(\" \", \"_\") for part in cur_path_parts]\n              cur_path_parts[0] = 'src' # replace the first part with src so that it replaces the name of the project which isn't the root of the source code\n              if not service in imported:\n                  imported[service] = True\n                  service_path = os.path.join(*cur_path_parts, service.replaceAll(\" \", \"_\"))\n                  results.append({'service': service, 'path': service_path, 'service_loc': service_loc})\n      for fragment in services.projectService.textFragments:\n          globalFeatures = await deps['global component features'].getResult(fragment)\n          if globalFeatures:\n            cur_path_parts = fragment.key.split(\" > \")\n# replace all spaces with underscores\n            cur_path_parts = [part.replaceAll(\" \", \"_\").replaceAll('-', '_') for part in cur_path_parts]\n            cur_path_parts[0] = 'src' # replace the first part with src so that it replaces the name of the project which isn't the root of the source code\n            for service, features in globalFeatures.items():\n                if not service in imported:\n                    imported[service] = True\n                    service_path = os.path.join(*cur_path_parts, service.replaceAll(\" \", \"_\").replaceAll('-', '_')).strip()\n                    results.append({'service': service, 'path': service_path, 'service_loc': fragment.full_title})\n      return results  \n    ```     \n  - resolveComponentImports(fragment, component, callback, results):\n    ```python\n      declared_in = await shared.getDeclaredIn(deps, 'declare or use component', fragment, component)\n      if not declared_in:\n          raise new Error(f\"can't find import location for component {component} used in {fragment.key}\")\n      else:\n          declaredInFragment = services.projectService.getFragment(declared_in.replaceAll(\"'\", \"\").replaceAll('\"', '')) # remove quotes cause gpr sometimes adds them\n          if not declaredInFragment:\n            raise new Error(f'component declared in {declared_in}, but fragment cant be found at specified index')\n          components = await deps.components.getResult(declaredInFragment)\n          if component in components:\n              path = shared.buildPath(services, declaredInFragment, component)\n              results[component] = path\n          else:\n# if there is only 1 component declared in the fragment, we can presume that's the one we need\n              declared_comps = await shared.getAllDeclared(deps, 'declare or use component', declaredInFragment)\n              if len(declared_comps) == 1:\n                  path = shared.buildPath(services, declaredInFragment, declared_comps[0])\n                  results[component] = path\n              else:\n                  iterator(fragment, component, declared_comps, declaredInFragment) # declaredInFragment is needed for cleanresponse\n    ```\n  - cleanResponse(response, fragment, component, declared_comps, declaredInFragment): `return shared.buildPath(services, declaredInFragment, response)` \n  - buildMessage(fragment, component, declared_comps):\n    - description = await deps['component description'].getResult(fragment)\n      if not description return null\n      description = description[component] # a fragment can have multiple classes, so get the description of the class we are searching for\n      if not description return null\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_component_imports_service_1\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_component_imports_service_2\n        replace:\n        - {{description}}: `description`\n        - {{items}}: `\\n- '.join(declared_comps)`\n        - {{component}}: `component`\n\n    - return: `result, [ component ]`\n\n"}],"state":"still-valid"},"91c07e2e-b004-4ab4-8d1d-4a8cc69beee1":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_class-imports_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"class-imports service\n- The class-imports service is responsible for generating the list of modules that should be imported by a class.\n- Used to prepare the rendering of the code file for a class.\n- name: 'class imports'\n- dependencies: ['classes', 'declare or use class', 'service usage', 'class description']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): 200\n  - iterator(fragment, callback, result):\n    ```python\n      classes = await deps.classes.getResult(fragment)\n      for item in classes:\n        isDeclare = await getIsDeclared(deps, 'declare or use class', fragment, item) \n        if isDeclare:\n            imports = await getServiceImports(fragment)\n            results[item] = imports\n        else:\n            await resolveClassImports(fragment, item, callback, results)\n    ```\n  - getServiceImports(fragment):\n    ```python\n      imported = {} # so we don't list the same thing twice\n      results = []\n\n      services_used = await deps['service usage'].getResult(fragment)\n      if services_used:\n          for service, rec in services_used.items():\n              if not rec['value']:\n                  continue # some services are included in the list cause the previous step had flagged them (cheap run), but then list_service_usage didn't find any usage of them (expensive run)\n              service_loc = rec['source']\n              cur_path_parts = service_loc.split(\" > \")\n# replace all spaces with underscores\n              cur_path_parts = [part.replaceAll(\" \", \"_\") for part in cur_path_parts]\n              cur_path_parts[0] = 'src' # replace the first part with src so that it replaces the name of the project which isn't the root of the source code\n              if not service in imported:\n                  imported[service] = True\n                  service_path = os.path.join(*cur_path_parts, service.replaceAll(\" \", \"_\"))\n                  results.append({'service': service, 'path': service_path, 'service_loc': service_loc})\n      return results  \n    ```     \n  - resolveClassImports(fragment, item, callback, results):\n    ```python\n      declared_in = await shared.getDeclaredIn(deps, 'declare or use class', fragment, item)\n      if not declared_in:\n          raise new Error(f\"can't find import location for component {item} used in {fragment.key}\")\n      else:\n          declaredInFragment = services.projectService.getFragment(declared_in.replaceAll(\"'\", \"\").replaceAll('\"', '')) # remove quotes cause gpr sometimes adds them\n          if not declaredInFragment:\n            raise new Error(f'component declared in {declared_in}, but fragment cant be found at specified index')\n          classes = await deps.classes.getResult(declaredInFragment)\n          if item in classes:\n              path = shared.buildPath(services, declaredInFragment, item)\n              results[item] = path\n          else:\n# if there is only 1 item declared in the fragment, we can presume that's the one we need\n              declaredClasses = await shared.getAllDeclared(deps, 'declare or use class', declaredInFragment)\n              if len(declaredClasses) == 1:\n                  path = shared.buildPath(services, declaredInFragment, declaredClasses[0])\n                  results[item] = path\n              else:\n                  iterator(fragment, item, declaredClasses, declaredInFragment) # declaredInFragment is needed for cleanresponse\n    ```\n  - cleanResponse(response, fragment, item, declaredClasses, declaredInFragment): `return shared.buildPath(services, declaredInFragment, response)` \n  - buildMessage(fragment, item, declaredClasses):\n    - description = await deps['class description'].getResult(fragment)\n      if not description return null\n      description = description[item] # a fragment can have multiple classes, so get the description of the class we are searching for\n      if not description return null\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_class_imports_service_1\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_class_imports_service_2\n        replace:\n        - {{description}}: `description`\n        - {{items}}: `\\n- '.join(declaredClasses)`\n        - {{name}}: `item`\n\n    - return: `result, [ item ]`\n\n"}],"state":"still-valid"},"909ec667-5e52-4b88-b4ea-0fd820255955":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_usage-extractor_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"usage-extractor service\n- The usage-extractor service is responsible for listing all parts of the interface of a service that are actually used in the code.\n- Used to find the exact definitions that are used in the code so that the same name and parameters can be used everywhere.\n- name: 'usage extractor'\n- dependencies: ['component renderer', 'components', 'component imports', 'declare or use component', 'class renderer', 'classes', 'class imports']\n- isJson: true\n- functions:\n  - calculateMaxTokens(inputTokenCount): inputTokenCount / 5\n  - iterator(fragment, callback, result):\n    ```python\n      allCode = None\n      allImports = None\n      components = await deps.components.getResult(fragment)\n      primary = await deps['primary component'].getResult(fragment)\n      toRender, used = await getToRenderAndUsed(deps, fragment, components)\n# only search for usage in code for components that get rendered by this fragment, so not in the used items list\n      fragmentCode = deps['component renderer'].cache.getFragmentResults(fragment.key)\n      primaryCodeFile = fragmentCode[primary]\n      for component in toRender:\n        if component != primary and primaryCodeFile:\n# the primary component can also use the other components, so if the primary is already rendered, see how other components are used in primary.\n          code = readFile(primaryCodeFile)\n          callback(fragment, component, primary, fragment, code, True)\n        for checkAgainst in services.projectService.textFragments:\n# get code files that were rendered from the cache, otherwise we get circular ref.\n# we only want to find out how it is used in the already rendered code, not all\n          allCode = deps['component renderer'].cache.getFragmentResults(checkAgainst.key)\n          allImports = deps['component imports'].cache.getFragmentResults(checkAgainst.key)\n          if allCode and allImports:\n            for key, value in allCode.items():\n              imports = allImports[key]\n# only check the code if the fragment we are checking the usage of, was used in the fragment being checked against.\n              if fragment.key in imports:\n                code = readFile(value)\n                callback(fragment, component, key, checkAgainst, code, True)\n# classes that are found in a fragment, are always declared (due to the way it was asked from the llm)\n      classes = await deps.classes.getResult(fragment)\n      for item in classes:\n        for checkAgainst in services.projectService.textFragments:\n# get code files that were rendered from the cache, otherwise we get circular ref.\n# we only want to find out how it is used in the already rendered code, not all\n          allCode = deps['class renderer'].cache.getFragmentResults(checkAgainst.key)\n          allImports = deps['class imports'].cache.getFragmentResults(checkAgainst.key)\n          if allCode and allImports:\n            for key, value in allCode.items():\n              imports = allImports[key]\n# only check the code if the fragment we are checking the usage of, was used in the fragment being checked against.\n              if fragment.key in imports:\n                code = readFile(value)\n                callback(fragment, component, key, checkAgainst, code, False)\n# a class can be used by other classes and by other components, so check both\n          allCode = deps['component renderer'].cache.getFragmentResults(checkAgainst.key)\n          allImports = deps['component imports'].cache.getFragmentResults(checkAgainst.key)\n          if allCode and allImports:\n            for key, value in allCode.items():\n              imports = allImports[key]\n# only check the code if the fragment we are checking the usage of, was used in the fragment being checked against.\n              if fragment.key in imports:\n                code = readFile(value)\n                callback(fragment, component, key, checkAgainst, code, True)                \n    ```\n  - buildMessage(fragment, item, service, serviceFragment, code, isComponent):\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_usage_extractor_service_1\n          replace:\n          - {{name}}: `service`\n          - {{type}}: `if isComponent: 'component' else: 'class'`\n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_usage_extractor_service_2\n        replace:\n        - {{name}}: `service`\n        - {{code}}: `code`\n\n\n      - role: assistant, content: the value of the constant resources.res_web_client_plugins_transformers_usage_extractor_service_3\n        replace:\n          - {{name}}: `service`\n\n    - return: `result, [ item, serviceFragment.key, service ]`    \n"}],"state":"out-of-date"},"a8c4ac08-83f9-46e4-8b78-6feba196dada":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_consumed-interfaces-component_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"consumed-interfaces-component service\n- The consumed-interfaces-component is responsible for filtering the interface definitions of all imports done by a component to only those items that are used in the description.\n- Used to remove all definitions from the prompt that have no relationship to the current task as to not confuse the llm with lists of unused functions, fields,...\n- name: 'consumed interfaces component'\n- dependencies: ['components', 'component imports', 'found interface parts', 'component exact description', 'global component features']\n- isJson: true\n- functions:\n  - calculateMaxTokens(inputTokenCount): inputTokenCount\n  - iterator(fragment, callback, result): \n    ```python\n      components = await deps.components.getResult(fragment)\n      for component in components:\n        importsList = await deps['component imports'].getResult(fragment)\n        if importsList:\n          importsList = importsList[component] \n        if importsList:\n          componentDesc = (await deps['component exact description'].getResult(fragment))?.[component]\n          for import_def in importsList:\n            service = import_def['service']\n            serviceLoc = import_def['service_loc']\n            serviceFragment = services.projectService.getFragment(serviceLoc)\n            if not serviceFragment:\n              raise new Error(f'fragment with key {serviceLoc} not found in the project')\n            interfaceDef = (await deps['found interface parts'].getResult(serviceFragment))?.[service]\n            if interfaceDef:\n              fullDescription = componentDesc\n              globalInterfaceDef = await deps['global component features'].getResults(serviceFragment)\n              if globalInterfaceDef:\n                fullDescription += '\\n'\n                  for key, value in globalInterfaceDef.items():\n                    fullDescription += f'\\n{value}'\n              interfaceDef = formatInterface(interfaceDef)\n              callback(fragment, component, service, serviceLoc, interfaceDef, fullDescription)\n    ```\n  - formatInterface(interfaceDef):\n    ```python\n      result = ''\n      for key, value in interfaceDef.items():\n        result += f'- {key}: {value}\\n'\n      return result\n    ```\n  - buildMessage(fragment, item, service, serviceLoc, interfaceDef, fullDescription):\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_consumed_interfaces_component_service_1\n        replace:\n        - {{name}}: `service`\n        - {{interface}}: `interfaceDef`\n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_consumed_interfaces_component_service_2\n        replace:\n        - {{full}}: `fullDescription`\n\n    - return: `result, [ item, service ]`\n"}],"state":"still-valid"},"f5b1a11b-d157-4b2e-b2ca-05e90fe093ec":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_consumed-interfaces-class_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"consumed-interfaces-class service\n- The consumed-interfaces-class is responsible for filtering the interface definitions of all imports done by a class to only those items that are used in the description.\n- Used to remove all definitions from the prompt that have no relationship to the current task as to not confuse the llm.\n- name: 'consumed interfaces class'\n- dependencies: ['classes', 'class imports', 'found interface parts', 'class description']\n- isJson: true\n- functions:\n  - calculateMaxTokens(inputTokenCount): inputTokenCount\n  - iterator(fragment, callback, result): \n    ```python\n      classes = await deps.classes.getResult(fragment)\n      for item in components:\n        importsList = await deps['class imports'].getResult(fragment)\n        if importsList:\n          importsList = importsList[item] \n        if importsList:\n          classDesc = (await deps['class description'].getResult(fragment))?.[item]\n          for import_def in importsList:\n            service = import_def['service']\n            serviceLoc = import_def['service_loc']\n            serviceFragment = services.projectService.getFragment(serviceLoc)\n            if not serviceFragment:\n              raise new Error(f'fragment with key {serviceLoc} not found in the project')\n            interfaceDef = (await deps['found interface parts'].getResult(serviceFragment))?.[service]\n            if interfaceDef:\n              fullDescription = classDesc\n              interfaceDef = formatInterface(interfaceDef)\n              callback(fragment, service, serviceLoc, interfaceDef, fullDescription)\n    ```\n  - formatInterface(interfaceDef):\n    ```python\n      result = ''\n      for key, value in interfaceDef.items():\n        result += f'- {key}: {value}\\n'\n      return result\n    ```\n  - buildMessage(fragment, item, service, serviceLoc, interfaceDef, fullDescription):\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_consumed_interfaces_class_service_1\n        replace:\n        - {{name}}: `service`\n        - {{interface}}: `interfaceDef`\n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_consumed_interfaces_class_service_2\n        replace:\n        - {{full}}: `fullDescription`\n\n    - return: `result, [ item, service ]`\n"}],"state":"still-valid"},"dc306c1a-905d-4a46-ac91-af373f97f720":{"result":"C:\\Users\\janbo\\Documents\\dev\\markdownCode\\src\\web_client\\output\\web_client_plugins_transformers_component_renderer_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, resultSetter) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount.total + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"component-renderer service\n- the component-renderer service is responsible for generating all the code related to UI components.\n- used to build UI applications\n- name: 'component renderer'\n- dependencies: ['components', 'declare or use component', 'is service singleton', 'component imports', 'primary component', 'consumed interfaces component', 'usage extractor', 'component exact description', 'consumed interfaces class', 'constants']\n- isJson: false\n- functions: \n  - calculateMaxTokens(inputTokenCount, modelOptions): modelOptions.maxTokens - 1000\n  - iterator(fragment, callback, result): \n    ```python\n      renderToPath = shared.getPath(services, fragment)\n      components = await deps.components.getResult(fragment)\n      primary = await deps['primary component'].getResult(fragment)\n      if not primary:\n        raise Exception('no primary found for ', fragment.title)\n      [toRender, used] = await shared.getToRenderAndUsed(deps, fragment, components)\n      await callback(fragment, primary, components, renderToPath)\n      for component in toRender:\n        if component != primary:\n          await callback(fragment, component, components, renderToPath) # renderToPath for the cleanup (which saves)\n    ```\n  - cleanResponse(response, fragment, component, components, renderToPath): save to file\n    ```python\n      response = response.strip() # need to remove the newline at the end\n      if response.startswith(\"```javascript\"):\n          response = response[len(\"```javascript\"):]\n      if response.endswith(\"```\"):\n          response = response[:-len(\"```\")]\n      fullPath = path.join(services.folderService.output, renderToPath)\n      if not os.path.exists(fullPath):\n          os.makedirs(fullPath)\n      filePath = os.path.join(fullPath, component + \".js\")\n      with open(filePath, \"w\") as writer:\n          writer.write(response)\n      return filePath\n    ```    \n  - buildMessage(fragment, component, components, renderToPath):\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_component_renderer_service_1\n        replace:\n        - {{name}}: `component`\n        - {{devStack}}: `services.projectService.textFragments[1]?.lines.join('\\n').trim()`  \n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_component_renderer_service_2\n        replace:\n        - {{name}}: `component`\n        - {{ownDescription}}: `if len(components) > 1: (await deps['component exact description'].getResult(fragment))?.[component] else: '\\n'.join(fragment.lines)`\n        - {{externalDescription}}:  `await shared.getExternalDescription(deps, fragment, component)`\n        - {{otherInterfaces}}: `await shared.getOtherInterfaces(deps, fragment, component)`\n        - {{importsToAdd}}: `await shared.getAllImports(deps, 'component imports', services, fragment, component, renderToPath)`\n\n      - role: assistant, content: the value of the constant resources.res_web_client_plugins_transformers_component_renderer_service_3\n    - return: `result, [ component ]`\n\n"}],"state":"still-valid"},"6c60a63e-97d0-4fcf-a230-a7b5aaf45c7f":{"result":"C:\\Users\\janbo\\Documents\\dev\\markdownCode\\src\\web_client\\output\\web_client_plugins_transformers_class_renderer_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, resultSetter) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount.total + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"class-renderer service\n- the class-renderer service is responsible for generating all the code for the services in the form of classes.\n- used to build UI applications\n- name: 'class renderer'\n- dependencies: ['classes', 'declare or use class', 'is service singleton', 'class imports', 'primary class', 'consumed interfaces class', 'usage extractor']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount, modelOptions): modelOptions.maxTokens\n  - iterator(fragment, callback, result): \n    ```python\n      renderToPath = shared.getPath(services, fragment)\n      classes = await deps.classes.getResult(fragment)\n      primary = await deps['primary class'].getResult(fragment)\n      if not primary:\n        raise Exception('no primary found for ', fragment.title)\n      await callback(fragment, primary, classes, renderToPath)\n      for item in classes:\n        if item != primary:\n          await callback(fragment, item, classes, renderToPath) # renderToPath for the cleanup (which saves)\n    ```\n  - cleanResponse(response, fragment, item, classes, renderToPath): save to file\n    ```python\n      response = response.strip() # need to remove the newline at the end\n      if response.startswith(\"```javascript\"):\n          response = response[len(\"```javascript\"):]\n      if response.endswith(\"```\"):\n          response = response[:-len(\"```\")]\n      fullPath = os.path.join(services.folderService.output, renderToPath)\n      if not os.path.exists(fullPath):\n          os.makedirs(fullPath)\n      filePath = os.path.join(fullPath, item + \".js\")\n      with open(filePath, \"w\") as writer:\n          writer.write(response)\n      return filePath\n    ```    \n  - buildMessage(fragment, item, classes, renderToPath):\n    - result (json array):\n      - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_class_renderer_service_1\n        replace:\n        - {{name}}: `item`\n        - {{devStack}}: `services.projectService.textFragments[1]?.lines.join('\\n')`  \n\n      - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_class_renderer_service_2\n        replace:\n        - {{name}}: `item`\n        - {{ownDescription}}: `if len(classes) > 1: await deps['class exact description'].getResult(fragment) else: '\\n'.join(fragment.lines)`\n        - {{externalDescription}}:  `await shared.getExternalDescription(deps, fragment, item)`\n        - {{otherInterfaces}}: `await shared.getOtherInterfaces(deps, fragment, item)`\n        - {{importsToAdd}}: `await shared.getAllImports(deps, 'class imports', services, fragment, item, renderToPath)`\n\n      - role: assistant, content: the value of the constant resources.res_web_client_plugins_transformers_class_renderer_service_3\n    - return: `result, [ item ]`\n"}],"state":"still-valid"},"a8095359-c06a-4809-b384-e21a2682c454":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_render_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"render service\n- the render service is the main transformer responsible for generating code from fragments.\n- used to render code\n- name: 'renderer'\n- isEntryPoint: true\n- dependencies: ['class renderer', 'component renderer']\n- functions:\n  - iterator(fragment, callback, result): \n    ```python\n      result['components'] = await deps['component renderer'].getResult(fragment)\n      result['classes'] = await deps['class renderer'].getResult(fragment)\n    ```\n  - buildMessage(fragment, item, classes, renderToPath): `return ''`\n"}],"state":"still-valid"},"ca958867-e3cb-451a-93f9-8b759bf22255":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web-client_plugins_transformers_update-code_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, result) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"update-code service\n- The update-code service can be used to update the code that was rendered for a fragment according to the new specs of that fragment.\n- Useful to check if the system understands the fragment and can be used as input for other processes.\n- name: 'update code'\n- dependencies: ['constants', 'renderer']\n- isJson: false\n- calculateMaxTokens(inputTokenCount, modelOptions): modelOptions.maxTokens\n- iterator(fragment, callback, result): \n    ```python\n      files = await deps.renderer.getResult(fragment)\n      if files:\n        if files.components:\n          for file in files.components:\n            code = readFile(file)\n            iterator(fragment, code)\n        if files.classes:\n          for file in file.classes:\n            code = readFile(file)\n            iterator(fragment, code)\n    ```\n- build-message(fragment, code):\n  - result (json array):\n    - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_update_code_service_1\n      replace:\n        - {{name}}: `services.projectService.textFragments[1]?.lines.join('\\n')`\n\n    - role: user, content:  the value of the constant resources.res_web_client_plugins_transformers_update_code_service_2\n        replace:\n            - {{code}}: `code`\n            - {{specs}}: `await deps.constants.getResult(fragment)`\n\n  - return result, [ ]"}],"state":"still-valid"},"42397e3f-4fe9-4227-a8f1-f2e396182839":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web_client_plugins_transformers_primary_component_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, resultSetter) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount.total + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"primary-component service\n- The primary-component service is responsible for identifying the component that is most of all described and stands out as the most important component in the text-fragment.\n- part of determining which components to render and which to import\n- name: 'primary component'\n- dependencies: ['components']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 (just return a fixed size cause we only want 1 name coming back, shouldn't be too long)\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        components = await deps.components.getResult(fragment)  \n        if len(components) > 1:\n          await callback(fragment, components)\n        elif len(components) == 1:\n          resultSetter(components[0])\n      ```    \n  - buildMessage(fragment, components):\n    - result (json array):\n    - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_primary_component_service_1\n    - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_primary_component_service_2\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `fragment.lines.join('\\n')`\n      - {{components}}: `JSON.stringify(components)`\n\n    - role: assistant, content: the value of the constant resources.res_web_client_plugins_transformers_primary_component_service_3\n    - return: `result, [ ]`\n\n"}],"state":"still-valid"},"8325ad6e-bbd0-4925-8130-d30f0f257e3a":{"result":"C:\\Users\\janbo\\Documents\\mark_plugins\\web_client\\output\\web_client_plugins_transformers_primary_class_service.js","prompt":[{"role":"system","content":"Act as a full-stack ai software developer.\nIt is your task to write a javascript module according to the specifications.\n\nThe module should export an object containing the following fields:\n- getDescription(): (required) a function that returns a json object containing the fields:\n  - name: (required) name of the transformer\n  - dependencies: (required)list of names of other transformers\n  - isJson: (required)boolean, true if the transformer produces json data.\n  - description: (optional) a string that describes what the transformer does\n- buildMessage(fragment): (required) a function that builds and returns the prompt that should be used for the transformer and text-fragment. Note: if there is an iterator function, the argument list may be different and must match the argument list of the callback parameter of the iterator.\n- renderResult(fragment): (optional) a function that renders the result for the specified fragment.\n- renderResults(fragments): (optional) a function that renders a result which requires all the fragments in the project.\n- calculateMaxTokens(inputTokenCount): (optional) a function that calculates and returns the expected maximum token count used for the transformer's prompt\n- iterator(fragment, callback, resultSetter) (optional): a function that iterates over 1 or more values and calls the callback function for each set of values that needs to be processed. the parameters of the callback function are passed on to the buildMessage function. \n- cleanResponse(response) (optional): cleans or modifies the response that was produced by the llm before saving it.\n\nuse the following development stack:\n- developed in javascript (ES5)\n- The UI is built using react and antd\n\nexample response:\n\n```javascript\nconst resources = require('./resources.json');\nconst services = {}; // must always be present\nconst deps = {}; // must always be present\nconst shared = require('./shared.js');\nfunction getDescription() {\n  return {name: 'test', dependencies: ['constants'], isJson: true};\n}\nasync function buildMessage(fragment) {\n  var result = [\n      {\n        role: 'system',\n        content: resources.MarkdownCode_services_transformers_compress_service_0,\n      },\n      {\n        role: 'user',\n        content: await deps.constants.getResult(fragment),\n      },\n    ];\n\n    return [result, [ ]];\n}\nfunction calculateMaxTokens(inputTokenCount) {\n  return inputTokenCount.total + 1;\n}\nmodule.exports = { getDescription, buildMessage, calculateMaxTokens, services, deps };\n```\nDo not include an introduction or any explanation, only generate the code. Only include function that are required or the user included, do not write any optional functions from the example when not provided in the following text. Include a description field when possible."},{"role":"user","content":"primary-class service\n- The primary-class service is responsible for identifying the class that is most of all described and stands out as the most important item in the text-fragment.\n- part of determining which classes to render and which to import\n- name: 'primary class'\n- dependencies: ['classes', 'constants']\n- isJson: false\n- functions:\n  - calculateMaxTokens(inputTokenCount): return 120 \n    just return a fixed size cause we only want 1 name coming back, shouldn't be too long\n  - iterator(fragment, callback, resultSetter):\n      ```python\n        classes = await deps.classes.getResult(fragment)  \n        if len(classes) > 1:\n          await callback(fragment, classes)\n        elif len(classes) == 1:\n          resultSetter(classes[0])\n      ```    \n  - buildMessage(fragment, classes):\n    - result (json array):\n    - role: system, content: the value of the constant resources.res_web_client_plugins_transformers_primary_class_service_1\n    - role: user, content: the value of the constant resources.res_web_client_plugins_transformers_primary_class_service_2\n      replace:\n      - {{title}}: `fragment.title`\n      - {{content}}: `await deps.constants.getResult(fragment)`\n      - {{classes}}: `JSON.stringify(classes)`\n\n    - role: assistant, content: the value of the constant resources.res_web_client_plugins_transformers_primary_class_service_3\n    - return: `result, [ ]`\n"}],"state":"still-valid"}},"secondaryCache":{"ac18eefb-e5c5-457e-b0b1-c68bbb862a85":["ac18eefb-e5c5-457e-b0b1-c68bbb862a85"],"0da9552a-d9c0-404a-a806-f02011371ff4":["0da9552a-d9c0-404a-a806-f02011371ff4"],"fecfce6f-c166-4101-b713-cb29fa7a6bcd":["fecfce6f-c166-4101-b713-cb29fa7a6bcd"],"1480dd97-cec4-402d-bc5e-3cb0ce666210":["1480dd97-cec4-402d-bc5e-3cb0ce666210"],"318cec5a-9882-4320-96a6-e1ebc6762c6b":["318cec5a-9882-4320-96a6-e1ebc6762c6b"],"7338df56-c381-4acb-8f5e-25587f5bd08d":["7338df56-c381-4acb-8f5e-25587f5bd08d"],"892f1f34-3fd1-4a59-bfe4-16552f49a9e1":["892f1f34-3fd1-4a59-bfe4-16552f49a9e1"],"53ce18ed-32d9-4d75-a1fb-daa6fca3055a":["53ce18ed-32d9-4d75-a1fb-daa6fca3055a"],"d295ba37-ab5b-41dc-b0ea-9ce333090530":["d295ba37-ab5b-41dc-b0ea-9ce333090530"],"c04f4d5b-2cf5-46fb-8e99-6050acca9981":["c04f4d5b-2cf5-46fb-8e99-6050acca9981"],"0553c884-b0fd-41f6-8504-a26e63741a42":["0553c884-b0fd-41f6-8504-a26e63741a42"],"543b6187-6bb9-44fb-a2f0-3d1019a97794":["543b6187-6bb9-44fb-a2f0-3d1019a97794"],"b85f66e1-2a2b-4739-ac8e-ed15cd62f716":["b85f66e1-2a2b-4739-ac8e-ed15cd62f716"],"9914d2b4-da7a-4e0d-af78-502bdb31995d":["9914d2b4-da7a-4e0d-af78-502bdb31995d"],"42252887-b7ee-45f1-bf6f-dc692f996bc0":["42252887-b7ee-45f1-bf6f-dc692f996bc0"],"fe77852e-f251-4480-b206-e83a0159bf0b":["fe77852e-f251-4480-b206-e83a0159bf0b"],"35493b3f-918b-4441-b521-93269ef6921f":["35493b3f-918b-4441-b521-93269ef6921f"],"91c07e2e-b004-4ab4-8d1d-4a8cc69beee1":["91c07e2e-b004-4ab4-8d1d-4a8cc69beee1"],"909ec667-5e52-4b88-b4ea-0fd820255955":["909ec667-5e52-4b88-b4ea-0fd820255955"],"a8c4ac08-83f9-46e4-8b78-6feba196dada":["a8c4ac08-83f9-46e4-8b78-6feba196dada"],"f5b1a11b-d157-4b2e-b2ca-05e90fe093ec":["f5b1a11b-d157-4b2e-b2ca-05e90fe093ec"],"dc306c1a-905d-4a46-ac91-af373f97f720":["dc306c1a-905d-4a46-ac91-af373f97f720"],"6c60a63e-97d0-4fcf-a230-a7b5aaf45c7f":["6c60a63e-97d0-4fcf-a230-a7b5aaf45c7f"],"a8095359-c06a-4809-b384-e21a2682c454":["a8095359-c06a-4809-b384-e21a2682c454"],"ca958867-e3cb-451a-93f9-8b759bf22255":["ca958867-e3cb-451a-93f9-8b759bf22255"],"42397e3f-4fe9-4227-a8f1-f2e396182839":["42397e3f-4fe9-4227-a8f1-f2e396182839"],"8325ad6e-bbd0-4925-8130-d30f0f257e3a":["8325ad6e-bbd0-4925-8130-d30f0f257e3a"]},"overwrites":{},"lastSaveDate":"2024-01-26T15:47:02.511Z"}